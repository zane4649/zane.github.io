<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wenbing&#39;s Blog</title>
  
  <subtitle>但行好事，莫问前程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-29T13:26:04.801Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Wenbing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018年随手一记</title>
    <link href="http://yoursite.com/2018/03/29/2018%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/03/29/2018随手一记/</id>
    <published>2018-03-29T04:37:17.843Z</published>
    <updated>2018-03-29T13:26:04.801Z</updated>
    
    <content type="html"><![CDATA[<p>前几天跟阿旭聊天的时候，突然说到了我的博客，发现我的域名已经过期了(很尴尬),从去年离职换了工作之后，就一直没怎么去打理博客了，不知道怎么就变的这么懒了(可能是老了)，想当年我也是高产的博主啊。</p><p>之前博客搭建在公司的电脑上，离职后在家里又重新搭建了一次，准备继续更新博客，然而还没用多久，我就换固态硬盘了!!! 东芝(TOSHIBA)-Q200系列 240G,(为什么要选东芝？ 因为是东芝原厂MLC颗粒啊！),不得不说换了固态硬盘之后明显的感觉到电脑的性能提升了很多，也可能是我电脑太垃圾了(用了四五年的 “ThinkPad”),<a id="more"></a>想更新博客又要重新搭建环境了，然后太懒了就一直没动。。。。</p><p>直到2018年3月26号，重新续费了一个域名，换成www.belongwithme.com了，才开始重新搭建了一下环境，安装Git，Node.Js,Hexo等， 然而创建分支的时候，还没有合并分支，手抖了不知道怎么输入了hexo d 提交代码了，直接都提交到master了，之前所有的博客都被重新覆盖了，都变成2018-03-27那天发布了，被自己蠢哭！！！重新搭建了一下，其实也没费什么力气，就是装几个软件，之前的代码直接 git  clone一下就好了，不过在分支管理的时候还是有点麻烦，要多看一下官方文档，用了一下新的评论系统，虽然之前国内的有言也可以用，但是总感觉别扭，不怎么好看，这次换成了livere(来必力)，感觉就好多了，就是加载比较慢。。。</p><p>下面说一下最近的生活吧，最近刚学完了一些docker的课程，简单学习了一下docker的网络连接，数据的管理，以及跨主机的访问是如何实现的，不得不说docker容器技术确实很热门，很轻量，但是很高效，比起传统的方案优点很多！</p><p>除了学习这些技术之外，最近在看”吴军老师”的《文明之光》，之前也看过”吴军老师”写的《浪潮之巅》，主要讲IT行业发展史，HP,IBM,APPLE,微软，Google,SUN,Cisco,这些公司是怎么崛起的，如何站到了互联网这个浪潮的巅峰，以及斯坦福大学为什么可以成为科技公司的人才摇篮！一个偶然的机会看了《文明之光》这本书，主要是讲历史的，从最开始的宇宙再到地球生命的起源，从古埃及文明到美索不达米亚文明，再到古代科学之路，大开眼界，之前一直觉得”中华文明”是最源远流长的，动不动就中华上下5000年文化，我们从小报纸电视媒体上都是这么说的，看了吴军老师的讲解之后才知道地球上有一个国家叫古埃及，在中国商朝刚建立的时候，古埃及已经存在千年而且还出土了文字。。。心碎！才看了百分之十五，后面看完了有新的收货再分享！</p><p>简单的介绍一下”吴军老师”,吴军老师毕业于清华大学，之前腾讯的副总裁，现任Google的科学家。。。算了不想介绍了，心好痛！还是默默的看书吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天跟阿旭聊天的时候，突然说到了我的博客，发现我的域名已经过期了(很尴尬),从去年离职换了工作之后，就一直没怎么去打理博客了，不知道怎么就变的这么懒了(可能是老了)，想当年我也是高产的博主啊。&lt;/p&gt;
&lt;p&gt;之前博客搭建在公司的电脑上，离职后在家里又重新搭建了一次，准备继续更新博客，然而还没用多久，我就换固态硬盘了!!! 东芝(TOSHIBA)-Q200系列 240G,(为什么要选东芝？ 因为是东芝原厂MLC颗粒啊！),不得不说换了固态硬盘之后明显的感觉到电脑的性能提升了很多，也可能是我电脑太垃圾了(用了四五年的 “ThinkPad”),
    
    </summary>
    
      <category term="日常生活" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Centos7 编译安装MariaDB-10.1.22</title>
    <link href="http://yoursite.com/2018/03/27/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85mysql/"/>
    <id>http://yoursite.com/2018/03/27/编译安装mysql/</id>
    <published>2018-03-27T05:22:38.602Z</published>
    <updated>2017-09-27T06:25:44.876Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i.imgur.com/GKr7XTn.jpg" alt=""></p><p><strong>目的</strong>：使用源码包编译安装Mariadb <a id="more"></a></p><h2 id="卸载安装的mariadb"><a href="#卸载安装的mariadb" class="headerlink" title="卸载安装的mariadb"></a>卸载安装的mariadb</h2><pre><code>[root@localhost /]# rpm -qa | grep mariadbmariadb-libs-5.5.44-2.el7.centos.x86_64[root@localhost /]# rpm -e mariadb-libs-5.5.44-2.el7.centos.x86_64</code></pre><h2 id="创建用户和组"><a href="#创建用户和组" class="headerlink" title="创建用户和组"></a>创建用户和组</h2><pre><code>[root@localhost /]# groupadd  mysql[root@localhost /]# useradd -g mysql mysql</code></pre><h2 id="创建文件目录"><a href="#创建文件目录" class="headerlink" title="创建文件目录"></a>创建文件目录</h2><pre><code>[root@localhost /]# mkdir /mydata/data -pv[root@localhost /]# chown mysql.mysql data</code></pre><h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><pre><code>[root@localhost /]# yum groupinstall -y Development Tools #环境开发工具包[root@localhost /]# yum -y install gcc gcc-c++ make cmake ncurses ncurses-devel man ncurses libxml2 libxml2-devel openssl-devel bison bison-devel# cmake：由于从MySQL5.5版本开始弃用了常规的configure编译方法，所以需要cmake编译器，用于设置mysql的编译参数。（如：安装目录，数据存放目录，字符编码，排序规则等）# boost：从MySQL5.7.5开始Boost库是必需的，mysql源码中用到了C++的Boost库，要求必需安装Boost1.59.0或以上版本。# GCC：这是Linux下的C语言编译工具，MySQL源码编译完全由C和C++编写，要求必需安装GCC。# bison：Linux下C/C++语法分析器# ncurses：字符终端处理库。.........</code></pre><h2 id="编译准备"><a href="#编译准备" class="headerlink" title="编译准备"></a>编译准备</h2><pre><code>[root@localhost /]# tar -xvf mariadb-10.1.22.tar.gz -C /usr/local[root@localhost /]# cd /usr/local/[root@localhost /]# ln -sv mariadb-10.1.22 mysql #做软链接[root@localhost /]# chown -R root:mysql ./* #修改配置文件的属组</code></pre><h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><pre><code>[root@localhost mysql]#  cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql #Mysql安装的根目录             -DMYSQL_DATADIR=/mydata/data            #Mysql数据库文件存放路径             -DWITH_INNOBASE_STORAGbE_ENGINE=1       #添加InoooDB引擎              -DWITH_ARCHIVE_STORAGE_ENGINE=1         #添加ARCHIVE引擎             -DWITH_BLACKHOLE_STORAGE_ENGINE=1       #添加BLACKHOLE引擎             -DWITH_SSL=system -DWITH_ZLIB=system    #可以用systemd控制服务             -DWITH_LIBWRAP=0              #             -DMYSQL_UNIX_ADDR=/tmp/mysql.sock       #指定sock文件的位置             -DEFAULT_CHARSET=utf8 #Mysql默认字符集为utf-8               -DDEFAULT_COLLATION=utf8_general_ci     #支持默认字符集校对规则[root@localhost mysql]# make &amp;&amp; make install #编译并安装 </code></pre><h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><pre><code>四个数据库，information_schema ，performance_schema，test ，mysql源数据库（用户，权限，字段，字段名。。。。）, 自行脚本生成，脚本在mysql/scripts 执行一下就可以安装了[root@localhost mysql]# scripts/mysql_install_db --user=mysql --datadir=/mysql/data[root@localhost mysql]# scripts/mysql_install_db --help [root@localhost mysql]# ls /mydata/data/aria_log.00000001  ib_logfile0                multi-master.info  mysql-bin.indexaria_log_control   ib_logfile1                mysql              performance_schemaibdata1            localhost.localdomain.pid  mysql-bin.000001   test</code></pre><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><pre><code>[root@localhost mysql]# mkdir /etc/mysql[root@localhost mysql]# cp support-files/my-large.cnf /etc/mysql/my.cnf[root@localhost mysql]# vim /etc/mysql/my.cnf datadir = /mydata/data      #数据文件的路径innodb_file_per_table = on  #修改InnoDB为独立表空间模式skip_name_resolve = on      #跳过名称反解，将客户端连接IP反解成主机名，然后做权限检查</code></pre><h2 id="创建服务脚本"><a href="#创建服务脚本" class="headerlink" title="创建服务脚本"></a>创建服务脚本</h2><pre><code>[root@localhost mysql]# cp support-files/mysql.server /etc/rc.d/init.d/mysqld [root@localhost mysql]# chkconfig --add mysqld #设置开机启动[root@localhost mysql]# chkconfig --list mysqld [root@localhost mysql]# service mysqld start[root@localhost mysql]# ss -tnlp #查看3306是否被mysql监听LISTEN      0      80                     :::3306                               :::*   users:((&quot;mysqld&quot;,pid=5358,fd=21))</code></pre><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><pre><code>[root@localhost mysql]# vim /etc/profile.d/mysqld.shMYSQL_HOME=/usr/local/mysqlexport PATH=$MYSQL_HOME/bin:$PATH[root@localhost mysql]#  source /etc/profile.d/mysqld.sh #加载环境变量</code></pre><h2 id="连接Mysql"><a href="#连接Mysql" class="headerlink" title="连接Mysql"></a>连接Mysql</h2><pre><code>[root@localhost mysql]# mysqlWelcome to the MariaDB monitor.  Commands end with ; or \g.Your MariaDB connection id is 4Server version: 10.1.22-MariaDB Source distributionCopyright (c) 2000, 2016, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; </code></pre><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><pre><code>启动时报错：/usr/local/mysql//libexec/mysqld: Can&apos;t create/write to file &apos;/var/log/mariadb&apos; (Errcode: 13) 120516 15:23:19 [ERROR] Can&apos;t start server: can&apos;t create PID file: Permission denied  解决方法：chown mysql.mysql /var/log/mariadb/ -R</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i.imgur.com/GKr7XTn.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;：使用源码包编译安装Mariadb
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
      <category term="编译安装Mariadb-10.1" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Mariadb-10-1/"/>
    
  </entry>
  
  <entry>
    <title>windows下安装RabbitMQ</title>
    <link href="http://yoursite.com/2018/03/27/windows%E5%AE%89%E8%A3%85rabbitmq/"/>
    <id>http://yoursite.com/2018/03/27/windows安装rabbitmq/</id>
    <published>2018-03-27T05:22:38.602Z</published>
    <updated>2017-10-09T03:37:48.231Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习Python第11天的课程，讲消息队列，当然说的就是RabbitMQ，于是就想起，写篇博客记录一下安装过程！<br><img src="https://i.imgur.com/RaoQK9b.png" alt=""></p><a id="more"></a><p><strong> 版本说明 </strong><br>    OS: win10_1703<br>    Erlang: 20.1<br>    RabbitMQ: 3.6.12</p><p><strong> 安装erlang </strong></p><pre><code>RabbitMQ是建立Erlang平台上，所以先要装上erlang我这里安装的版本是：otp_win64_20.1（各人按自己系统版本下载）官方下载地址：http://www.erlang.org/downloads</code></pre><p><strong>添加环境变量</strong><br><img src="https://i.imgur.com/1kYBja7.png" alt=""></p><p><strong>安装RabbitMQ</strong></p><pre><code>我这里下载的版本是：rabbitmq-server-3.6.12官方下载地址：http://www.rabbitmq.com/download.html</code></pre><p><strong>配置RabbitMQ</strong></p><pre><code>激活rabbitmq-plugins(C:\Program Files\RabbitMQ Server\rabbitmq_server-3.6.12\sbin\rabbitmq-plugins.bat)命令：rabbitmq-plugins enable rabbitmq_management需要重启服务才能生效</code></pre><p><img src="https://i.imgur.com/bcV9bg6.png" alt=""></p><p><strong>访问控制台</strong><br>     上面步骤都配置好后，浏览器地址栏输入：<a href="http://localhost:15672(" target="_blank" rel="external">http://localhost:15672(</a> 默认用户和密码都是guest)</p><p> <img src="https://i.imgur.com/4BWu5BR.png" alt=""></p><p>最后：简单的配置到这里就结束了，后续有其他的要求到时候再更新博客</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天学习Python第11天的课程，讲消息队列，当然说的就是RabbitMQ，于是就想起，写篇博客记录一下安装过程！&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/RaoQK9b.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Python学习之第五天</title>
    <link href="http://yoursite.com/2018/03/27/python%E7%AC%AC%E4%BA%94%E5%A4%A9/"/>
    <id>http://yoursite.com/2018/03/27/python第五天/</id>
    <published>2018-03-27T05:22:38.570Z</published>
    <updated>2017-09-27T10:42:25.726Z</updated>
    
    <content type="html"><![CDATA[<p>最近这段时间，利用业余时间学习了一下Python,写篇博客算是记录一下相关的知识点，方便以后查询，也算做个小总结！</p><p><img src="https://i.imgur.com/RYTHJeH.jpg" alt=""><br><a id="more"></a><br><strong>第五天学习主要类容：模块定义，导入，正则表达式等</strong></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h2><pre><code>模块：用来从逻辑上组织python代码（变量，函数，类，）本质就是.py结尾的python文件（文件名：test.py,对应的模块名：test）包：用来从逻辑上组织模块的，本质就是一个目录（必须要有一个__init__.py文件）</code></pre><h2 id="导入方法"><a href="#导入方法" class="headerlink" title="导入方法"></a><strong>导入方法</strong></h2><pre><code>import module_nameimport module1_name,module2_name#import module1_name 相当于把整个模块的代码复制给当前一个变量，然后调用from module_zane frome * #导入module_zane模块的所有，一般不建议这么用 from module_zane import m1,m2 #导入module_zane模块的方法from module_zane import name as new_name #从module_zane模块下导入一个模块（赋给另一个变量）#from 相当于只打开了module_name的一个方法</code></pre><h2 id="import本质"><a href="#import本质" class="headerlink" title="import本质"></a><strong>import本质</strong></h2><pre><code>导入&quot;模块&quot;的本质就是把python文件解释一遍导入&quot;包&quot;的本质就是执行该包下的__init__.py文件）import sys,osprint(sys.path)#print(os.path.abspath(__file__)) #abspath：获取当前文件的绝对路径#此时的路径E:/pycharm/s14/day5/module_test/main.py&quot;x = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))#os.path.dirname:获取路径名，这里因为module_test文件在day5路径下，所以要上找两层sys.path.append(x)  #把获取的路径sys.pathimport module_test</code></pre><h2 id="time和datetime模块"><a href="#time和datetime模块" class="headerlink" title="time和datetime模块"></a><strong>time和datetime模块</strong></h2><pre><code>import time     #导入time模块time.time()          #获取时间戳time.timezone()    #获取时区，中国在东8区time.altzone()    #夏令时和UTC(标准时)的差值time.daylight()    #是否使用了夏令时time.sleep()    #沉睡几秒time.gmtime()    #把时间戳转换成元祖，结果是UTC时区time.localtime()#把时间戳转换成元祖，结果是本地时区time.mktime()   #将元祖转换成时间戳time.strftime() #将元祖转换成字符串格式显示（例：time.strftime(&quot;%Y-%m:%d %H:%M:%S&quot;,x)）time.strptime() #将字符串转换成元祖形式（time.strptime(&apos;2017-09:06 22:19:00&apos;,&quot;%Y-%m:%d %H:%M:%S&quot;））time.astime()   #将元祖转换成字符转形式time.ctime()    #将时间戳转换成字符串形式时间加减：import datatimeprint(datetime.datetime.now()) #返回当前时间print(datetime.datetime.now() + datetime.timedelta(3)) #当前时间+3天print(datetime.datetime.now() + datetime.timedelta(-3)) #当前时间-3天print(datetime.datetime.now() + datetime.timedelta(hours=3)) #当前时间+3小时print(datetime.datetime.now() + datetime.timedelta(hours+30)) #当前时间+30分钟c_time = datetime.datetime.now() #当前时间：2017-09-06 22:53:53.191920print(c_time.replace(minute=3,hour=2)) #时间替换为：2017-09-06 02:03:53.191920</code></pre><h2 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a><strong>random模块</strong></h2><pre><code>import randomrandom.random() #0到1之间的随机数random.randit(1,3) #生成一个指定范围的整数 random.shuffle() #洗牌（例如：i=[1,2,3,4] random.shuffle(i) 输入为：[2,1,4,3）random.choice(&apos;afsdsgfd&apos;) #随机字符random.sample(&apos;afgagradf&apos;,3) #选取特定数量的字符练习：生成4位随机数import randomcheckcode=&apos;&apos;for i in range(4):    current=random.randint(1,9)        if current ==i:                tmp = chr(random.randint(65,90))           else:    tmp = random.randint(0,9)checkcode+=str(tmp)\print(checkcode)</code></pre><h2 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a><strong>os模块</strong></h2><pre><code>&quot;os&quot;模块是提供对操作系统进行调用的接口import osos.getcwd() #获取当前工作目录os.chdir(r&quot;C:\User&quot;) #切换目录os.curdir  #返回当前目录os.pardir  #获取当前目录的父目录os.makedirs(r&quot;C:\a\b\c&quot;) #递归创建目录os.removedirs(r&quot;C:\a\b\c&quot;) #递归删除目录（如果目录为空则删除上级目录）os.mkdir() #创建单级目录os.rmdir() #删除单级目录os.listdir(r&apos;D:&apos;) #列出D盘下所有文件夹os.remove() #删除一个文件os.rename(&quot;oldname&quot;,&quot;newname&quot;) #修改文件名os.stat(path/filename) #获取文件/目录信息os.sep #输出系统路径分隔符os.environ #输出当前系统的环境变量os.pathsep #输出用于分割文件路径的字符串os.system(dir,ipconfig) #执行系统命令os.path.abspath() #获取文件的绝对路径os.path.split() #将path分割成目录，文件名os.path.dirname(r&apos;C:\a\b\test.txt&apos;) #只获取路径（输出结果为：&apos;C:\\a\\b&apos;）os.path.basename(r&apos;C:\a\b\test.txt&apos;) #只获取文件名(输出结果为：‘test.txt’)os.path.exists(r&apos;D:\a&apos;) #判断路径是否存在（存在返回True,不存在返回False）os.path.file(path)  #判断是否为文件os.path.dir(path)  #判断是否为目录os.path.getatime(path) #获取文件或目录最后的存取时间(返回时间戳)os.path.getmtime(path) #获取文件或路径最后的修改时间(返回时间戳)</code></pre><h2 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a><strong>sys模块</strong></h2><pre><code>import syssys.argv #命令行参数List，第一个元素是程序本身路径sys.exit(n) #程序退出，正常返回&apos;0&apos;,其他返回&apos;1-254&apos;sys.version #获取Python版本信息sys.path    #返回模块搜索路径sys.platform #获取操作系统平台信息</code></pre><h2 id="shutil模块"><a href="#shutil模块" class="headerlink" title="shutil模块"></a><strong>shutil模块</strong></h2><pre><code>高级的文件，文件夹，压缩包处理模块shutil.copyfile(&quot;file_name1&quot;,&quot;file_name2&quot;) #复制文件shutil.copytree(&quot;source&quot;,&quot;new_name&quot;) #递归复制文件目录shutil.rmtree(&quot;file_name&quot;) #递归删除文件shutil.make_archive(&quot;压缩文件名&quot;，“type”,&quot;path&quot;) #压缩文件 (例：shutil.make_archive(&quot;shutil_test&quot;,&quot;gzip&quot;,&quot;D:\test.py&quot;))json &amp; picklejson 把python内存中的数据类型转换成字符串（dumps）,调用（loads）pickle 把python特有的类型和python的数据类型进行转换</code></pre><h2 id="json序列化"><a href="#json序列化" class="headerlink" title="json序列化"></a><strong>json序列化</strong></h2><pre><code>序列化就是把python对象编码转换成json格式的字符串import jsoninfo = {    &apos;name&apos;:&apos;zane&apos;,    &apos;age&apos;:22}f = open(&quot;test.txt&quot;,&apos;w&apos;)#print(json.dumps(info))f.write(json.dumps(info)) #dump序列化f.close()</code></pre><h2 id="json反序列化"><a href="#json反序列化" class="headerlink" title="json反序列化"></a><strong>json反序列化</strong></h2><pre><code>反序列化就是把json字符串解码转换成python数据对象import jsonf = open(&quot;test.txt&quot;,&apos;r&apos;)data = json.loads(f.read()) #反序列化loadsprint(data[&quot;age&quot;])f.close()</code></pre><h2 id="configparser模块"><a href="#configparser模块" class="headerlink" title="configparser模块"></a><strong>configparser模块</strong></h2><pre><code>用于生成和修改常见配置文档详情：http://www.cnblogs.com/alex3714/articles/5161349.html</code></pre><h2 id="hashlib模块"><a href="#hashlib模块" class="headerlink" title="hashlib模块"></a><strong>hashlib模块</strong></h2><pre><code>一般用于加密,python3.0里代替了md5模块和sha模块，主要提供了MD5,SHA1,SHA256,SHA512等算法import hashlib# f = hashlib.md5()f.update(b&apos;hello&apos;) #b表示byte类型f.update(b&apos;world&apos;)print(f.digest()) #digest:二进制hashprint(f.hexdigest()) #hexdigest:十六进制hash#md5hash = hashlib.md5()hash.update(b&apos;admin&apos;)print(hash.hexdigest())#sha1hash = hashlib.sha1()hash.update(b&apos;admin&apos;)print(hash.hexdigest())#sha256hash = hashlib.sha256()hash.update(b&apos;admin&apos;)print(hash.hexdigest())#sha512hash = hashlib.sha512()hash.update(b&apos;admin&apos;)print(hash.hexdigest())</code></pre><h2 id="hmac模块"><a href="#hmac模块" class="headerlink" title="hmac模块"></a><strong>hmac模块</strong></h2><pre><code>它内部对我们创建&quot;key&quot;和&quot;内容&quot;再进行处理然后再加密import hmacf = hmac.new(b&apos;123AVC&apos;,&apos;小鸡炖蘑菇&apos;.encode(encoding=&apos;utf-8&apos;))print(f.hexdigest())</code></pre><h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a><strong>re模块</strong></h2><pre><code>&quot;re&quot;模块一般用于正则表达式匹配re.match()      #文本从头开始搜索re.search()     #从整个文本开始搜索re.findall()    #把所有匹配到的字符放到以列表中的元素返回re.splitall()  #以匹配到的字符当作列表分隔符re.sub()        #匹配字符并替换(例:将数字替换成|并且只替换前面两个,                (re.sub(&quot;[0-9]+&quot;,&quot;|&quot;,&quot;abc12de3f45gh&quot;,count=2)) 结果为:&apos;abc|de|f45gh&apos;).         #匹配换行符之外的任意字符^         #匹配字符开头$         #匹配字符结尾+         #匹配前一个字符1次或多次?         #匹配前1个字符1次或0次(例:re.search(&quot;aa?&quot;,&quot;aaa123&quot;) 结果为:aa){m}      #匹配前一个字符m次(例：re.search(&quot;[0-9]{3}&quot;,&quot;aa1x2d456&quot;) 结果为456){n,m}     #匹配前一个字符n到m次(例：re.findall(&quot;[0-9]{1,3}&quot;,&quot;aa1x2d456&quot;) 结果为:1,2,456)|         #匹配左或|右的字符(例:re.search(&quot;abc|ABC&quot;,&quot;ABCxabcDN&quot;) 结果为:ABC)...        #分组匹配\A        #从字符开头匹配 (例：re.search(&quot;\A[0-9]+[a-z]\Z&quot;,&quot;1234a&quot;) 结果为:1234a)\Z        #从字符结尾匹配，同$\d        #匹配数字0-9\D        #匹配非数字意外的字符(包括特殊字符)\w        #匹配字母，数字\W        #匹配特殊字符\s       #匹配空白字符(例:re.search(&quot;\s+&quot;,&quot;a12gdf \r\n  &quot;) 结果为:\r\n\t)例：1,匹配R开头，a结尾字符ChenRonghua123  #re.search(&quot;R[a-z]+a&quot;)2,获取#之间的字符123#hello#     #re.search(&quot;#.+#&quot;)</code></pre><p>文档详细参考：<a href="http://www.cnblogs.com/alex3714/articles/5161349.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5161349.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近这段时间，利用业余时间学习了一下Python,写篇博客算是记录一下相关的知识点，方便以后查询，也算做个小总结！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/RYTHJeH.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 Jdk+Tomcat的安装</title>
    <link href="http://yoursite.com/2018/03/27/tomcat/"/>
    <id>http://yoursite.com/2018/03/27/tomcat/</id>
    <published>2018-03-27T05:22:38.570Z</published>
    <updated>2017-04-25T10:07:55.772Z</updated>
    
    <content type="html"><![CDATA[<p>Java Development Kit（JDK）是太阳微系统针对Java开发人员发布的免费软件开发工具包（SDK，Software development kit）。自从Java推出以来，JDK已经成为使用最广泛的Java SDK。由于JDK的一部分特性采用商业许可证，而非开源。因此，2006年太阳微系统宣布将发布基于GPL的开源JDK，使JDK成为自由软件。<a id="more"></a></p><p>目的：公司开发人员的需要</p><p>安装的版本：<br>jdk版本：1.8.0_121<br>tomcat版本：8.5.13</p><h2 id="Jdk的安装："><a href="#Jdk的安装：" class="headerlink" title="Jdk的安装："></a><strong>Jdk的安装</strong>：</h2><p><strong>先查询是否安装JDK</strong> </p><pre><code>[root@node1 ~]# java -version  #centos7 默认是装的openjdkOpenjdk version &quot;1.8.0_65&quot;OpenJDK Runtime Environment (build 1.8.0_65-b17)OpenJDK 64-Bit Server VM (build 25.65-b01, mixed mode) [root@node1 ~]# yum remove java-1.8.0-openjdk ##直接卸载[root@node1 ~]# java -version  #为什么还有在是吗？？？？Openjdk version &quot;1.8.0_65&quot;OpenJDK Runtime Environment (build 1.8.0_65-b17)OpenJDK 64-Bit Server VM (build 25.65-b01, mixed mode) 正确的方式卸载openjdk：[root@node1 ~]# rpm -qa | grep java #查看装了那些包java-1.7.0-openjdk-1.7.0.91-2.6.2.3.el7.x86_64java-1.7.0-openjdk-headless-1.7.0.91-2.6.2.3.el7.x86_64java-1.8.0-openjdk-headless-1.8.0.65-3.b17.el7.x86_64[root@node1 ~]# rpm -e --nodeps java-1.7.0-openjdk-1.7.0.91-2.6.2.3.el7.x86_64 ##三个都要卸载[root@node1 ~]# java -version #OK，这次卸载的很干净-bash: /bin/java: No such file or directory</code></pre><h2 id="下载你需要版本的jdk"><a href="#下载你需要版本的jdk" class="headerlink" title="下载你需要版本的jdk"></a><strong>下载你需要版本的jdk</strong></h2><pre><code>地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html [root@node1 ~]# rpm -ivh /usr/java/jdk1.7.0.79.rpm #安装JDK</code></pre><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a><strong>配置环境变量</strong></h2><pre><code>在/etc/profile尾部添加以下代码：JAVA_PATH #标记是java的内容export JAVA_HOME=/usr/java/jdk1.8.0_121 #export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar [root@node1 ~]# source /etc/profile #使配置生效</code></pre><p><strong>java -version  #查看是否安装成功</strong></p><h2 id="TOMCAT的配置和安装："><a href="#TOMCAT的配置和安装：" class="headerlink" title="TOMCAT的配置和安装："></a><strong>TOMCAT的配置和安装</strong>：</h2><p>Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。<br>由于Tomcat本身也内含了一个HTTP服务器，它也可以被视作一个单独的Web服务器。<br>但是，不能将Tomcat和Apache HTTP服务器混淆，Apache HTTP服务器是一个用C语言实现的HTTPWeb服务器；<br>这两个HTTP web server不是捆绑在一起的。Apache Tomcat包含了一个配置管理工具，<br>也可以通过编辑XML格式的配置文件来进行配置。</p><h2 id="下载并安装TOMCAT"><a href="#下载并安装TOMCAT" class="headerlink" title="下载并安装TOMCAT"></a><strong>下载并安装TOMCAT</strong></h2><pre><code>[root@node1 ~]# tar -zxvf tomcat-8.5.13.tar.gz tomcat #解压安装文件并命名为&quot;tomcat&quot;[root@node1 ~]# mv tomcat /usr/local/</code></pre><h2 id="启动tomcat"><a href="#启动tomcat" class="headerlink" title="启动tomcat"></a><strong>启动tomcat</strong></h2><pre><code>[root@node1 ~]# bash catalina.sh start [root@node1 ~]# curl http://localhost:8080 #能看到tomcat的欢迎页面表示ok</code></pre><h2 id="修改TOMCAT默认端口"><a href="#修改TOMCAT默认端口" class="headerlink" title="修改TOMCAT默认端口"></a><strong>修改TOMCAT默认端口</strong></h2><pre><code>[root@node1 ~]# vim /usr/local/tomcat/conf/server.xml**Connector port=&quot;**80**[S1] &quot; maxHttpHeaderSize=&quot;8192&quot;##默认端口是8080,看你需求修改maxThreads=&quot;150&quot; minSpareThreads=&quot;25&quot; maxSpareThreads=&quot;75&quot;enableLookups=&quot;false&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;100&quot;connectionTimeout=&quot;20000&quot; disableUploadTimeout=&quot;true&quot; /&gt;**[root@node1 bin]# ./shutdown.sh [root@node1 bin]# ./catalina.sh start #重新启动一下tomcat[root@node1 bin]# ss -tnlp #查看80、8005、8009是否为Java所监听    [root@node1 ~]#netstat -pant | grep 8005命令查看端口[root@node1 ~]#fuser -v -n tcp 8005 #查看8005监听状态-v 详细模式-n 指定一个不同的命名空间</code></pre><h2 id="放行防火墙端口"><a href="#放行防火墙端口" class="headerlink" title="放行防火墙端口"></a><strong>放行防火墙端口</strong></h2><pre><code>firewall-cmd --permanent --add-prot=80/tcpfirewall-cmd --reload</code></pre><h2 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a><strong>开机启动</strong></h2><pre><code>[root@node1 ~]# vim /etc/rc.d/rc.local添加下面三行内容：tomcat #标记是tomcat的内容export JAVA_HOME=/usr/java/jdk1.8.0_121 # 是jdk安装目录/usr/local/tomcat/bin/startup.sh start  #是tomcat安装的目录注意：修改rc.local文件添加执行权限： chmod +x rc.local</code></pre><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a><strong>遇到的问题</strong></h2><pre><code>如果执行配置文件报错1：touch:cannot touc &apos;/usr/local/kencery/tomcat/logs/catalina.out:NO such file or directory*:报这个错只需要 mkdir /usr/local/tomcat/logs 即可一般执行配置文件报错都会在/usr/local/tomcat/logs/catalina.out中显示如果执行配置文件报错2：/usr/local/tomcat/bin/catalina.sh:line 435: /usr/local/java/jdk1.7.0_79/bin/java: no such file directory/usr/local/tomcat/bin/catalina.sh:line 435: /usr/local/jdk6/jre/bin/java: no such file or directory/usr/local/tomcat/bin/catalina.sh:line 435: /usr/local/jdk1.7.0_79//jre/bin/java: no such file or directory*:报这个错 只需要打开配置文件 /usr/local/tomcat/bin/catalina.sh 然后在435行用#注释掉即可</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java Development Kit（JDK）是太阳微系统针对Java开发人员发布的免费软件开发工具包（SDK，Software development kit）。自从Java推出以来，JDK已经成为使用最广泛的Java SDK。由于JDK的一部分特性采用商业许可证，而非开源。因此，2006年太阳微系统宣布将发布基于GPL的开源JDK，使JDK成为自由软件。
    
    </summary>
    
      <category term="Tomcat" scheme="http://yoursite.com/categories/Tomcat/"/>
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 HA集群之Corosync+Pacemaker+NFS+Http+Ansible</title>
    <link href="http://yoursite.com/2018/03/27/pacemaker+corosync/"/>
    <id>http://yoursite.com/2018/03/27/pacemaker+corosync/</id>
    <published>2018-03-27T05:22:38.554Z</published>
    <updated>2017-09-26T03:25:20.417Z</updated>
    
    <content type="html"><![CDATA[<p>Corosync是OpenAIS发展到Wilson版本后衍生出来的开放性集群引擎工程。可以说Corosync是OpenAIS工程的一部分。OpenAIS从openais0.90开始独立成两部分，一个是Corosync；另一个是AIS标准接口Wilson。Corosync包含OpenAIS的核心框架用来对Wilson的标准接口的使用、管理。它为商用的或开源性的集群提供集群执行框架。Corosync执行高可用应用程序的通信组系统，它有以下特征：<br>（1）一个封闭的程序组（A closed process group communication model）通信模式<a id="more"></a>，这个模式提供一种虚拟的同步方式来保证能够复制服务器的状态。<br>（2）一个简单可用性管理组件（A simple availability manager），这个管理组件可以重新启动应用程序的进程当它失败后。<br>（3）一个配置和内存数据的统计（A configuration and statistics in-memory database），内存数据能够被设置，回复，接受通知的更改信息。<br>（4）一个定额的系统（A quorum  system）,定额完成或者丢失时通知应用程序。<br><strong>总结</strong>：Corosync是整合底层节点服务器，提供API个pacemaker的一个中间层</p><p>Pacemaker，是一个群集资源管理器。它实现最大可用性群集服务（亦称资源管理）的节点和资源级故障检测和恢复使用您的首选集群基础设施（OpenAIS的或Heaerbeat）提供的消息和成员能力。<br>它可以做乎任何规模的集群，并配备了一个强大的依赖模型，使管理员能够准确地表达群集资源之间的关系（包括顺序和位置）。几乎任何可以编写脚本，可以管理作为心脏起搏器集群的一部分。<br>pacemaker支持超过16个节点的控制</p><p>目的：利用Corosyn+Packemaker+NFS+Http实现Web高可用集群</p><p><strong>工作原理图</strong><br>（图片来源于网络）：<br><img src="http://i.imgur.com/SQ2c1OJ.png" alt=""></p><p><strong>架构图：</strong></p><p><img src="http://i.imgur.com/sNG4kIJ.jpg" alt=""></p><p>准备四台机器和一个虚拟IP：</p><pre><code>虚拟IP:192.168.1.60        node1:192.168.1.51  node1.comnode2:192.168.1.52  node2.comnfs  :192.168.1.53ansible:192.168.1.54</code></pre><h2 id="集群准备工作"><a href="#集群准备工作" class="headerlink" title="集群准备工作"></a><strong>集群准备工作</strong></h2><p>   两节点要时间同步，ssh访问互信，hosts名称解析一致,关闭selinux</p><pre><code>1.修改Hosts    [root@node1 ~]# vim /etc/hosts192.168.1.51 node1.com node1192.168.1.52 node2.com node2 [root@node1 ~]# uname -n        node1.com   其他节点和上面配置一样2.配置ansible主机[root@ansible ~]# yum -y install ansible （需要配置eple源）[root@ansible ~]# cp hosts{,.bak} ##复制一份备用[root@ansible ~]# vim /etc/ansible/hosts      [haservers]   ##定义一个ansible集群组192.168.1.51192.168.1.523.建立ssh公钥认证[root@ansible ~]# ssh-keygent -t rsa -P&apos;&apos;  ##生成公钥（一路回车就行了）[root@ansible ~]# ssh-copy-id -i .ssh/id_rsa.pub root@192.168.1.51 ##复制公钥到node1.com[root@ansible ~]# ssh-copy-id -i .ssh/id_rsa.pub root@192.168.1.52   ##复制到node2.com4.测试一下：[root@ansible ~]# ssh node1The authenticity of host &apos;node1 (192.168.1.51)&apos; can&apos;t be established.ECDSA key fingerprint is 85:a3:4b:1d:ab:2f:41:30:df:70:39:76:f4:08:be:02.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;node1&apos; (ECDSA) to the list of known hosts.Last login: Tue Feb 28 22:07:37 2017[root@node1 ~]#       ##没有输密码表示成功node2节点也试一下[root@ansible ~]# ansible all -m ping  ##使用ansible测试一下   192.168.1.51 | SUCCESS =&gt; {&quot;changed&quot;: false, &quot;ping&quot;: &quot;pong&quot; } 192.168.1.52 | SUCCESS =&gt; { &quot;changed&quot;: false,  &quot;ping&quot;: &quot;pong&quot;  }</code></pre><p>同步时间：</p><pre><code>[root@ansible ~]# ansible all -m yum -a &quot;name=ntpdate state=present&quot; ##各节点都装上时间服务器[root@ansible ~]# ansible all -m shell -a &quot;ntpdate cn.pool.ntp.org&quot; ##向国家时间服务器同步</code></pre><h2 id="安装corosync-pacemaker-crmsh"><a href="#安装corosync-pacemaker-crmsh" class="headerlink" title="安装corosync,pacemaker,crmsh "></a><strong>安装corosync,pacemaker,crmsh </strong></h2><pre><code>1.首先安装corosync和pacemaker由于corosync是pacemake的依赖包，所有安装完pacemaker后corosync自动被安装上  使用ansible安装:[root@ansible ~]# ansible all -m yum -a &quot;name=pacemaker state=present&quot;在2个node节点确认：[root@node1~]# rpm -qa pacemaker pacemaker-1.1.13-10.el7.x86_64[root@node1~]# rpm -qa corosync corosync-2.3.4-7.el7.x86_642.安装crmshcrmsh在yum仓库和epel源都没有需要去另外下载,下载后拷贝到ansible主机/crmsh  http://download.opensuse.org/repositories/network:/ha-clustering:/Stable/CentOS_CentOS-7/noarch/   [root@ansible ~]#ls /crmsh  asciidoc-8.6.9-32.2.noarch.rpm           crmsh-scripts-3.0.0-1.2.noarch.rpm   asciidoc-examples-8.6.9-32.2.noarch.rpm  crmsh-test-3.0.0-1.2.noarch.rpm  crmsh-3.0.0-1.2.noarch.rpm               python-parallax-1.0.1-28.2.noarch.rpm[root@ansible ~]# ansible all -m shell -a &apos;mkdir /root/crmsh&apos;[root@ansible ~]# ansible all -m copy -a &quot;src=/root/crmsh/ dest=/root/crmsh/&quot;[root@ansible ~]# ansible all -m shell -a &apos;yum -y install /root/crmsh/*.rpm&apos;   两个节点确认一下:[root@node1 ~]#crmcrm(live)#     ##表示crmsh安装成功</code></pre><h2 id="配置corosync和pacemaker并启动服务"><a href="#配置corosync和pacemaker并启动服务" class="headerlink" title="配置corosync和pacemaker并启动服务"></a><strong>配置corosync和pacemaker并启动服务</strong></h2><pre><code> corosync配置文件修改，ansible主机上修改并部署 [root@ansible ~]# yum -y install pacemaker [root@ansible ~]# cd /etc/corosync [root@ansible ~]# cp corosync.conf.example corosync.conf [root@ansible ~]# vim corosync.conf  # Please read the corosync.conf.5 manual page  totem {   ##集群信息       version: 2   ##版本    crypto_cipher: aes128   ##对称节点采用aes128加密方式，单项采用sha1加密    crypto_hash: sha1    interface {            ringnumber: 0 ##心跳信息传递的环号码，如果有多个接口传递心跳信息，则定义多个，每个环号不同            bindnetaddr: 192.168.1.0 ##心跳信息接口的网络地址            mcastaddr: 239.255.1.1   ##心跳信息传递时使用的组播地址            mcastport: 5405  ##组播端口            ttl: 1  ##防止心跳信息环路，限定心跳信息传递的ttl值，一般是集群节点个数减去1        }  }  logging { ##定义日志记录方式    fileline: off    to_stderr: no    to_logfile: yes  ##是否记录日志    logfile: /var/log/cluster/corosync.log  ##日志文件位置    to_syslog: no  ##是否记录到系统日志    debug: off   ##关闭调试模式    timestamp: on  ##时间戳标签    logger_subsys {  ##记录投票子系统的日志信息            subsys: QUORUM            debug: off    }}  quorum {            provider: corosync_votequorum  ##投票系统使用corosync自带  }  nodelist {  ##自定义的节点    node {            ring0_addr:node1.com  ##环0上的地址，如果此前定义了多个接口用于传递心跳信息，                则次处定义多个环上的不同地址，如ring1_addr:....            nodeid:1     }    node {            ring0_addr:node2.com            nodeid:2    }}</code></pre><p>创建认证文件</p><pre><code>[root@ansible ~]# corosync-keygen -l  ##由于corosync配置文件中定义了通信采用的加密方式进行，因此要生成秘钥文件使用ansible将配置文件及认证文件全部拷贝至节点服务器，注意authkey的权限（400或600）[root@ansible ~]# ansible all -m copy -a &quot;src=/etc/corosync/authkey mode=400 dest =/etc/corosync/authkey&quot;##复制认证文件到各节点    [root@ansible ~]# ansible all -m copy -a &quot;src=/etc/corosync/corosync.confdest=/etc/corosync/corosync.conf&quot;##复制corosync配置文件到各节点 </code></pre><p>进入节点主机进行验证:</p><pre><code>[root@node1~]# ll /etc/corosync/total 20-r--------. 1 root root  128 Feb 23 02:47 authkey-rw-r--r--. 1 root root 2999 Feb 27 22:32 corosync.conf-rw-r--r--. 1 root root 2881 Nov 20  2015 corosync.conf.example-rw-r--r--. 1 root root  767 Nov 20  2015 corosync.conf.example.udpu-rw-r--r--. 1 root root 3278 Nov 20  2015 corosync.xml.exampledrwxr-xr-x. 2 root root    6 Nov 20  2015 uidgid.d</code></pre><p>开启corosync和pacemaker服务：</p><pre><code>[root@ansible ~]# ansible all -m service -a &quot;name=corosync state=started&quot;   ##启动各节点的corosync服务[root@ansible ~]# ansible all -m service -a &quot;name=pacemaker state=started&quot;  ##启动各节点的pacemaker服务</code></pre><p>各节点查看服务状态：</p><pre><code>[root@node1~]# crm status Last updated: Tue Feb 28 23:32:05 2017         Last change: Tue Feb 28 22:03:05 2017 by root via cibadmin on node1.com Stack: corosync Current DC: node1.com (version 1.1.13-10.el7-44eb2dd) - partition with quorum 2 nodes and 3 resources configured Online: [ node1.com node2.com ]    ##node1和node同时在线表示成功</code></pre><h2 id="配置NFS服务"><a href="#配置NFS服务" class="headerlink" title="配置NFS服务"></a><strong>配置NFS服务</strong></h2><p>安装配置nfs服务</p><pre><code>[root@nfs server ~]# yum -y install nfs-utils  ##安装nfs[root@nfs server ~]# systemctl enable nfs.service  ##开机启动nfs[root@nfs server ~]# systemctl start  nfs.service  ##启动nfs[root@nfs server ~]# firewall-cmd --permanent --add-service=nfs ##防火墙放行nfs[root@nfs server ~]# firewall-cmd --permanent --add-service=rpc-bind[root@nfs server ~]# firewall-cmd --permanent --add-service=mountd[root@nfs server ~]# firewall-cmd --reload[root@nfs server ~]# mkdir /web/storage -pv[root@nfs server ~]# vim /etc/exportfs     /web/storage 192.168.1.0/24(rw)[root@nfs server ~]#exportfs -rv      ##(-r表示重读配置，-v显示共享情况)[root@nfs server ~]# systemctl restart nfs.service</code></pre><p><strong>使用ansible挂载nfs</strong></p><pre><code>[root@ansible ~]# ansible all -m yum -a &quot;name=nfs-utils state=present&quot;[root@ansible ~]# ansible all -m shell -a &apos;mount -t nfs 192.168.1.53:/web/storage /var/www/html&apos;    到node节点上查看是否挂载[root@node1 ~]# df -h Filesystem                 Size  Used Avail Use% Mounted on192.168.1.53:/web/storage   10G  4.1G  6.0G  41% /var/www/htmlansible卸载nfs（这里先卸载，因为后面集群会自动挂载）[root@ansible ~]# ansible all -m shell -a &apos;umount /var/www/html’</code></pre><h2 id="crmsh配置集群"><a href="#crmsh配置集群" class="headerlink" title="crmsh配置集群"></a><strong>crmsh配置集群</strong></h2><pre><code>   [root@node1~]# crm(live)cd configurecrm(live)configure# property no-quorum-policy=stop   ##关闭法定票数不足       crm(live)configure# property stonith-enabled=false  ##由于没有stonith设备，所以先将stonith关闭    crm(live)configure# rsc_defaults resource-stickiness=100 ##设定资源粘性值为100               crm(live)configure#primitive webip ocf:heartbeat:IPaddr params ip=192.168.1.60 ##定义虚拟IP                   定义完虚拟IP可以验证一下，看各节点是否都配置成功  [root@node1~]# ip addr                  2: eno16777736: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000             link/ether 00:0c:29:9b:93:76 brd ff:ff:ff:ff:ff:ff         inet 192.168.1.51/24 brd 192.168.1.255 scope global eno16777736             valid_lft forever preferred_lft forever                 inet 192.168.1.60/24 brd 192.168.1.255 scope global secondary eno16777736                 valid_lft forever preferred_lft forever                 inet6 fe80::20c:29ff:fe9b:9376/64 scope link                  valid_lft forever preferred_lft forever crm(live)configure# primitive webserver systemd:httpd op start timeout=100  op stop timeout=100 op monitor interval=60 timeout=100   ##定义使用的服务 crm(live)configure# primitive webstore ocf:heartbeat:Filesystem params directory=&quot;/var/www/html&quot;  fstype=nfs op start timeout=60s op stop timeout=60s op monitor interval=60 timeout=100       ##定义使用的存储设备 crm(live)configure# group   webservice  webip webstore webserver ##定义集群组，要按照资源顺序来 crm(live)configure# verify  ##校验 crm(live)configure# commit  ##提交配置确认并生效配置完成后查看是这样，表示成功  crm(live)# status       Last updated: Wed Mar  1 01:27:39 2017               Last change: Tue Feb 28 22:03:05 2017 by root via cibadmin on node1.com       Stack: corosync        Current DC: node1.com (version 1.1.13-10.el7-44eb2dd) - partition with quorum       2 nodes and 3 resources configured    Online: [ node1.com node2.com ]    Full list of resources:     Resource Group: webservice         webip        (ocf::heartbeat:IPaddr):    Started node1.com          webstore    (ocf::heartbeat:Filesystem):    Started node1.com          webserver    (systemd:httpd):    Started node1.com 可以用下面几种资源约束的方法：     crm(live)configure# location webstore_perfer webstore inf: node1.com ##使用location定义webstore对节点1的倾向性为正无穷crm(live)configure# colocation webserver_with_webip inf:webserver webip ##定义两个资源的粘性，必须在一起crm(live)configure# order webip_bef_webstore_bef_webserver mandatory: webip webstore webse    ##强制资源启动顺序    crm(live)resource# migrate webip node1.com  ##使用migrate进行资源转移</code></pre><h2 id="开始测试集群："><a href="#开始测试集群：" class="headerlink" title="开始测试集群："></a><strong>开始测试集群：</strong></h2><pre><code>[root@node1~]# echo The page is NFS Server &gt;&gt; /var/www/html/index.html[root@node1~]# curl http://192.168.1.60    The page is NFS Server     [root@node1~]# crm node standby ##停用当前节点[root@node1~]# crm status   Node node1.com: standby   Online: [ node2.com ]   Full list of resources:   Resource Group: webservice        webip         (ocf::heartbeat:IPaddr):    Started node2.com        webstore    (ocf::heartbeat:Filesystem):    Started node2.com        webserver    (systemd:httpd):    Started node2.com      此时节点已经转移到了node2</code></pre><p>  OK，到此结束，全部成功了     </p><h2 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title=" 遇到的问题："></a><strong> 遇到的问题：</strong></h2><pre><code>1、 2个节点双方都显示自己这一方在线，另一方不在线    解决方法：彻底关闭selinux2、[root@node1 ~]#crm status   ERROR: status: crm_mon (rc=107): Connection to cluster failed: Transport endpoint is not connected   解决方法：systemctl start packemaker.service  ##ok!</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Corosync是OpenAIS发展到Wilson版本后衍生出来的开放性集群引擎工程。可以说Corosync是OpenAIS工程的一部分。OpenAIS从openais0.90开始独立成两部分，一个是Corosync；另一个是AIS标准接口Wilson。Corosync包含OpenAIS的核心框架用来对Wilson的标准接口的使用、管理。它为商用的或开源性的集群提供集群执行框架。Corosync执行高可用应用程序的通信组系统，它有以下特征：&lt;br&gt;（1）一个封闭的程序组（A closed process group communication model）通信模式
    
    </summary>
    
      <category term="Cluster" scheme="http://yoursite.com/categories/Cluster/"/>
    
    
      <category term="HA之Corosync+Pacemaker" scheme="http://yoursite.com/tags/HA%E4%B9%8BCorosync-Pacemaker/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 搭建ntp时间服务器</title>
    <link href="http://yoursite.com/2018/03/27/ntp-server/"/>
    <id>http://yoursite.com/2018/03/27/ntp-server/</id>
    <published>2018-03-27T05:22:38.550Z</published>
    <updated>2017-04-25T09:50:22.067Z</updated>
    
    <content type="html"><![CDATA[<p>目的：解决实验环境中时间的一致性<br>NTP是Network Time Protocol的简写，即网络时间协议。多个主机可以通过NTP同步系统时间。<br>下面我们搭建一个NTP服务器，其他服务器都可以通过NTP服务器实现时间同步。<br>首先需要确保服务器时区设置是否正确，使用timedatectl查看设置时区（Asia/Shanghai）.</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作:"></a><strong>准备工作</strong>:</h2><pre><code>NTP服务器地址：    服务器：192.168.1.50客户端：192.168.1.51</code></pre><h2 id="RPM包检查："><a href="#RPM包检查：" class="headerlink" title="RPM包检查："></a><strong>RPM包检查</strong>：</h2><pre><code>[root@ntp server ~]# rpm -ql |grep ntp 没有安装就直接yum安装  [root@ntp server ~]# yum -y install ntp</code></pre><h2 id="开机启动ntp服务"><a href="#开机启动ntp服务" class="headerlink" title="开机启动ntp服务"></a><strong>开机启动ntp服务</strong></h2><pre><code>systemctl enable ntpdsystemctl start  ntpd</code></pre><h2 id="获取免费时间服务器地址"><a href="#获取免费时间服务器地址" class="headerlink" title="获取免费时间服务器地址"></a><strong>获取免费时间服务器地址</strong></h2><pre><code>http://www.pool.ntp.org/zone/cn</code></pre><h2 id="配置时间服务器"><a href="#配置时间服务器" class="headerlink" title="配置时间服务器:"></a><strong>配置时间服务器:</strong></h2><pre><code>[root@ntp server ~]# vim /etc/ntp.conf     server 0.cn.pool.ntp.orgserver 1.cn.pool.ntp.org    server 2.cn.pool.ntp.org    server 3.cn.pool.ntp.org    fudge 127.127.0.1 stratum 3     ##设置自身为3级Ntp serverNTPserver server 127.127.1.0 iburst  local clock  ##外部不可用时，使用本地时间    restrict 192.168.1.0 mask 255.255.255.0 nomodify  ## 设置客户端的限制，nomodify允许来自哪个段的IP来同步时间但不允许改ntp服务器参数</code></pre><h2 id="重启服务并防火墙放行"><a href="#重启服务并防火墙放行" class="headerlink" title="重启服务并防火墙放行"></a><strong>重启服务并防火墙放行</strong></h2><pre><code>systemctl restart ntpdfirewall-cmd --permanent--add-port=123/udp firewall-cmd --reload</code></pre><h2 id="检查-ntpq-p查看ntpd"><a href="#检查-ntpq-p查看ntpd" class="headerlink" title="检查 ntpq -p查看ntpd"></a><strong>检查 ntpq -p查看ntpd</strong></h2><h2 id="客户端测试"><a href="#客户端测试" class="headerlink" title="客户端测试  "></a><strong>客户端测试  </strong></h2><pre><code>[root@test ~]# ntpdate 192.168.1.5029 Mar 15:13:01 ntpdate[3895]: adjust time server 192.168.1.50 offset -0.019419 sec ##同步时间成功[root@test ~]# hwclock -w  ##重新写入硬件时钟</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目的：解决实验环境中时间的一致性&lt;br&gt;NTP是Network Time Protocol的简写，即网络时间协议。多个主机可以通过NTP同步系统时间。&lt;br&gt;下面我们搭建一个NTP服务器，其他服务器都可以通过NTP服务器实现时间同步。&lt;br&gt;首先需要确保服务器时区设置是否正确，使用timedatectl查看设置时区（Asia/Shanghai）.&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="Ntp Server" scheme="http://yoursite.com/tags/Ntp-Server/"/>
    
  </entry>
  
  <entry>
    <title>Centos7  Nginx利用“反向代理”实现“动静分离”</title>
    <link href="http://yoursite.com/2018/03/27/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2018/03/27/Nginx反向代理/</id>
    <published>2018-03-27T05:22:38.533Z</published>
    <updated>2017-09-26T03:24:40.599Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Nginx</strong>是一款免费的，开源的，高性能的HTTP服务软件，它不仅能够支持反向代理服务器，而且也可以当作IMAP/POP3代理服务。<br>nginx不采用每客户机一线程的设计模型，而是充分使用异步逻辑，削减了上下文调度开销，所以并发服务能力更强。整体采用模块化设计，有丰富的模块库和第三方模块库，配置灵活。在Linux操作系统下，nginx使用epoll事件模型，得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于epoll的高效事件模型kqueue。<br>而且它稳定，配置丰富，设置简单，支持热部署<a id="more"></a>，而且占用系统资源少，10000个keep-alive模式下connection仅需要2.5MB内存！！！（俄罗斯的产品果然是简单粗暴）</p><p><strong>Nginx工作模式</strong>：Master/worker<br>          一个主进程master生成一个或者多个work线程<br>          master:负责加载和分析配置文件<br>          work:处理并响应用户请求</p><p><strong>特性</strong>：<br>         异步，非阻塞，事件驱动<br>         文件IO: sendfile ，mmap</p><p><strong>核心模块</strong>：<br>          main: 主要用户配置错误日志，进程管理，权限控制<br>          event: 配置epoll,kqueue,select,poll</p><p><strong>rewrite模块</strong>：<br>          把用户请求的URL基于regex做检查，匹配时将替换为replacement指定的字符串<br>          如果replacement是以http：//开头，则替换结果会直接重定向返回客户端<br>          在同一个localtion中存在多个rewrite规则会自上而下逐个检查，可以使用flag控制此循环功能</p><p>last：提前结束本轮循环，进入下一轮，continue<br>break：终止了，不再循环<br>redirect：重定向，临时重定向，302<br>permanent：永久重定向，301，重写后生成的新url给客户端，由客户端对新url进行请求</p><p>例如：<br>  localtion / {<br>        rewrite (.<em>）.txt$ $1.html;<br>         }<br>请求的txt文件都变成html，重写，变成了一个新的url，然后被匹配<br>    再加上：<br>  location ~</em>.html\$ {<br>        rewrite (.*).html $1.txt;<br>        }<br>后，html又转化为txt了，就形成一个死循环，所以要在两个后面加上条件，break。</p><p>然后再加上个redirect，临时重定向<br>    location / {<br>         rewrite (.*).txt$ $1.html redirect;<br>        }</p><p><strong>upstream 模块</strong>：<br>           负载均衡，必须定义在http段落</p><p><strong>实验目的</strong>：利用Nginx反向代理，将用户请求的动态资源反代到Web1,静态资源反代到Web2</p><p>架构图：</p><p><img src="http://i.imgur.com/09Eqfpl.jpg" alt=""></p><h2 id="虚拟机实验环境"><a href="#虚拟机实验环境" class="headerlink" title="虚拟机实验环境"></a>虚拟机实验环境</h2><pre><code>1.关闭selinux和清空iptables2.所有主机同步时间3.Nginx反向代理服务器内网网卡选择VMNET8虚拟网络连接4.Web1部署LAMP平台，Web2部署httpd</code></pre><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><pre><code>  客户端IP：192.168.1.158  Nginx反向代理服务器IP：                外网：192.168.1.51                内网：192.168.42.130后端Web服务器IP：                Web1：192.168.42.128                Web2：192.168.42.129</code></pre><h2 id="服务安装"><a href="#服务安装" class="headerlink" title="服务安装"></a>服务安装</h2><pre><code>Nginx服务器安装nginx软件包：      [root@nginx /]# yum -y install nginx   ##需要配置好epel源Web1服务器配置搭建LAMP平台：[root@Web1 /]# yum -y install httpd mariadb-server php php-mysql php-gd libjpeg* php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-bcmath php-mhash新建测试页vim /var/www/html/index.php&lt;?phpphpinfo();?&gt;[root@Web1 /]# curl http://192.168.42.128能看到php测试页表示ok   Web2服务器配置httpd服务[root@Web2 /]# yum -y install httpd安装完后新建测试页curl http://192.168.42.129能看到表示ok</code></pre><h2 id="nginx配置反向代理"><a href="#nginx配置反向代理" class="headerlink" title="nginx配置反向代理"></a>nginx配置反向代理</h2><pre><code>[root@nginx nginx]# cp nginx.conf{,.bak}  ##先做备份主要配置： proxy_set_header NWC_TEST $remote_addr;  ##定义日志首部location / {        root /usr/share/nginx/html;        index   index.html index.htm;        proxy_pass http://192.168.42.129;}location ~ \.php$ {        proxy_pass http://192.168.42.128;        index   index.php index.html index.htm;}</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>http://192.168.1.51/index.php|index.html 能看到.php页面和.html页面的内容和WEB1,WEB2相同表明OK</code></pre><h2 id="设置RS的请求报文首部"><a href="#设置RS的请求报文首部" class="headerlink" title="设置RS的请求报文首部"></a>设置RS的请求报文首部</h2><pre><code>在nginx主机上添加proxy_set_header NWC_TEST $remote_addr;利用proxy_set_header指令，设置nginx反代用户请求到后端主机上时，为请求报文添加一个首部，首部名称为NWC_TEST,首部对应的值为$remote-addr对应的值，也就是真是客户端IP地址修改完nginx服务器，再到后端主机修改日志格式LogFormat &quot;%{NWC_TEST}i %h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%{Referer}i\&quot; \&quot;%{User-Agent}i\&quot;&quot; combined</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Nginx&lt;/strong&gt;是一款免费的，开源的，高性能的HTTP服务软件，它不仅能够支持反向代理服务器，而且也可以当作IMAP/POP3代理服务。&lt;br&gt;nginx不采用每客户机一线程的设计模型，而是充分使用异步逻辑，削减了上下文调度开销，所以并发服务能力更强。整体采用模块化设计，有丰富的模块库和第三方模块库，配置灵活。在Linux操作系统下，nginx使用epoll事件模型，得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于epoll的高效事件模型kqueue。&lt;br&gt;而且它稳定，配置丰富，设置简单，支持热部署
    
    </summary>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 Mysql主从同步</title>
    <link href="http://yoursite.com/2018/03/27/Mysql-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
    <id>http://yoursite.com/2018/03/27/Mysql-主从同步/</id>
    <published>2018-03-27T05:22:38.517Z</published>
    <updated>2017-04-25T09:51:14.801Z</updated>
    
    <content type="html"><![CDATA[<p><strong>MySQL主从同步</strong>：MySQL的主从复制广泛用于数据库备份、故障转移、数据分析等场合<br>主从同步原理*：<br>通过设置在Master MySQL上的binlog(使其处于打开状态)，Slave MySQL上通过一个I/O线程从Master MySQL上读取binlog，再传输到Slave MySQL的中继日志中，<a id="more"></a>然后Slave MySQL的SQL线程从中继日志中读取中继日志，应用到Slave MySQL的数据库中。这样实现了主从数据同步功能。</p><p><strong>目的：主从复制能够有效的缓解数据库读写的压力</strong></p><p>模型图（图片来源于网络）：<br><img src="http://i.imgur.com/ZMwq5kZ.jpg" alt=""></p><h2 id="环境的准备"><a href="#环境的准备" class="headerlink" title="环境的准备"></a><strong>环境的准备</strong></h2><pre><code>1.Mysql主备之前版本必须一致2.为了不影响实验结果建议关闭&apos;Selinux&apos; 主服务器：mysql-master: 192.168.1.60从服务器：mysql_slave:  192.168.1.61</code></pre><p><strong>安装Mariadb</strong></p><pre><code>[root@mysql-master /]yum -y install mariadb mariadb-server [root@mysql-master /]systemctl enable mariadb.service      ##开机启动mariadb服务  [root@mysql-master /]systemctl start  mariadb.service      ##启动mariadb服务  [root@mysql-master /]mysql_secure_installation            ##初始化Mysql从服务器同上操作</code></pre><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a><strong>修改配置文件</strong></h2><pre><code>主服务器的配置文件（/etc/my.cnf）,开启日志功能，设置server_id 保证唯一[root@mysql-master tmp]# vim /etc/my.cnf加入以下两行内容[mysqld]server_id = 200      ##server_id 同步复制时标识该语句最初是从哪个server写入的log-bin=mysql-bin  ##开启二进制功能 保存退出，重启服务器</code></pre><h2 id="数据库授权"><a href="#数据库授权" class="headerlink" title="数据库授权"></a><strong>数据库授权</strong></h2><pre><code>[root@mysql-master /]# mysqldump -uroot -pMariaDB [mysql]&gt; grant replication slave,reload,super on *.* to &apos;slave&apos;@&apos;192.168.1.60&apos; identified by &apos;slavepass&apos;  MariaDB [mysql]&gt;flush privileges  ##重读授权表信息 注释：‘replication slave’拥有此权限可以查看从服务器，从主服务器读取二进制日志 ‘reload’权限，才可以执行flush [tables | logs | privileges]‘super’这个权限允许用户终止任何查询；修改全局变量的SET语句；使用CHANGE MASTER，PURGE MASTER LOGS。 MariaDB [mysql]&gt;show master status; ##查看主服务的状态  +----------------------+----------+--------------+------------------+ | File                 | Position | Binlog_Do_DB | Binlog_Ignore_DB | +----------------------+----------+--------------+------------------+ | mysql-bin.000002      |      245|              |                  | +----------------------+----------+--------------+------------------+</code></pre><h2 id="主从备份"><a href="#主从备份" class="headerlink" title="主从备份"></a><strong>主从备份</strong></h2><pre><code>为保证主DB server和从DB server的数据一致,这里采用主备份,从还原来实现初始数据一致MariaDB [mysql]&gt;flush tables with read lock;    ##加临时锁，表只读[root@mysql-master /]# mysqldump -uroot -p --all-   databases &gt; /home/backup.sql   ##复制所有数据库到/home/[root@mysql-master /]# unlock tables;  J##解锁[root@mysql-master /]# scp /home/backup.sql ‘root’@‘192.168.1.61’：/home/ ##将备份数据发送到从服务器，用于恢复</code></pre><h2 id="配置Slave"><a href="#配置Slave" class="headerlink" title="配置Slave"></a><strong>配置Slave</strong></h2><pre><code>[root@mysql-slave /]# vim /etc/my.cnf server_id=201 ##设置server_id</code></pre><h2 id="Slave还原备份数据"><a href="#Slave还原备份数据" class="headerlink" title="Slave还原备份数据"></a><strong>Slave还原备份数据</strong></h2><pre><code>[root@mysql-slave /]#systemctl restart mariadb.service[root@mysql-slave /]#mysql -uroot -p &lt; /home/backup.sql</code></pre><h2 id="连接Master服务器"><a href="#连接Master服务器" class="headerlink" title="连接Master服务器"></a><strong>连接Master服务器</strong></h2><pre><code>登陆从数据库,添加相关参数(主服务器的ip/端口/同步用户/密码/position号/读取哪个日志文件)[root@mysql-slave /]#mysql -uroot -pMariaDB [mysql]&gt;change master to master_host=&apos;192.168.1.60&apos;,master_user=&apos;slave&apos;,master_password=&apos;slavepass&apos;,        master_log_file=&apos;mysql-bin.000002&apos;,master_log_pos=245;     ##开启主从同步MariaDB [mysql]&gt;start slave;  ##查看主动同步状态MariaDB [mysql]&gt;show slave status\G; ##主要看下面2项，都是YES表示成功了Slave_IO_Running: YesSlave_SQL_Running: Yes</code></pre><h2 id="Master和Slave验证"><a href="#Master和Slave验证" class="headerlink" title="Master和Slave验证"></a><strong>Master和Slave验证</strong></h2><p>上面都没问题，那就开始测试了，去主服务断创建一个库，一张表，插入数据，再到从服务器来查看，如果数据一致表示没问题了</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a><strong>遇到的问题</strong></h2><pre><code>ERROR 2002 (HY000): Can&apos;t connect to local MySQL server through socket &apos;/tmp/mysql.sock&apos; (2) ####解决办法：在错误日志中，启动失败的原因极为明显，file ‘./mysql-bin。000004’ not found，failed to open！mysql开启了bin日志功能，到数据库根目录查看该文件是存在的，可能是文件权限的问题。[root@mysql-slave /]chown -R mysql:mysql /var/log/mysql[root@mysql-slave /]mysqld_safe &amp;     ##启动安全模式[root@mysql-slave /]systemctl stop mariadb.service[root@mysql-slave /]systemctl start mariadb.service###再重新初始化数据库，就可以登录了记得killall mysqld_safe mysql，因为不结束将不能开启二进制日志，结束安全模式进程然后[root@mysql-slave /]systemctl stop mariadb.service[root@mysql-slave /]systemctl start mariadb.service</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;MySQL主从同步&lt;/strong&gt;：MySQL的主从复制广泛用于数据库备份、故障转移、数据分析等场合&lt;br&gt;主从同步原理*：&lt;br&gt;通过设置在Master MySQL上的binlog(使其处于打开状态)，Slave MySQL上通过一个I/O线程从Master MySQL上读取binlog，再传输到Slave MySQL的中继日志中，
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
      <category term="Mysql主从同步" scheme="http://yoursite.com/tags/Mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 LB集群之LVS（一）</title>
    <link href="http://yoursite.com/2018/03/27/LVS+NAT/"/>
    <id>http://yoursite.com/2018/03/27/LVS+NAT/</id>
    <published>2018-03-27T05:22:38.517Z</published>
    <updated>2017-09-26T03:23:30.659Z</updated>
    
    <content type="html"><![CDATA[<p><strong>LVS</strong>(linux virtue server)是一个虚拟的服务器集群系统。项目在1998年5月由章文嵩成立，是中国国内最早出现的自由软件项目之一。<br>LVS集群采用IP负载均衡技术和基于内容请求分发技术。调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。整个服务器集群的结构对客户是透明的，而且无需修改客户端和服务器端的程序。为此，在设计时需要考虑系统的透明性、可伸缩性、高可用性和易管理性。<a id="more"></a></p><p><strong>目的</strong>：利用LVS实现负载均衡</p><p>模型图：<br><img src="http://i.imgur.com/2tSFs0K.jpg" alt=""></p><h2 id="配置IP"><a href="#配置IP" class="headerlink" title="配置IP"></a><strong>配置IP</strong></h2><p>lvs eth0： 192.168.1.103（VIP）<br>    eth1： 192.168.201.138（DIP）<br>web1 eth0：192.168.201.137<br>       lo：192.168.201.103<br>web2 eth0：192.168.201.132<br>    lo ：192.168.201.103 </p><h2 id="安装http服务"><a href="#安装http服务" class="headerlink" title="安装http服务"></a><strong>安装http服务</strong></h2><p>[root@WEB1 ~]# yum -y install httpd<br>[root@WEB1 ~]# systemctl enable http.service<br>[root@WEB1 ~]# systemctl start  http.service<br>[root@WEB1 ~]# echo “1” &gt;/var/www/html/index.html<br>[root@WEB1 ~]# curl <a href="http://localhost" target="_blank" rel="external">http://localhost</a><br>WEB2同上</p><h2 id="安装ipvsadm"><a href="#安装ipvsadm" class="headerlink" title="安装ipvsadm"></a><strong>安装ipvsadm</strong></h2><p>[root@WEB1 ~]# yum -y install ipvsadm<br>[root@WEB1 ~]# modprobe ip_vs  #加载到内核<br>[root@WEB1 ~]# ipvsadm         #查看是否安装成功</p><h2 id="配置IPVS"><a href="#配置IPVS" class="headerlink" title="配置IPVS"></a><strong>配置IPVS</strong></h2><p>[root@WEB1 ~]#ipvsadm -C 清空原来表格内容<br>[root@WEB1 ~]# ipvsadm -A -t 192.168.1.103:80 -s rr #创建一个集群<br>  -A添加地址 -t指定vip tcp端口 -s指定算法<br>[root@WEB1 ~]# ipvsadm -a -t 192.168.1.103:80 -r 192.168.201.137:80 -m<br>  -a指定真实服务器 -t lvs上的vip -r 真实服务器<br>[root@WEB1 ~]# ipvsadm -a -t 192.168.1.103:80 -r 192.168.201.132:80 -m<br>  -a指定真实服务器 -t lvs上的vip -r 真实服务器<br>[root@WEB1 ~]# ipvsadm -L -n 查看<br>IP Virtual Server version 1.2.1(size=4096)<br>Prot LocalAddress:PortScheduler Flags<br>-&gt; RemoteAddress:Port Forward Weight ActiveConn InActConn<br>TCP 192.168.1.103 wrr persistent 20<br>-&gt; 192.168.201.137 Route 1 0 0<br>-&gt; 192.168.201.132 Route 1 0 0 </p><p>…表示成功了</p><h2 id="配置RS"><a href="#配置RS" class="headerlink" title="配置RS"></a><strong>配置RS</strong></h2><p>给WEB1服务器配置VIP<br>ifconfig lo 192.168.1.103 netmask 255.255.255.255<br>WEB2设置同上</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h2><p>浏览器输入VIP地址 192.168.1.103<br>看WEB1和WEB2是不是轮询响应，down掉一个还能否响应</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;LVS&lt;/strong&gt;(linux virtue server)是一个虚拟的服务器集群系统。项目在1998年5月由章文嵩成立，是中国国内最早出现的自由软件项目之一。&lt;br&gt;LVS集群采用IP负载均衡技术和基于内容请求分发技术。调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。整个服务器集群的结构对客户是透明的，而且无需修改客户端和服务器端的程序。为此，在设计时需要考虑系统的透明性、可伸缩性、高可用性和易管理性。
    
    </summary>
    
      <category term="Cluster" scheme="http://yoursite.com/categories/Cluster/"/>
    
    
      <category term="Lvs+NAT" scheme="http://yoursite.com/tags/Lvs-NAT/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 Mysql双主模型</title>
    <link href="http://yoursite.com/2018/03/27/mysql%E5%8F%8C%E4%B8%BB%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/03/27/mysql双主模型/</id>
    <published>2018-03-27T05:22:38.517Z</published>
    <updated>2017-09-26T03:23:58.145Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Mysql</strong>双主模型可以在一定程度上保证主库的高可用,在一台主库down掉之后,可以在极短的时间内切换到另一台主库上（尽可能减少主库宕机对业务造成的影响），减少了主从同步给线上主库带来的压力；<a id="more"></a></p><p><strong>目的：利用双主模型来提高系统的可用性</strong></p><p><strong>模型图</strong><br>（来源于网络）：<br><img src="http://i.imgur.com/UCkH4Eo.jpg" alt=""></p><p><strong>准备工作</strong><br>1、为了不影响实验结果，建议关闭Selinux和Iptables<br>2、两台服务器时间要同步<br>3、两台服务器都要启动中继日志，二进制日志<br>4、主服务器1: 192.168.1.60<br>      主服务器2：192.168.1.61</p><h2 id="安装Mariadb"><a href="#安装Mariadb" class="headerlink" title="安装Mariadb"></a><strong>安装Mariadb</strong></h2><p>[root@mysql-masster1 /]# yum -y install mariadb-server mariadb<br>第二台服务器一样直接安装</p><h2 id="修改主配置文件"><a href="#修改主配置文件" class="headerlink" title=" 修改主配置文件"></a><strong> 修改主配置文件</strong></h2><pre><code>Master1配置：[root@mysql-masster1 /]# vim /etc/my.cnf[mysqld]server_id=1       ##设定全局唯一的server_idlog_bin=master-log      ##启用二进制日志，指明二进制日志的存放路径及名称relay_log=relay-log    ##启用中继日志，指明中继日志的存放路径及名称    auto_increment_offset=1    ##避免自增长字段的冲突值，设置本机的自增长字段从1开始，每次增长2auto_increment_increment=2    skip-name-resolve=ON     ##禁止名称解析innodb-file-per-table=ON   ##innodb存储引擎每表一个表空间Master2配置：[root@mysql-masster2 /]# vim /etc/my.cnf[mysqld]server_id=2    ##设定全局唯一的server_idlog-bin=master-log  ##启用二进制日志，指明二进制日志的存放路径及名称    relay-log=relay-log  ##启用中继日志，指明中继日志的存放路径及名称auto_increment_offset=2  ##避免自增长字段的冲突值，设置本机的自增长字段从1开始，每次增长2auto_increment_increment=2skip-name-resolve=ON     ##禁止名称解析innodb-file-per-table=ON  ##innodb存储引擎每表一个表空间**Master1和Master2配置完成后，重新启动mariadb服务**</code></pre><h2 id="登录MySQL用户授权"><a href="#登录MySQL用户授权" class="headerlink" title="登录MySQL用户授权"></a><strong>登录MySQL用户授权</strong></h2><pre><code>Master1配置：[root@mysql-masster1 /]#mysql -uroot -p MariaDB [mysql]&gt; grant replication client,replication slave on *.* to &apos;repluser&apos;@&apos;192.168.1.61&apos; identified by &apos;redhat&apos;;  MariaDB [mysql]&gt; flush privileges;MariaDB [mysql]&gt; show master logs;  ##查看二进制日志列表和当前正在使用的二进制日志的文件位置MariaDB [mysql]&gt; show master status; +-------------------+----------+--------------+------------------+ | File              | Position | Binlog_Do_DB | Binlog_Ignore_DB | +-------------------+----------+--------------+------------------+ | master-log.000001 |   245|   |              |                  |  +-------------------+----------+--------------+------------------+    MariaDB [mysql]&gt; ls /var/lib/mysql/ 查询二进制文件是否存在Master2配置：[root@mysql-masster2 /]#mysql -uroot -p MariaDB [mysql]&gt; grant replication client,replication slave on *.* to &apos;repluser&apos;@&apos;192.168.1.60&apos; identified by &apos;redhat&apos;;MariaDB [mysql]&gt; flush privileges;MariaDB [mysql]&gt; show master logs;MariaDB [mysql]&gt; show master status;+-------------------+----------+--------------+------------------+| File              | Position | Binlog_Do_DB | Binlog_Ignore_DB |+-------------------+----------+--------------+------------------+| master-log.000003 |     2109 |              |                  |+-------------------+----------+--------------+------------------+MariaDB [mysql]&gt; ls /var/lib/mysql/</code></pre><h2 id="定义2个节点"><a href="#定义2个节点" class="headerlink" title="定义2个节点"></a><strong>定义2个节点</strong></h2><pre><code> 在两个节点上定义复制时的属性，启动复制线程  Master1的配置：      MariaDB [mysql]&gt; change master to                                  master_host=&apos;192.168.1.61&apos;,    ##指定的Master主机                 master_user=&apos;repluser&apos;,            ##以哪个用户的身份练上去             master_password=&apos;redhat&apos;,       ##连接用户的密码             master_log_file=&apos;master-log.000003&apos;,      ##主节点的二进制日志文件             master_log_pos=2109;    ##主节点的二进制日志所在位置Master2的配置：change master to master_host=&apos;192.168.1.60&apos;,master_user=&apos;repluser&apos;,master_password=&apos;redhat&apos;,master_log_file=&apos;master-log.000001&apos;,master_log_pos=245;</code></pre><h2 id="启动复制线程"><a href="#启动复制线程" class="headerlink" title="启动复制线程    "></a><strong>启动复制线程    </strong></h2><pre><code>[root@mysql-masster2 /]#mysql -uroot -p MariaDB [mysql]&gt;start slave; ##启动复制线程MariaDB [mysql]&gt;show salve status;             Slave_IO_Running:YES  ##IO线程和SQL线程Slave_SQL_Running:YES两个线程都是YES，表明成功了，如果IO线程状态是Connecting 请退出MySQL，这个地方稍微有点延迟,重新启动一下mariadb服务，再连进去查看线程状态</code></pre><h2 id="双主服务器互相验证"><a href="#双主服务器互相验证" class="headerlink" title="双主服务器互相验证"></a><strong>双主服务器互相验证</strong></h2><p>在Master1上创建一个testdb库，看Master2能否看见。<br>Master2在testdb库中创建t1表，Master1能看见表明成功<br>Master1在t1插入数据，Master能看见表示成功</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Mysql&lt;/strong&gt;双主模型可以在一定程度上保证主库的高可用,在一台主库down掉之后,可以在极短的时间内切换到另一台主库上（尽可能减少主库宕机对业务造成的影响），减少了主从同步给线上主库带来的压力；
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
      <category term="Mysql双主模型" scheme="http://yoursite.com/tags/Mysql%E5%8F%8C%E4%B8%BB%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 LVS集群+Keepalived（二）</title>
    <link href="http://yoursite.com/2018/03/27/LVS+Keepalived/"/>
    <id>http://yoursite.com/2018/03/27/LVS+Keepalived/</id>
    <published>2018-03-27T05:22:38.502Z</published>
    <updated>2017-04-25T09:52:28.287Z</updated>
    
    <content type="html"><![CDATA[<p><strong>LVS</strong>是Linux Virtual Server的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统。本项目在1998年5月由章文嵩博士成立，是中国国内最早出现的自由软件项目之一。目前有三种IP负载均衡技术（NAT、DR、TUN），十种调度算法（rr|wrr|lc|wlc|lblc|lblcr|dh|sh|sed|nq）<a id="more"></a><br><strong>Keepalived</strong>在这里主要用作RealServer的健康状态检查以及Master主机和BackUP主机之间failover的实现下面，搭建基于LVS+Keepalived的高可用负载均衡集群，其中，LVS实现负载均衡，但是，简单的LVS不能监控后端节点是否健康，它只是基于具体的调度算法对后端服务节点进行访问。同时，单一的LVS又存在单点故障的风险。在这里，引进了Keepalived，可以实现以下几个功能：1. 检测后端节点是否健康2. 实现LVS本身的高可用</p><p><strong>目的：解决DR模型下Director单点故障</strong></p><p>模型图：<br><img src="http://i.imgur.com/XVzk8Wc.jpg" alt=""></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作:"></a><strong>准备工作:</strong></h2><pre><code>DR1:          vip :192.168.1.150  eno16777736:192.168.1.130     DR2 :             vip :192.168.1.150    eno16777736:192.168.1.131        RS1:    eno16777736:192.168.1.132    lo:192.168.1.150   netmask 255.255.255.255   ##4个255表示将广播域限制在本机RS2:    eno16777736:192.168.1.133    lo:192.168.1.150 netmask 255.255.255.255</code></pre><p>网络配置完成后都互相ping一下，看是不是都配通了</p><p>注意问题：<br>1.清空iptables规则 iptables  -t filter -F<br>2.关闭selinux  setenforce 0 </p><h2 id="安装httpd"><a href="#安装httpd" class="headerlink" title="安装httpd"></a><strong>安装httpd</strong></h2><pre><code>yum -y install httpdsystemctl enable httpd.service 开启启动httpd服务systemctl start  httpd.service 启动服务echo “WEB1”&gt;/var/www/html/index.html  在httpd下写一个测试网页curl http://localhost 测试一下看能不能看到“WEB1”  配置完后把VIP指向RS1ifconfig lo 192.168.1.150 netmask 255.255.255.0 【DR2】配置同上RS服务器上也要关闭防火墙，关闭selinux</code></pre><h2 id="安装ipvs"><a href="#安装ipvs" class="headerlink" title="安装ipvs"></a><strong>安装ipvs</strong></h2><pre><code>yum -y install ipvsadm modprobe ip_vs  #加载到内核 lsmod |grep ip_vs #查看是否有ipvs模块  【DR2】上同上配置</code></pre><h2 id="安装keepalived"><a href="#安装keepalived" class="headerlink" title="安装keepalived"></a><strong>安装keepalived</strong></h2><pre><code>yum -y install keepalived   systemctl enable keepalived 开机启动   systemctl start  keepalived 启动程序     yum -y install httpd ##这里装httpd做Server—server   echo &lt;h1System upgrade maintenance &lt;\h1&gt;/var/www/html/index.html  systemctl start httpd        </code></pre><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置:"></a><strong>修改配置</strong>:</h2><pre><code>vim /etc/keepalived/keepalived.conf配置文件如下：global_defs {notification_email {acassen@firewall.loc #设置报警邮件地址，可设置多个，每行一个failover@firewall.loc #需要开启右键报警以及本机的sendmail服务sysadmin@firewall.loc}notification_email_from Alexandre.Cassen@firewall.locsmtp_server 127.0.0.1  #设置SMTP Server地址smtp_connect_timeout 30router_id LVS_DEVEL}vrrp_instance VI_1 {state MASTER   #指定keepalived的角色，MASTER为主服务器，BACKUP为备用服务器interface eno16777736virtual_router_id 50priority 100 #定义优先级，数字越大，优先级越高，主Direvtor必须大于备用Directoradvert_int 1authentication {    auth_type PASS  #设置验证类型    auth_pass 1111  #设置验证密码,最好随机生成几位数字}virtual_ipaddress {  192.168.1.150    #设置主Director的VIP}virtual_server 192.168.1.150  80 { 设置VIP地址和端口 用空格隔开delay_loop 6     #设置健康检查时间，单位为秒lb_algo rr          #设置负载均衡调度算法，默认为rr，即轮循算法，最优秀的是wlc算法lb_kind DR        #设置LVS实现LB机制，有NAT,DR,TUN三种模式nat_mask 255.255.255.0persistence_timeout 50 #回话保持时间，单位为秒protocol TCP       #指定转发协议类型，有TCP和UDP两种real_server 192.168.1.132 80 {    weight 2    #配置节点权值，数字越大权值越高HTTP[_GET {       url {         path /          digest ff20ad2481f97b1754ef3e12ecd3a9cc        }        url {         path /mrtg/          digest 9b3a0c85a887a256d6939da88aabd8cd    connect_timeout 3        #表示3秒无响应，则超时        nb_get_retry 3        #表示重试次数        delay_before_retry 3    #表示重试间隔sorry_server 127.0.0.1 80  ##所有节点都down掉了，  soory_server可以当real_server使用，或者定义升级维护页面real_server 192.168.1.113 80 {    weight 1 # HTTP_GET {    #    url {      #    path /     #     digest ff20ad2481f97b1754ef3e12ecd3a9cc       # }        #url {         # path /mrtg/          #digest 9b3a0c85a887a256d6939da88aabd8cd       # }        connect_timeout 3        nb_get_retry 3        delay_before_retry 3        }}【DR2】配置大致同上，只需修改部分参数    1. 把state MASTER 改为 state BACKUP     2. 把priority 100 的优先值改成90然后保存即可</code></pre><h2 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a><strong>重启服务</strong></h2><pre><code>systemctl restart keepalived.service[DR1]#ipvsadm -L -n  出现以下信息表示配置成功，没有就返回上一步排错   IP Virtual Server version 1.2.1 (size=4096)   Prot LocalAddress:Port Scheduler Flags  -RemoteAddress:Port           Forward Weight   ActiveConn InActConn  TCP  192.168.1.150:80 rr persistent 50  -192.168.1.113:80             Route   1      0          0            -192.168.1.132:80             Route   2      0          0</code></pre><h2 id="抑制ARP响应"><a href="#抑制ARP响应" class="headerlink" title="抑制ARP响应"></a><strong>抑制ARP响应</strong></h2><pre><code>（防止将后端Real Server暴露在公网） 【DR1】# echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore   【DR1】# echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/lo/ arp_announce   【DR1】# echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignore   【DR1】# echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announcearp响应限制:   1）arp_ignore:    0 - (默认值): 回应任何网络接口上对任何本地IP地址的arp查询请求     1 - 只回答目标IP地址是来访网络接口本地地址的ARP查询请求   2）arp_announce:        0 - (默认) 在任意网络接口（eth0,eth1，lo）上的任何本地地址            2 - 对查询目标使用最适当的本地地址.在此模式下将忽略这个IP数据包的源地址并尝试选择与能与该地址通信的本地地址.        首要是选择所有的网络接口的子网中外出访问子网中包含该目标IP地址的本地地址.         如果没有合适的地址被发现,将选择当前的发送网络接口或其他的有可能接受到该ARP回应的网络接口来进行发送.</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h2><p>DR1和DR2上把keepalived服务都启动起来<br>systemctl keepalived status 查看服务当前状况<br>在浏览器输入“192.168.1.150” 看能否看到“WEB1”和“WEB2”<br>将DR2关掉看能否访问到“192.168.1.150”<br>还能看到“WEB1”“WEB2”<br>恭喜你 成功了！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;LVS&lt;/strong&gt;是Linux Virtual Server的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统。本项目在1998年5月由章文嵩博士成立，是中国国内最早出现的自由软件项目之一。目前有三种IP负载均衡技术（NAT、DR、TUN），十种调度算法（rr|wrr|lc|wlc|lblc|lblcr|dh|sh|sed|nq）
    
    </summary>
    
      <category term="Cluster" scheme="http://yoursite.com/categories/Cluster/"/>
    
    
      <category term="Lvs+Keepalived" scheme="http://yoursite.com/tags/Lvs-Keepalived/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/03/27/hello-world/"/>
    <id>http://yoursite.com/2018/03/27/hello-world/</id>
    <published>2018-03-27T05:22:38.470Z</published>
    <updated>2017-09-25T08:35:10.034Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Centos7 LAMP黄金组合之wordpress</title>
    <link href="http://yoursite.com/2018/03/27/lamp+weordpress/"/>
    <id>http://yoursite.com/2018/03/27/lamp+weordpress/</id>
    <published>2018-03-27T05:22:38.470Z</published>
    <updated>2017-09-26T03:18:32.366Z</updated>
    
    <content type="html"><![CDATA[<p>WordPress是一个注重美学、易用性和网络标准的个人信息发布平台。WordPress虽为免费的开源软件，但其价值无法用金钱来衡量。WordPress的图形设计在性能上易于操作、易于浏览；在外观上优雅大方、风格清新、色彩诱人。<br>使用WordPress可以搭建功能强大的网络信息发布平台，但更多的是应用于个性化的博客。针对博客的应用，WordPress能让您省却对后台技术的担心，集中精力做好网站的内容。<br><a id="more"></a><br><strong>目的：LAMP搭建wordpress博客</strong></p><pre><code>准备工作：1.上来先关闭防火墙 iptables -F2.ping以下网络是否通畅 ping www.baidu.com</code></pre><h2 id="安装Httpd"><a href="#安装Httpd" class="headerlink" title="安装Httpd"></a><strong>安装Httpd</strong></h2><pre><code>[root@wp ~]# yum -y install httpd[root@wp ~]# systemctl start  httpd.service   #启动httpd防火墙放行80端口以及http服务[root@wp ~]#firewell-cmd --permanent --add-service=http[root@wp ~]#fireewll-cmd --reload      #重启防火墙生效地址栏输入http://localhost 能看到apche测试页面即成功</code></pre><h2 id="安装mariadb"><a href="#安装mariadb" class="headerlink" title="安装mariadb"></a><strong>安装mariadb</strong></h2><pre><code>[root@wp ~]# yum -y install mariadb mariadb-server[root@wp ~]# systemctl enabled mariadb.service      #开机启动mysql[root@wp ~]# systemctl start mariadb.service      #启动mysql初始化mysql并设置密码：[root@wp ~]# mysql_secure_installation Enter current password for root (enter for none): #初次运行直接回车Set root password? [Y/n]  #是否设置root用户密码，输入y并回车或直接回车New password: #设置root用户的密码Re-enter new password: #再输入一次你设置的密码Remove anonymous users? [Y/n]  #是否删除匿名用户，回车Disallow root login remotely? [Y/n] #是否禁止root远程登录 ,回车,Remove test database and access to it? [Y/n] # 是否删除test数据库,回车Reload privilege tables now? [Y/n] #是否重新加载权限表，回车始化MariaDB完成，接下来测试登录 root@wp ~]# mysql -u root -p  #登录mysql </code></pre><h2 id="安装php"><a href="#安装php" class="headerlink" title="安装php"></a><strong>安装php</strong></h2><pre><code>[root@wp ~]# yum install php php-mysql php-gd libjpeg* php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-bcmath php-mhash[root@wp ~]# vim /var/www/html/index.php&lt;?phpphpinfo();?&gt;保存退出！  systemctl restart httpd.service  浏览器地址栏输入http://localhost 能看到php测试页面即成功</code></pre><h2 id="配置wordpress"><a href="#配置wordpress" class="headerlink" title="配置wordpress"></a><strong>配置wordpress</strong></h2><pre><code>进入wordpress目录  [root@wp ~]# cd /wordpress[root@wp ~]# cp wp-config-sample.php wp-config.php   #复制主配置文并改名为wp-config.php开始配置wp-config.php[root@wp ~]# vim wp-config.php/ ** MySQL settings - You can get this info from your web host ** ///** The name of the database for WordPress */define(&apos;DB_NAME&apos;, &apos;wordpressdb&apos;); #数据库名称/** MySQL database username */ #数据库用户名define(&apos;DB_USER&apos;, &apos;wordpressuser&apos;);/** MySQL database password */ #数据库密码define(&apos;DB_PASSWORD&apos;, &apos;wordpresspassword&apos;);wq保存退出配置完成后将wordpress目录下所有文件移动到/var/www/html下chown -R apache:apache /var/www/html/chmod -R 755 /var/www/html</code></pre><h2 id="mysql授权配置"><a href="#mysql授权配置" class="headerlink" title="mysql授权配置"></a><strong>mysql授权配置</strong></h2><pre><code>[root@wp ~]# mysql -u root -pMariaDB [mysql]&gt; create database  wordpressdb;  #（创建库）MariaDB [mysql]&gt; create user wordpressuser@localhost identified by &apos;wordpresspassword&apos;;  #（创建用户并设置密码）MariaDB [mysql]&gt; grant all privileges on  wordpressdb.* to wordpressuser@localhost;  #(给wordpressuser对wordpress授取所有权) MariaDB [mysql]&gt; flush privileges;    #（重读数据库变量）配置完重启服务:MariaDB [mysql]&gt; service httpd restartMariaDB [mysql]&gt; service  mariadb restart#我一般不喜欢用Phpmyadmin，直接用Navicat</code></pre><h2 id="配置Wordpress"><a href="#配置Wordpress" class="headerlink" title="配置Wordpress"></a><strong>配置Wordpress</strong></h2><p>浏览器地址栏输入<a href="http://localhost" target="_blank" rel="external">http://localhost</a><br>配置成功后应该是这个样子的，主题相关参数自行配置，<br>是不是很时尚，wordpress有很多时尚的主题自己选择一个安装吧吧<br><img src="http://i.imgur.com/VPlfHLE.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WordPress是一个注重美学、易用性和网络标准的个人信息发布平台。WordPress虽为免费的开源软件，但其价值无法用金钱来衡量。WordPress的图形设计在性能上易于操作、易于浏览；在外观上优雅大方、风格清新、色彩诱人。&lt;br&gt;使用WordPress可以搭建功能强大的网络信息发布平台，但更多的是应用于个性化的博客。针对博客的应用，WordPress能让您省却对后台技术的担心，集中精力做好网站的内容。&lt;br&gt;
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="LAMP+Wordpress" scheme="http://yoursite.com/tags/LAMP-Wordpress/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 HAproxy实现反向代理和资源动静分离</title>
    <link href="http://yoursite.com/2018/03/27/haproxy/"/>
    <id>http://yoursite.com/2018/03/27/haproxy/</id>
    <published>2018-03-27T05:22:38.455Z</published>
    <updated>2017-09-26T03:25:49.311Z</updated>
    
    <content type="html"><![CDATA[<p>HAProxy 是一款提供高可用性、负载均衡以及基于TCP（第四层）和HTTP（第七层）应用的代理软件， 支持虚拟主机，它是免费、快速并且可靠的一种解决方案。 HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。HAProxy运行在时下的硬件上，完全可以支持数以万计的 并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中， 同时可以保护你的web服务器不被<a id="more"></a>暴露到网络上。<br>HAProxy 实现了一种事件驱动、单一进程模型，此模型支持非常大的并发连接数。多进程或多线程模型受内存限制 、系统调度器限制以及无处不在的锁限制，很少能处理数千并发连接。 事件驱动模型因为在有更好的资源和时间管理的用户端(User-Space) 实现所有这些任务，所以没有这些问题。此模型的弊端是，在多核系统上，这些程序通常扩展性较差。<br>这就是为什么他们必须进行优化以 使每个CPU时间片(Cycle)做更多的工作。</p><p><strong>总结</strong>：HAproxy只是Http协议的反向代理，不提供内存，但额外支持对TCP层基于Http通信的应用做负载均衡</p><p>架构图<br><img src="http://i.imgur.com/BeI8SzP.jpg" alt=""></p><p><strong>HAproxy工作模式</strong>：<br>        1、Http反向代理<br>        2、TCP连接负载均衡</p><p><strong>HAproxy的配置文件格式</strong>：<br>    global: 设定全局配置参数<br>    proxy：定义”defaults” “listen” “frontend” “backend”</p><p>三台主机：<br>    HAProxy:192.168.1.51<br>    Web1:192.168.1.52<br>    Web2:192.168.1.53</p><p><strong>目的：利用HAproxy实现反向代理和资源动静分离</strong></p><h2 id="利用HAproxy实现反向代理"><a href="#利用HAproxy实现反向代理" class="headerlink" title="利用HAproxy实现反向代理"></a>利用HAproxy实现反向代理</h2><pre><code>Web1主机安装httpd[root@web1 ~]# yum -y install httpd[root@web1 ~]# echo web1 &gt; /var/www/html/index.html[root@web1 ~]# systemctl start httpd[root@web1 ~]# firewall-cmd --permanent --add-service=http[root@web1 ~]# firewall-cmd --reload[root@web1 ~]# curl http://192.168.1.52    web1Web2主机配置同上Proxy主机安装HAproxy[root@proxy ~]# yum -y install haproxy.x86_64[root@proxy ~]# vim /etc/haproxy/haproxy.cfgchroot      /var/lib/haproxy #工作目录pidfile     /var/run/haproxy.pid #pid文件maxconn     4000 #最大连接数user        haproxy #进程启动以哪个用户来运行group       haproxydaemon  #启动为守护进程，不加daemon将会运行在前台frontend  main *:80 #监听的端口  efault_backend    webserver  backend webserver    balance     roundrobin  #使用roundrobin算法（rr轮询）    #用法:server &lt;name&gt; &lt;addr&gt;[:port] [param]  server web1 192.168.1.52:80 check weight=1 #check做健康监测，默认2秒一次,weight定义权重  server web2 192.168.1.53:80 check weight=1[root@proxy ~]# systemctl start haproxy.service    [root@proxy ~]# curl http://192.168.1.51    web1[root@proxy ~]# curl http://192.168.1.51    web2[root@proxy ~]# firewall-cmd --permanent --add-port=80/tcp[root@proxy ~]# firewall-cmd --reload </code></pre><h2 id="基于浏览器cookie实现session-sticke"><a href="#基于浏览器cookie实现session-sticke" class="headerlink" title="基于浏览器cookie实现session sticke"></a><strong>基于浏览器cookie实现session sticke</strong></h2><pre><code>backend webserverbalance     roundrobincookie SERVERID insert nocahe #设置cookie,insert插入，nocache不允许缓存，indirect间接方式让cookie生效server web1 192.168.1.52:80 check weight=1 cookie websrv1 #绑定cookie并指定cookie名称server web2 192.168.1.53:80 check weight=1 cookie websrv2要点：（1）每个server有自己唯一的cookie标识（2）在backend中定义为用户请求调度完成操作其cookie</code></pre><h2 id="Haproxy的几种调度方法"><a href="#Haproxy的几种调度方法" class="headerlink" title="Haproxy的几种调度方法"></a><strong>Haproxy的几种调度方法</strong></h2><pre><code>动态：（权重可以动态调整）静态：（调整权重不会立即生效，需要重启服务生效）1、Roundrobin(rr轮询）:根据权重的比率在服务器之间公平调度，每个后端服务器最多可以承载4128个并发连接，属于动态2、Leastcinn: 根据后端服务器的负载数量进行调度，仅适用于长连接回话，属于动态3、Static（rr轮询）:和roundrobin类似，但是不支持实时修改权重，后端服务器并发连接理论没有上限，属于静态，4、Source：将连接请求的源地址进行Hash计算，并由后端服务器的权重总和相除后转发至匹配的服务器，是否静态或动态，取决于Hash-type5、URI: 对uri左半部分或对整个uri进行Hash计算,并由服务器的总权重相除后派至匹配后的某个服务器，特别适用于代理缓存服务器应用场景6、Hdr&lt;name&gt;: 根据请求报文中指定的header,（如：user_agent,referer,hostname）进行调度，把指定的header的值做hash计算,Hash_type7、URL_param: 根据url中指定参数的值进行调度，把值做Hash计算，并除以总权重，Hash_type   ##只要用到Hash算法，就会根据Hash_type的值来确定是动态还是静态Hash-type：     1、map-hash(取模法)，静态     2、consistent(一致性哈希)，动态</code></pre><h2 id="配置stats管理界面"><a href="#配置stats管理界面" class="headerlink" title="配置stats管理界面"></a><strong>配置stats管理界面</strong></h2><pre><code>[root@proxy ~]# vim /etc/haproxy/haproxy.cfgfrontend  main    bind *:80default_backend             webserverlisten stat    bind 192.168.1.51:9000 #管理页面的端口    stats enable #开启stats页面stats hide-version #隐藏版本号    stats uri /admin #访问stats的url    stats realm haproxy\ admin\ area  #需要认证时，认证框里面的提示信息    stats auth admin:admin #认证的账号和密码（user:password）    stats refresh 5s #打开页面后每秒刷新间隔    stats admin if TRUE #是否开启管理功能然后浏览器输入 192.168.1.51:9000/admin 根据提示输入用户和密码</code></pre><p><strong>密码验证：</strong><br><img src="http://i.imgur.com/SF8yIvm.png" alt=""></p><p><strong>管理界面：</strong><br><img src="http://i.imgur.com/Qghcrij.png" alt=""></p><h2 id="利用Haproxy实现动静分离"><a href="#利用Haproxy实现动静分离" class="headerlink" title="利用Haproxy实现动静分离"></a><strong>利用Haproxy实现动静分离</strong></h2><pre><code>[root@proxy ~]# vim /etc/haproxy/haproxy.cfgfrontend  main    bind *:80default_backend   dynamic #默认backend为dynamic    acl url_static path_end -i .php #访问控制列表，匹配结尾.php资源    use_backend static if url_static #如果结尾是.php，则backend为staticbackend staticbalance    roundrobin  #这里使用roundrobin算法server dynamic 192.168.1.53:80 checkbackend dynamic    balance uri#这里使用uri算法    server static 192.168.1.52:80 check</code></pre><h2 id="客户端资源验证"><a href="#客户端资源验证" class="headerlink" title="客户端资源验证"></a><strong>客户端资源验证</strong></h2><p><strong>静态资源</strong><br><img src="http://i.imgur.com/s5bHNdg.png" alt=""><br><strong>动态资源</strong><br><img src="http://i.imgur.com/EDRdtgx.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HAProxy 是一款提供高可用性、负载均衡以及基于TCP（第四层）和HTTP（第七层）应用的代理软件， 支持虚拟主机，它是免费、快速并且可靠的一种解决方案。 HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。HAProxy运行在时下的硬件上，完全可以支持数以万计的 并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中， 同时可以保护你的web服务器不被
    
    </summary>
    
      <category term="HAproxy" scheme="http://yoursite.com/categories/HAproxy/"/>
    
    
      <category term="HAproxy" scheme="http://yoursite.com/tags/HAproxy/"/>
    
  </entry>
  
</feed>
