<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wenbing&#39;s  Blog</title>
  
  <subtitle>人生一世，勤学须早</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhuwenbing.top/"/>
  <updated>2019-09-06T11:27:06.546Z</updated>
  <id>http://zhuwenbing.top/</id>
  
  <author>
    <name>Wenbing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python练习题</title>
    <link href="http://zhuwenbing.top/2019/09/05/python02_%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <id>http://zhuwenbing.top/2019/09/05/python02_练习题/</id>
    <published>2019-09-05T09:26:35.516Z</published>
    <updated>2019-09-06T11:27:06.546Z</updated>
    
    <content type="html"><![CDATA[<p>文章主要内容如下：</p><ul><li>打印空心正方形</li><li>求奇数的和</li><li>判断学生成绩</li><li>求1到5的阶乘之和</li><li>求5以内的素数 <a id="more"></a></li><li>求圆的面积和周长</li><li>数字排序 </li><li>九九乘法表</li><li>闪电符号</li><li>斐波那契</li></ul><h2 id="1，打印空心正方形"><a href="#1，打印空心正方形" class="headerlink" title="1，打印空心正方形"></a><strong>1，打印空心正方形</strong></h2><pre><code>代码如下：for i in range(1,12):    if i == 1 or i == 11:        print(&apos;+&apos; * 20)    else:        print(&apos;+&apos; + (&apos; &apos; * 18) + &apos;+&apos;)输出结果：PS D:\Software\python_object&gt;+++++++++++++++++++++                  ++                  ++                  ++                  ++                  ++                  ++                  ++                  ++                  +++++++++++++++++++++PS D:\Software\python_object&gt;</code></pre><h2 id="2，求100以内所有奇数的和"><a href="#2，求100以内所有奇数的和" class="headerlink" title="2，求100以内所有奇数的和"></a><strong>2，求100以内所有奇数的和</strong></h2><pre><code>代码如下：sum = 0for i in range(1,100,2):    sum +=iprint(sum)输出结果：PS D:\Software\python_object&gt;2500PS D:\Software\python_object&gt;</code></pre><h2 id="3，判断学生成绩，成绩等级A-E-其中90分以上为A-80分-89分为B-70-79分为C-60-69分为D，60分以下为E"><a href="#3，判断学生成绩，成绩等级A-E-其中90分以上为A-80分-89分为B-70-79分为C-60-69分为D，60分以下为E" class="headerlink" title="3，判断学生成绩，成绩等级A-E,其中90分以上为A, 80分-89分为B, 70-79分为C,60-69分为D，60分以下为E"></a><strong>3，判断学生成绩</strong>，成绩等级A-E,其中90分以上为A, 80分-89分为B, 70-79分为C,60-69分为D，60分以下为E</h2><pre><code>代码如下：score=int(input(&quot;pleas input your socre: &quot;))if score &gt;= 90:    print(&quot;A&quot;)elif score &gt;= 80 and score &lt;= 89:    print(&quot;B&quot;)elif score &gt;= 70 and score &lt;= 79:    print(&quot;C&quot;)elif score &gt;= 60 and score &lt;= 69:    print(&quot;D&quot;)else:    print(&quot;E&quot;)输出结果：PS D:\Software\python_object&gt;  pleas input your socre: 89BPS D:\Software\python_object&gt;pleas input your socre: 53EPS D:\Software\python_object&gt;</code></pre><h2 id="4，求1到5的阶乘之和"><a href="#4，求1到5的阶乘之和" class="headerlink" title="4，求1到5的阶乘之和"></a><strong>4，求1到5的阶乘之和</strong></h2><pre><code>代码如下：s = 1sum = 0for i in range(1,6):    s = s*i    sum += sprint(s)print(sum)输出结果：PS D:\Software\python_object&gt;120153PS D:\Software\python_object&gt; </code></pre><h2 id="5，求5以内的素数"><a href="#5，求5以内的素数" class="headerlink" title="5，求5以内的素数"></a><strong>5，求5以内的素数</strong></h2><pre><code>代码如下num = int(input(&quot;plese ainput a prime number: &quot;))for i in range(2,num):    if num % i == 0:        print(i,&quot; is not prime number!&quot;)        break    else:        print(i,&quot;is a prime number!&quot;)输出结果：PS D:\Software\python_object&gt;plese ainput a prime number: 52 is a prime number!3 is a prime number!4 is a prime number!PS D:\Software\python_object&gt;</code></pre><h2 id="6，给一个半径，求圆的面积和周长"><a href="#6，给一个半径，求圆的面积和周长" class="headerlink" title="6，给一个半径，求圆的面积和周长"></a><strong>6，给一个半径，求圆的面积和周长</strong></h2><pre><code>代码如下：r =int(input(&quot;请输入半径: &quot;))print(&quot;面积:&quot;,2*3.14*r)print(&quot;周长:&quot;,3.14*(r**2))输出结果：PS D:\Software\python_object&gt;请输入半径: 5面积: 31.400000000000002周长: 78.5PS D:\Software\python_object&gt;</code></pre><h2 id="7，输入2个数，比较大小后，从小到大排序打印"><a href="#7，输入2个数，比较大小后，从小到大排序打印" class="headerlink" title="7，输入2个数，比较大小后，从小到大排序打印"></a><strong>7，输入2个数，比较大小</strong>后，从小到大排序打印</h2><pre><code>代码如下：a=int(input(&quot;please input a first number: &quot;))b=int(input(&quot;please input a second number: &quot;))if a &gt; b:    print(b,a)else:    print(a,b)输出结果：PS D:\Software\python_object&gt;please input a first number: 4please input a second number: 11 4PS D:\Software\python_object&gt;please input a first number: 3please input a second number: 11 3</code></pre><h2 id="8-打印九九乘法表"><a href="#8-打印九九乘法表" class="headerlink" title="8,打印九九乘法表"></a><strong>8,打印九九乘法表</strong></h2><pre><code>代码如下：for i in range(1,10):for j in range(1,i+1):    print(&quot;%d*%d=%d &quot;%(j,i,j*i)+&quot;\t&quot;,end=(&quot;&quot;))print(&quot;&quot;)输出结果：PS D:\Software\python_object&gt;1*1=11*2=2   2*2=41*3=3   2*3=6   3*3=91*4=4   2*4=8   3*4=12  4*4=161*5=5   2*5=10  3*5=15  4*5=20  5*5=251*6=6   2*6=12  3*6=18  4*6=24  5*6=30  6*6=361*7=7   2*7=14  3*7=21  4*7=28  5*7=35  6*7=42  7*7=491*8=8   2*8=16  3*8=24  4*8=32  5*8=40  6*8=48  7*8=56  8*8=641*9=9   2*9=18  3*9=27  4*9=36  5*9=45  6*9=54  7*9=63  8*9=72  9*9=81PS D:\Software\python_object&gt;</code></pre><h2 id="9，打印闪电符号"><a href="#9，打印闪电符号" class="headerlink" title="9，打印闪电符号"></a><strong>9，打印闪电符号</strong></h2><pre><code>代码如下：for i in range(-3,4):if i &lt; 0:    a = -i    print(&quot; &quot;*a+(4-a)*&quot;@&quot;)elif i == 0:    print(&quot;@&quot;*7)else:    print(&quot; &quot;*3+&quot;@&quot;*(4-i))输出结果：PS D:\Software\python_object&gt;   @  @@ @@@@@@@@@@   @@@   @@   @PS D:\Software\python_object&gt;</code></pre><h2 id="10，求10项目内斐波那契数"><a href="#10，求10项目内斐波那契数" class="headerlink" title="10，求10项目内斐波那契数"></a><strong>10，求10项目内斐波那契数</strong></h2><pre><code>代码如下：def feibo(n):if n &lt;= 1:    return nelse:    return(feibo(n-1)+feibo(n-2))num =int(input(&quot;你需要打印到第几项: &quot;))for i in range(num):    print(feibo(i))输出结果：PS D:\Software\python_object&gt;你需要打印到第几项: 501123PS D:\Software\python_object&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章主要内容如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打印空心正方形&lt;/li&gt;
&lt;li&gt;求奇数的和&lt;/li&gt;
&lt;li&gt;判断学生成绩&lt;/li&gt;
&lt;li&gt;求1到5的阶乘之和&lt;/li&gt;
&lt;li&gt;求5以内的素数
    
    </summary>
    
      <category term="Python" scheme="http://zhuwenbing.top/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>python语法基础</title>
    <link href="http://zhuwenbing.top/2019/09/04/python01_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://zhuwenbing.top/2019/09/04/python01_基础语法/</id>
    <published>2019-09-04T03:12:33.529Z</published>
    <updated>2019-09-05T08:24:46.027Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习Python相关的知识，学习了很久，知识真的是很长时间不用就会忘记，重新学习看网上的文档很混乱，还是自己总结比较好，需要用的时候找起来也方便。python是一门解释性语言，动态语言，强类型语言，这些又是什么意思呢，查看网上的解释和自己的理解，分享一下。</p><p>文章主要涉及Python以下内容：<a id="more"></a></p><ul><li>转义序列</li><li>算数运算符</li><li>位运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>成员运算符</li><li>身份运算符</li></ul><h2 id="语言分类"><a href="#语言分类" class="headerlink" title="语言分类"></a><strong>语言分类</strong></h2><pre><code>编译语言：编辑器把代码程序编译成一个文件才能执行的语言，(例如.exe)解释语言：一边解释，一边执行两者的区别：白话解释：编译语言就像炒菜，非要把菜炒好了才能吃         解释语言就像吃火锅，可以一边煮一边吃</code></pre><h2 id="静态和动态语言"><a href="#静态和动态语言" class="headerlink" title="静态和动态语言"></a><strong>静态和动态语言</strong></h2><pre><code>静态语言：使用前必须声明变量类型，类型不能再改变，编译的时候会检查动态语言：不用事先声明变量，随时可以赋值为其他类型</code></pre><h2 id="强弱类型语言"><a href="#强弱类型语言" class="headerlink" title="强弱类型语言"></a><strong>强弱类型语言</strong></h2><pre><code>强类型语言：不同类型之间操作，必须先“强制类型转换”为同一类型,如python print(&apos;a&apos;+1)弱类型语言：不同类型之间可以操作，自动隐士转换，如javaScript中console(1+&apos;a&apos;)</code></pre><p><strong>python基础语法</strong>：</p><h2 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a><strong>转义序列</strong></h2><pre><code>转义符主要有：\\  \t  \r  \n \&apos; \&quot;\用法：&gt;&gt;&gt; print(&apos;c:\user\test&apos;)  File &quot;&lt;stdin&gt;&quot;, line 1SyntaxError: (unicode error) &apos;unicodeescape&apos; codec can&apos;t decode bytes in position 2-3: truncated \uXXXX escape&gt;&gt;&gt; print(&apos;c:\\user\\test&apos;)c:\user\test&gt;&gt;&gt;</code></pre><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a><strong>算数运算符</strong></h2><pre><code>  算数运算符主要有6种：+ - * / % **自然数除/的结果是浮点数，整除//    例子：&gt;&gt;&gt; 2 * 3    乘6&gt;&gt;&gt; 6 / 3    除2.0&gt;&gt;&gt; 6//3     整除2&gt;&gt;&gt; 10 % 3   取模1&gt;&gt;&gt; 2 ** 2   幂运算4</code></pre><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a><strong>位运算符</strong></h2><pre><code>位运算符主要有6种：&amp;：按位与运算，参与的运算的2个值，如果相应位都是1，则该位的结果为1，否则为0|：按位或运算，只要对应的2个二进制有一个为1时，则结果为1^：按位异或运算，当2个对应的二进位想异时，结果为1~：按位取反运算，对数据的每个二进制位取反，即1变成0,0变成1&lt;&lt;：左移位运算，运算的各二进位全部左移若干位，高位丢弃，低位补0&gt;&gt;：右移位运算，运算的各二进位全部右移若干位，高位丢弃，低位补0例子：&gt;&gt;&gt; a=60&gt;&gt;&gt; b=13&gt;&gt;&gt; a &amp; b12&gt;&gt;&gt; a | b61&gt;&gt;&gt; ~a-61&gt;&gt;&gt; a ^ b49&gt;&gt;&gt; a &lt;&lt; 2   向左边移动2位240&gt;&gt;&gt; a &gt;&gt; 2   向右边移动2位15&gt;&gt;&gt;解答“&amp;运算”为什么结果是12：60在二进制表示：0011 110013再二进制表示：0000 1101按&amp;位运算符号的定义，结果为：0000 1100 </code></pre><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a><strong>比较运算符</strong></h2><pre><code>比较运算符主要有6种：==：比较对象是否相等    !=：，比较两个对象是否不相等    &gt;：返回a是否大于b    &lt;：返回a是否小于b&gt;=：返回a是否大于等于b&lt;=：返回a是否小于等于b    所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。&gt;&gt;&gt; a=60&gt;&gt;&gt; b=13&gt;&gt;&gt; a == bFalse&gt;&gt;&gt; a != bTrue&gt;&gt;&gt; a &gt; bTrue&gt;&gt;&gt; a &lt; bFalse&gt;&gt;&gt; a &gt;= bTrue&gt;&gt;&gt; a &lt;= bFalse&gt;&gt;&gt;</code></pre><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a><strong>逻辑运算符</strong></h2><pre><code>逻辑运算符主要有3种：and     如果 a 为 False，a and b 返回 False，否则它返回 b 的计算值。    or     如果 a 为 True，它返回 a 的值，否则它返回 b 的计算值。not     如果 a 为 True，返回 False 。如果 a 为 False，它返回 True。&gt;&gt;&gt; a and b   a为True所以返回b的值13&gt;&gt;&gt; a or b    a为True所以返回a的值60&gt;&gt;&gt; not a     a为True所以返回FalseFalse</code></pre><h2 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a><strong>成员运算符</strong></h2><pre><code>成员运算符主要有2种：    in：如果在指定的序列找打了值返回True，否则为False    not in:如果没有在指定的序列找打值返回True,否则返回True&gt;&gt;&gt; lst =(1,3,6,8,4)&gt;&gt;&gt; 2 in lstFalse&gt;&gt;&gt; 3 in lstTrue&gt;&gt;&gt; 9 not in lstTrue&gt;&gt;&gt; 8 not in lstFalse&gt;&gt;&gt;</code></pre><h2 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a><strong>身份运算符</strong></h2><pre><code>身份运算符主要有2种：    is：判断2个标识符是不是引用自一个对象    is not：判断2个标识符是不是引用自不同对象&gt;&gt;&gt; a = 20&gt;&gt;&gt; b = 20&gt;&gt;&gt; id(a)140710943307184&gt;&gt;&gt; id(b)140710943307184&gt;&gt;&gt;&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; id(a) is id(b)False&gt;&gt;&gt; a is not bFalse&gt;&gt;&gt; id(a) is not id(b)True&gt;&gt;&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习Python相关的知识，学习了很久，知识真的是很长时间不用就会忘记，重新学习看网上的文档很混乱，还是自己总结比较好，需要用的时候找起来也方便。python是一门解释性语言，动态语言，强类型语言，这些又是什么意思呢，查看网上的解释和自己的理解，分享一下。&lt;/p&gt;
&lt;p&gt;文章主要涉及Python以下内容：
    
    </summary>
    
      <category term="Python" scheme="http://zhuwenbing.top/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python冒泡法排序</title>
    <link href="http://zhuwenbing.top/2019/08/27/Python%E5%86%92%E6%B3%A1%E6%B3%95/"/>
    <id>http://zhuwenbing.top/2019/08/27/Python冒泡法/</id>
    <published>2019-08-27T02:20:32.635Z</published>
    <updated>2019-08-27T02:24:33.396Z</updated>
    
    <content type="html"><![CDATA[<p>冒泡法排序是一种简单的排序算法，它的思想是，重复的遍历要排序的列表，一次比较2个元素，如果他们的排序错误就把他们的位置交换过来，直到没有需要再交换的元素，表明该列表已经排序完成。</p><p>例子：<br> 有下面这样一个列表，利用冒泡法实现排序<br><a id="more"></a><br> li=[10,6,4,5,7,9,2,1,3,8]</p><pre><code>代码如下：li=[10,6,4,5,7,9,2,1,3,8]for i in range(len(li)-1):#列表中一共有10个数，两两比较，因此实际次数为9    for j in range(len(li)-1-i):    #每次冒泡确认一个最大值，因此只需要n-1冒泡        if li[j] &gt; li[j+1]:        #判断前面的数是否大于后面的数           li[j],li[j+1] = li[j+1],li[j]           #如果大于则交换位置print(li)#打印排序后的列表处理过程：[6, 10, 4, 5, 7, 9, 2, 1, 3, 8][6, 4, 10, 5, 7, 9, 2, 1, 3, 8][6, 4, 5, 10, 7, 9, 2, 1, 3, 8][6, 4, 5, 7, 10, 9, 2, 1, 3, 8][6, 4, 5, 7, 9, 10, 2, 1, 3, 8][6, 4, 5, 7, 9, 2, 10, 1, 3, 8][6, 4, 5, 7, 9, 2, 1, 10, 3, 8][6, 4, 5, 7, 9, 2, 1, 3, 10, 8][6, 4, 5, 7, 9, 2, 1, 3, 8, 10][4, 6, 5, 7, 9, 2, 1, 3, 8, 10][4, 5, 6, 7, 9, 2, 1, 3, 8, 10][4, 5, 6, 7, 2, 9, 1, 3, 8, 10][4, 5, 6, 7, 2, 1, 9, 3, 8, 10][4, 5, 6, 7, 2, 1, 3, 9, 8, 10][4, 5, 6, 7, 2, 1, 3, 8, 9, 10][4, 5, 6, 2, 7, 1, 3, 8, 9, 10][4, 5, 6, 2, 1, 7, 3, 8, 9, 10][4, 5, 6, 2, 1, 3, 7, 8, 9, 10][4, 5, 2, 6, 1, 3, 7, 8, 9, 10][4, 5, 2, 1, 6, 3, 7, 8, 9, 10][4, 5, 2, 1, 3, 6, 7, 8, 9, 10][4, 2, 5, 1, 3, 6, 7, 8, 9, 10][4, 2, 1, 5, 3, 6, 7, 8, 9, 10][4, 2, 1, 3, 5, 6, 7, 8, 9, 10][2, 4, 1, 3, 5, 6, 7, 8, 9, 10][2, 1, 4, 3, 5, 6, 7, 8, 9, 10][2, 1, 3, 4, 5, 6, 7, 8, 9, 10][1, 2, 3, 4, 5, 6, 7, 8, 9, 10]最后结果：PS D:\Software\python_object&gt;  **[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]**PS D:\Software\python_object&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;冒泡法排序是一种简单的排序算法，它的思想是，重复的遍历要排序的列表，一次比较2个元素，如果他们的排序错误就把他们的位置交换过来，直到没有需要再交换的元素，表明该列表已经排序完成。&lt;/p&gt;
&lt;p&gt;例子：&lt;br&gt; 有下面这样一个列表，利用冒泡法实现排序&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://zhuwenbing.top/categories/Python/"/>
    
    
      <category term="Python" scheme="http://zhuwenbing.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>创建Docker私有仓库</title>
    <link href="http://zhuwenbing.top/2018/04/18/docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>http://zhuwenbing.top/2018/04/18/docker私有仓库/</id>
    <published>2018-04-18T14:28:36.370Z</published>
    <updated>2018-04-18T14:38:47.689Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp; 仓库是存放镜像的地方，每个服务器可以有多个仓库，而每个仓库下面有多个镜像。仓库分为公库和私库，官方的公共仓库就是docker Hub,不过国内被墙。今天就来创建一个私有仓库<br><a id="more"></a><br>docker registry是官方提供的工具，用来构建私有镜像仓库</p><h2 id="启动registry镜像"><a href="#启动registry镜像" class="headerlink" title="启动registry镜像"></a>启动registry镜像</h2><pre><code>[root@ubuntu:~]# docker run -d -p 5000:5000 --restart=always --name registry registryUnable to find image &apos;registry:latest&apos; locallylatest: Pulling from library/registry81033e7c1d6a: Pull completeb235084c2315: Pull completec692f3a6894b: Pull completeba2177f3a70e: Pull completea8d793620947: Pull completeDigest: sha256:672d519d7fd7bbc7a448d17956ebeefe225d5eb27509d8dc5ce67ecb4a0bce54Status: Downloaded newer image for registry:lateste97c298aabcdb30b1901b33b03768c78bcda3643c3255084ad3cbe4df68e6a8c将registry镜像启动私有仓库，仓库会被创建在容器/var/lib/registry目录下，使用-v参数来讲镜像文件放到本地/opt/data/registry下报错：[root@ubuntu:~]# docker run -d  -p 5000:5000  -v /opt/data/registry:/var/lib/registry registry08ccd61cfc5fe2fdcbee16aede38807ca80239141f5e6dd6adf3cb825ef76f62docker: Error response from daemon: driver failed programming external connectivity on endpoint unruffled_villani (b12b514dc8419abf708dca81f227997b4957f0cb3f52432978b25760b4f7a9dc): Bind for 0.0.0.0:5000 failed: port is already allocated.停掉占用端口的容器即可[root@ubuntu:/]# docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry registry49bc7964d631d1c45058a1b03305106c13afb959eb4c794c6fed9233c1c1ce1b[root@ubuntu:/]# cd /opt/data/[root@ubuntu:/opt/data]# lsregistry可以看到registry目录，表示成功了</code></pre><h2 id="docker-tag"><a href="#docker-tag" class="headerlink" title="docker tag"></a>docker tag</h2><pre><code>将test/ubuntu v1.0 这个镜像标记为 127.0.0.0:5000/ubuntu:latest[root@ubuntu:/opt/data]# docker image lsREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEtest/ubuntu         v1.0                072cd43a3a6a        2 hours ago         85.8MB&lt;none&gt;              &lt;none&gt;              0ccd5ef276a3        47 hours ago        85.8MBubuntu              latest              c9d990395902        2 days ago          113MBubuntu              17.10               14107f6d2c97        2 days ago          99.1MBcentos              latest              e934aafc2206        8 days ago          199MBregistry            latest              d1fd7d86a825        3 months ago        33.3MB[root@ubuntu:/opt/data]# docker tag test/ubuntu:v1.0 127.0.0.0:5000/ubuntu:latest[root@ubuntu:/opt/data]# docker image lsREPOSITORY              TAG                 IMAGE ID            CREATED             SIZE127.0.0.0:5000/ubuntu   latest              072cd43a3a6a        2 hours ago         85.8MBtest/ubuntu             v1.0                072cd43a3a6a        2 hours ago         85.8MB&lt;none&gt;                  &lt;none&gt;              0ccd5ef276a3        47 hours ago        85.8MBubuntu                  latest              c9d990395902        2 days ago          113MBubuntu                  17.10               14107f6d2c97        2 days ago          99.1MBcentos                  latest              e934aafc2206        8 days ago          199MBregistry                latest              d1fd7d86a825        3 months ago        33.3MB[root@ubuntu:/opt/data]#</code></pre><h2 id="docker-push"><a href="#docker-push" class="headerlink" title="docker push"></a>docker push</h2><pre><code>上传标记的镜像[root@ubuntu:/opt/data]# docker push 127.0.0.1:5000/ubuntuThe push refers to repository [127.0.0.1:5000/ubuntu]414667feb05a: Pushedlatest: digest: sha256:c408657b59e55a1ca24e7b5165bdf620031c79d5b803b2df68b12ed249dfe951 size: 528</code></pre><h2 id="curl查看仓库中的镜像"><a href="#curl查看仓库中的镜像" class="headerlink" title="curl查看仓库中的镜像"></a>curl查看仓库中的镜像</h2><pre><code>可以看到 {&quot;repositories&quot;:[&quot;ubuntu&quot;]} 表示上传成功[root@ubuntu:/opt/data]# curl 127.0.0.1:5000/v2/_catalog{&quot;repositories&quot;:[&quot;ubuntu&quot;]}</code></pre><h2 id="验证："><a href="#验证：" class="headerlink" title="验证："></a>验证：</h2><pre><code>删除已经创建的127.0.0.1:5000/ubuntu镜像，再从私有仓库下载刚创建的镜像[root@ubuntu:/opt/data]# docker image rm 127.0.0.1:5000/ubuntuUntagged: 127.0.0.1:5000/ubuntu:latestUntagged: 127.0.0.1:5000/ubuntu@sha256:c408657b59e55a1ca24e7b5165bdf620031c79d5b803b2df68b12ed249dfe951这里可以看到镜像已经被删除了[root@ubuntu:/opt/data]# docker image lsREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEtest/ubuntu         v1.0                072cd43a3a6a        2 hours ago         85.8MB&lt;none&gt;              &lt;none&gt;              0ccd5ef276a3        47 hours ago        85.8MBubuntu              latest              c9d990395902        2 days ago          113MBubuntu              17.10               14107f6d2c97        2 days ago          99.1MBcentos              latest              e934aafc2206        8 days ago          199MBregistry            latest              d1fd7d86a825        3 months ago        33.3MB重新从仓库下载带有127.0.0.1:5000/ubuntu标签的镜像[root@ubuntu:/opt/data]# docker pull 127.0.0.1:5000/ubuntuUsing default tag: latestlatest: Pulling from ubuntuDigest: sha256:c408657b59e55a1ca24e7b5165bdf620031c79d5b803b2df68b12ed249dfe951Status: Downloaded newer image for 127.0.0.1:5000/ubuntu:latest这样就下载成功了[root@ubuntu:/opt/data]# docker image lsREPOSITORY              TAG                 IMAGE ID            CREATED             SIZE127.0.0.1:5000/ubuntu   latest              072cd43a3a6a        2 hours ago         85.8MBtest/ubuntu             v1.0                072cd43a3a6a        2 hours ago         85.8MB&lt;none&gt;                  &lt;none&gt;              0ccd5ef276a3        47 hours ago        85.8MBubuntu                  latest              c9d990395902        2 days ago          113MBubuntu                  17.10               14107f6d2c97        2 days ago          99.1MBcentos                  latest              e934aafc2206        8 days ago          199MBregistry                latest              d1fd7d86a825        3 months ago        33.3MB[root@ubuntu:/opt/data]#注意：不使用127.0.0.1:5000这个地址作为仓库地址，将无法推送镜像，因为docker默认不允许使用https的方式推送镜像</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp; 仓库是存放镜像的地方，每个服务器可以有多个仓库，而每个仓库下面有多个镜像。仓库分为公库和私库，官方的公共仓库就是docker Hub,不过国内被墙。今天就来创建一个私有仓库&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker 常用命令</title>
    <link href="http://zhuwenbing.top/2018/04/17/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://zhuwenbing.top/2018/04/17/docker常用命令/</id>
    <published>2018-04-17T14:22:11.200Z</published>
    <updated>2018-04-18T13:17:34.395Z</updated>
    
    <content type="html"><![CDATA[<p>docker用起来还是很方便的，而且命令也容易，常用的命令如下：<br>docker run<br>docker ps<br>docker inspect<br>docker attach<br>….<br><a id="more"></a></p><h2 id="docker-run运行一个容器"><a href="#docker-run运行一个容器" class="headerlink" title="docker run运行一个容器"></a>docker run运行一个容器</h2><pre><code>Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...] [flags][root@ubuntu:~]# docker run -it ubuntu /bin/bash[root@c32ec2b3f49a:/]# lsbin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var [root@c32ec2b3f49a:/]#     -i 为容器打开标准输出  -t 给打开的容器运行一个伪tty终端</code></pre><h2 id="docker-ps-列出容器"><a href="#docker-ps-列出容器" class="headerlink" title="docker ps 列出容器"></a>docker ps 列出容器</h2><pre><code>[root@ubuntu:~]# docker ps -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESc32ec2b3f49a        ubuntu              &quot;/bin/bash&quot;         2 minutes ago       Up 2 minutes                            hopeful_bose4f078216cfef        ubuntu              &quot;/bin/bash&quot;         47 hours ago        Up 47 hours                             competent_sammet41432143ef92        ubuntu              &quot;/bin/bash&quot;         47 hours ago        Up 47 hours                             hardcore_payne929860f00fa4        ubuntu              &quot;/bin/bash&quot;         47 hours ago        Up 47 hours                             competent_perlmand2170af637a4        centos              &quot;/bin/bash&quot;         47 hours ago        Up 47 hours                             epic_stallman3ac68df6d5de        ubuntu              &quot;/bin/bash&quot;         2 days ago          Up 2 days                               blissful_northcutt8b9e5cc28561        ubuntu              &quot;/bin/bash&quot;         2 days ago          Up 2 days                               cranky_stallman[root@ubuntu:~]# docker ps -lCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESc32ec2b3f49a        ubuntu              &quot;/bin/bash&quot;         2 minutes ago       Up 2 minutes                            hopeful_bose -a 列出所有的容器 -l 最新创建的容器</code></pre><h2 id="docker-inspect列出镜像信息"><a href="#docker-inspect列出镜像信息" class="headerlink" title="docker inspect列出镜像信息"></a>docker inspect列出镜像信息</h2><pre><code>Usage:  docker inspect [OPTIONS] NAME|ID [NAME|ID...] [flags][root@ubuntu:~]# docker inspect c32ec2b3f49a            hopeful_bose[{    &quot;Id&quot;: &quot;c32ec2b3f49a5774bef44f88c00c1303d760c142fc0b528ad33c61208cf97725&quot;,    &quot;Created&quot;: &quot;2018-04-15T14:01:11.956052589Z&quot;,    &quot;Path&quot;: &quot;/bin/bash&quot;,    &quot;Args&quot;: [],    &quot;State&quot;: {        &quot;Status&quot;: &quot;running&quot;,        &quot;Running&quot;: true,        &quot;Paused&quot;: false,        &quot;Restarting&quot;: false,        &quot;OOMKilled&quot;: false,        &quot;Dead&quot;: false,        &quot;Pid&quot;: 6180,        &quot;ExitCode&quot;: 0,        &quot;Error&quot;: &quot;&quot;,        &quot;StartedAt&quot;: &quot;2018-04-15T14:01:12.390885359Z&quot;,        &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;......</code></pre><h2 id="docker-attach进入后台运行的容器"><a href="#docker-attach进入后台运行的容器" class="headerlink" title="docker attach进入后台运行的容器"></a>docker attach进入后台运行的容器</h2><pre><code>Usage:  docker attach [OPTIONS] CONTAINER [flags][root@ubuntu:~]# docker run -it ubuntu /bin/bash[root@40fe9f37c774:/]#[root@40fe9f37c774:/]# root@ubuntu:~#[root@ubuntu:~]#注意：在刚创建的容器里，&quot;Ctrl+d&quot;直接退出并结束进程，使用&quot;Ctrl+P+Q&quot;(大写)退出不结束进程[root@ubuntu:~]# docker attach 40fe9f37c774[root@40fe9f37c774:/]#[root@40fe9f37c774:/]#</code></pre><h2 id="docker-exec-命令"><a href="#docker-exec-命令" class="headerlink" title="docker exec 命令"></a>docker exec 命令</h2><pre><code>Usage:  docker exec [OPTIONS] CONTAINER COMMAND [ARG...] [flags][root@ubuntu:~]# docker run -itd ubuntucd92f0ec9d4018f24ee4a06edd17f38d382dbed174bc578825d72e42219f6653[root@ubuntu:~]# docker ps -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                  PORTS               NAMEScd92f0ec9d40        ubuntu              &quot;/bin/bash&quot;              16 seconds ago      Up 16 seconds                                   upbeat_blackwell[root@ubuntu:~]# docker exec -it cd92f0ec9d40 bashroot@cd92f0ec9d40:/# lsbin   dev  home  lib64  mnt  proc  run   srv  tmp  varboot  etc  lib   media  opt  root  sbin  sys  usr[root@cd92f0ec9d40:/]# exit[root@ubuntu:~]# docker exec -it cd92f0ec9d40 bash[root@cd92f0ec9d40:/]#可以看到使用了exec命令后，exit退出容器也不会停止列出所有容器[root@ubuntu:~]# docker container ls -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS               NAMEScd92f0ec9d40        ubuntu              &quot;/bin/bash&quot;              39 minutes ago      Up 39 minu</code></pre><h2 id="docker-export导出容器快照"><a href="#docker-export导出容器快照" class="headerlink" title="docker export导出容器快照"></a>docker export导出容器快照</h2><pre><code>[root@ubuntu:~]# docker export cd92f0ec9d40 &gt;/tmp/ubuntu.tar [root@ubuntu:~]# ls /tmp/ubuntu.tar            unity_support_test.0</code></pre><h2 id="docker-import导入容器快照"><a href="#docker-import导入容器快照" class="headerlink" title="docker import导入容器快照"></a>docker import导入容器快照</h2><pre><code>[root@ubuntu:~]# cat /tmp/ubuntu.tar |docker import - test/ubuntu:v1.0sha256:0ccd5ef276a3b175b14d9b031fba85bbdf44e8d5819a62d49564333398f0e9dc[root@ubuntu:~]# docker image lsREPOSITORY          TAG                 IMAGE ID            CREATED              SIZEtest/ubuntu         v1.0                072cd43a3a6a        About a minute ago   85.8MB</code></pre><h2 id="docker-rm-删除容器"><a href="#docker-rm-删除容器" class="headerlink" title="docker rm 删除容器"></a>docker rm 删除容器</h2><pre><code>[root@ubuntu:~]# docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES1862e1300c97        ubuntu              &quot;/bin/bash&quot;         46 hours ago        Up 46 hours                             stupefied_chebyshev4f078216cfef        ubuntu              &quot;/bin/bash&quot;         46 hours ago        Up 46 hours                             competent_sammet41432143ef92        ubuntu              &quot;/bin/bash&quot;         46 hours ago        Up 46 hours                             hardcore_payne929860f00fa4        ubuntu              &quot;/bin/bash&quot;         47 hours ago        Up 47 hours                             competent_perlmand2170af637a4        centos              &quot;/bin/bash&quot;         47 hours ago        Up 47 hours                             epic_stallman3ac68df6d5de        ubuntu              &quot;/bin/bash&quot;         47 hours ago        Up 47 hours                             blissful_northcutt8b9e5cc28561        ubuntu              &quot;/bin/bash&quot;         47 hours ago        Up 47 hours                             cranky_stallman[root@ubuntu:~]# docker container rm 1862e1300c97 Error response from daemon: You cannot remove a running container cd92f0ec9d4018f24ee4a06edd17f38d382dbed174bc578825d72e42219f6653.Stop the container before attempting removal or force remove注意：因为当前容器是正在运行的，所以直接停止会报错，加上参数-f，docker会发送sigkill信号给容器[root@ubuntu:~]# docker container rm -f 1862e1300c971862e1300c97[root@ubuntu:~]# docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES4f078216cfef        ubuntu              &quot;/bin/bash&quot;         46 hours ago        Up 46 hours                             competent_sammet41432143ef92        ubuntu              &quot;/bin/bash&quot;         46 hours ago        Up 46 hours                             hardcore_payne929860f00fa4        ubuntu              &quot;/bin/bash&quot;         47 hours ago        Up 47 hours                             competent_perlmand2170af637a4        centos              &quot;/bin/bash&quot;         47 hours ago        Up 47 hours                             epic_stallman3ac68df6d5de        ubuntu              &quot;/bin/bash&quot;         47 hours ago        Up 47 hours                             blissful_northcutt8b9e5cc28561        ubuntu              &quot;/bin/bash&quot;         47 hours ago        Up 47 hours                             cranky_stallman[root@ubuntu:~]#</code></pre><h2 id="prune清除所有处于终止状态的容器"><a href="#prune清除所有处于终止状态的容器" class="headerlink" title="prune清除所有处于终止状态的容器"></a>prune清除所有处于终止状态的容器</h2><pre><code>[root@ubuntu:~]# docker container ls -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS               NAMEScd92f0ec9d40        ubuntu              &quot;/bin/bash&quot;              46 hours ago        Exited (0) 6 minutes ago                       upbeat_blackwell4f078216cfef        ubuntu              &quot;/bin/bash&quot;              46 hours ago        Up 46 hours                                    competent_sammet51783f7ff529        ubuntu              &quot;/bin/bash&quot;              46 hours ago        Exited (0) 46 hours ago                        competent_chebyshev41432143ef92        ubuntu              &quot;/bin/bash&quot;              47 hours ago        Up 47 hours                                    hardcore_payne4e80f171f0dd        ubuntu              &quot;/bin/bash&quot;              47 hours ago        Exited (0) 47 hours ago                        xenodochial_dijkstrae34b31703aac        ubuntu:17.10        &quot;/bin/sh -c &apos;whilr t…&quot;   47 hours ago        Exited (0) 47 hours ago                        reverent_bhaskara929860f00fa4        ubuntu              &quot;/bin/bash&quot;              47 hours ago        Up 47 hours                                    competent_perlmanaf27e78a0078        ubuntu              &quot;/bin/bash&quot;              47 hours ago        Exited (0) 47 hours ago                        goofy_hamiltond4306e006205        ubuntu              &quot;/bin/echo &apos; hello w…&quot;   47 hours ago        Exited (0) 47 hours ago                        relaxed_albattani6134f0d591a5        ubuntu              &quot;/bin/hello world&quot;       47 hours ago        Created                                        determined_heisenbergd2170af637a4        centos              &quot;/bin/bash&quot;              47 hours ago        Up 47 hours                                    epic_stallman3ac68df6d5de        ubuntu              &quot;/bin/bash&quot;              47 hours ago        Up 47 hours                                    blissful_northcutt8b9e5cc28561        ubuntu              &quot;/bin/bash&quot;              47 hours ago        Up 47 hours                                    cranky_stallman[root@ubuntu:~]# docker container pruneWARNING! This will remove all stopped containers.Are you sure you want to continue? [y/N] yDeleted Containers:cd92f0ec9d4018f24ee4a06edd17f38d382dbed174bc578825d72e42219f665351783f7ff529e82fa852921bfe1f567f97345e9fb2934808803954e24a24a1e94e80f171f0ddaebde20a79e643585e8ace4e515804b423b6da04a67bf49c346ae34b31703aaca5931468cee0df8763d4dc78df36bb7ed5ba0e0c09729f8ec825af27e78a00784aea88258f4d528f35c1cd616f68a76d3dbf222104061f533ba5d4306e006205fb89b3ca64b5efe4e73591bfce0b283c208733cf1e8f5ca6fe586134f0d591a50ae081db0c91d6d8fc1efda0c9588424fa6890daa01a84e115b0Total reclaimed space: 8B可以看到终止的容器已经被清理掉了[root@ubuntu:~]# docker container ls -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES4f078216cfef        ubuntu              &quot;/bin/bash&quot;         46 hours ago        Up 46 hours                             competent_sammet41432143ef92        ubuntu              &quot;/bin/bash&quot;         47 hours ago        Up 47 hours                             hardcore_payne929860f00fa4        ubuntu              &quot;/bin/bash&quot;         47 hours ago        Up 47 hours                             competent_perlmand2170af637a4        centos              &quot;/bin/bash&quot;         47 hours ago        Up 47 hours                             epic_stallman3ac68df6d5de        ubuntu              &quot;/bin/bash&quot;         47 hours ago        Up 47 hours                             blissful_northcutt8b9e5cc28561        ubuntu              &quot;/bin/bash&quot;         47 hours ago        Up 47 hours                             cranky_stallman[root@ubuntu:~]#</code></pre><h2 id="docker-stop停止一个容器"><a href="#docker-stop停止一个容器" class="headerlink" title="docker stop停止一个容器"></a>docker stop停止一个容器</h2><pre><code>[root@ubuntu:~]# docker run -it ubuntu /bin/bash[root@2a1de0464580:/]#[root@ubuntu:~]# docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES2a1de0464580        ubuntu              &quot;/bin/bash&quot;         41 seconds ago      Up 40 seconds                           romantic_bhaskara[root@ubuntu:~]# docker stop 2a1de04645802a1de0464580</code></pre><h2 id="docker-search拉取镜像"><a href="#docker-search拉取镜像" class="headerlink" title="docker search拉取镜像"></a>docker search拉取镜像</h2><pre><code>[root@ubuntu:~]# docker search centosNAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATEDcentos                             The official build of CentOS.                   4188                [OK]ansible/centos7-ansible            Ansible on Centos7                              108                                     [OK]jdeathe/centos-ssh                 CentOS-6 6.9 x86_64 / CentOS-7 7.4.1708 x86_…   94                                      [OK]consol/centos-xfce-vnc             Centos container with &quot;headless&quot; VNC session…   52                                      [OK]imagine10255/centos6-lnmp-php56    centos6-lnmp-php56                              40                                      [OK]tutum/centos                       Simple CentOS docker image with SSH access      38gluster/gluster-centos             Official GlusterFS Image [ CentOS-7 +  Glust…   26                                      [OK]centos/mysql-57-centos7            MySQL 5.7 SQL database server                   23openshift/base-centos7             A Centos7 derived base image for Source-To-I…   22kinogmt/centos-ssh                 CentOS with SSH                                 19                                      [OK]centos/python-35-centos7           Platform for building and running Python 3.5…   19centos/postgresql-96-centos7       PostgreSQL is an advanced Object-Relational …   12openshift/jenkins-2-centos7        A Centos7 based Jenkins v2.x image for use w…   11centos/httpd-24-centos7            Platform for running Apache httpd 2.4 or bui…   10openshift/mysql-55-centos7         DEPRECATED: A Centos7 based MySQL v5.5 image…   6openshift/wildfly-101-centos7      A Centos7 based WildFly v10.1 image for use …   3openshift/jenkins-1-centos7        DEPRECATED: A Centos7 based Jenkins v1.x ima…   3pivotaldata/centos-gpdb-dev        CentOS image for GPDB development. Tag names…   3pivotaldata/centos                 Base centos, freshened up a little with a Do…   1pivotaldata/centos-mingw           Using the mingw toolchain to cross-compile t…   1blacklabelops/centos               CentOS Base Image! Built and Updates Daily!     1                                       [OK]openshift/php-55-centos7           DEPRECATED: A Centos7 based PHP v5.5 image f…   1pivotaldata/centos-gcc-toolchain   CentOS with a toolchain, but unaffiliated wi…   0smartentry/centos                  centos with smartentry                          0                                       [OK]jameseckersall/sonarr-centos       Sonarr on CentOS 7                              0                                       [OK]root@ubuntu:~#可以看到拉取的镜像返回了很多内容，包括：镜像名称，描述，收藏数，是否是官方创建，是否为自动创建列出所有镜像Usage:    docker images [OPTIONS] [REPOSITORY[:TAG]][root@ubuntu:~]# docker images -aREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEtest/ubuntu         v1.0                072cd43a3a6a        About an hour ago   85.8MB&lt;none&gt;              &lt;none&gt;              0ccd5ef276a3        46 hours ago        85.8MBubuntu              latest              c9d990395902        2 days ago          113MBubuntu              17.10               14107f6d2c97        2 days ago          99.1MBcentos              latest              e934aafc2206        8 days ago          199MB[root@ubuntu:~]# -a 显示所有镜像 -q 显示镜像ID</code></pre><h2 id="docker-pull下载镜像到本地"><a href="#docker-pull下载镜像到本地" class="headerlink" title="docker pull下载镜像到本地"></a>docker pull下载镜像到本地</h2><pre><code>[root@ubuntu:~]# docker pull centosUsing default tag: latestlatest: Pulling from library/centosDigest: sha256:989b936d56b1ace20ddf855a301741e52abca38286382cba7f44443210e96d16Status: Image is up to date for centos:latestroot@ubuntu:~#</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker用起来还是很方便的，而且命令也容易，常用的命令如下：&lt;br&gt;docker run&lt;br&gt;docker ps&lt;br&gt;docker inspect&lt;br&gt;docker attach&lt;br&gt;….&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://zhuwenbing.top/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>初识Docker 一</title>
    <link href="http://zhuwenbing.top/2018/04/02/%E5%88%9D%E8%AF%86Docker1/"/>
    <id>http://zhuwenbing.top/2018/04/02/初识Docker1/</id>
    <published>2018-04-02T09:51:06.840Z</published>
    <updated>2018-04-02T11:20:10.242Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/c8nnEdw.jpg" alt=""></p><p>&emsp;&emsp;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。Docker分为CE和EE。CE即社区版，免费开源。EE即企业版，安全性更高，需要付费使用。<a id="more"></a></p><h2 id="Docker-三个基本概念"><a href="#Docker-三个基本概念" class="headerlink" title="Docker 三个基本概念"></a><strong>Docker 三个基本概念</strong></h2><p>·镜像（Images）<br>·容器（Container）<br>·仓库（Registry）</p><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a><strong>Docker镜像</strong></h2><p>&emsp;&emsp;就是一个层叠的只读文件系统，底端是一个引导文件系统，当容器启动之后引导文件系统就会被卸载，上一层是只读的root文件系统，或者更上一层还有其他文件系统，Docker“联合加载”会将这种叠加在一起的文件系统整合在一起，而这种整合在一起的文件系统，就是Docker镜像。它主要提供一些容器运行时需要的程序，库，资源，配置(环境变量，用户)。镜像不会包含任何动态内容，内容结构也不会被改变。</p><h2 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a><strong>Docker容器</strong></h2><p>&emsp;&emsp;容器就实质是一个进程，当启动一个容器时，Docker会在镜像最顶层加载一个“读写层”，容器就是在这个读写层执行的。Docker第一次启动时，这个“读写层”是空白的，当修改一个文件时，Docker会从文件系统底层的“只读层”复制到“读写层”，该文件只读版本依然存在但是被“读写层”改文件的副本所隐藏，这就是Docker的“写时复制”。</p><h2 id="镜像和容器的关系"><a href="#镜像和容器的关系" class="headerlink" title="镜像和容器的关系"></a><strong>镜像和容器的关系</strong></h2><p>&emsp;&emsp;镜像是静止的定义，容器是镜像运行时的实体，容器可以被创建，启动，停止和删除等。（这个地方花了很长时间才区分开镜像和容器的本质区别）</p><h2 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a><strong>Docker仓库</strong></h2><p>&emsp;&emsp;当镜像构建完成后，如果要拿到其他服务器上使用时，就需要一个集中管理，分发镜像的服务，这就是Docker仓库(分为共有和私有)。</p><p>如果还是不清楚，可以参考这个：<a href="http://dockone.io/article/783" target="_blank" rel="external">http://dockone.io/article/783</a></p><h2 id="Docker依赖Linux内核特性"><a href="#Docker依赖Linux内核特性" class="headerlink" title="Docker依赖Linux内核特性"></a><strong>Docker依赖Linux内核特性</strong></h2><pre><code>Docker依赖Linux内核2大特性：        ·NameSpace        ·CgroupsNameSpace: 将特定的全局系统资源(网络，文件系统，进程等)，通过抽象的方法使NameSpace进程实现资源隔离Cgroups: 用于资源限定，设置优先级和资源计量和资源控制</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/c8nnEdw.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。Docker分为CE和EE。CE即社区版，免费开源。EE即企业版，安全性更高，需要付费使用。
    
    </summary>
    
      <category term="Docker" scheme="http://zhuwenbing.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://zhuwenbing.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>初识Docker 二</title>
    <link href="http://zhuwenbing.top/2018/04/02/%E5%88%9D%E8%AF%86docker%202/"/>
    <id>http://zhuwenbing.top/2018/04/02/初识docker 2/</id>
    <published>2018-04-02T07:54:44.637Z</published>
    <updated>2018-05-02T06:44:52.755Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/BKmp13Y.jpg" alt=""></p><p><strong>Docker的安装</strong><br><a id="more"></a></p><p>&emsp;&emsp; 说明：我用的是Ubuntu(16.04）,洛杉矶VPS，所以没配置镜像加速(国内主机的话还是配置一下)</p><h2 id="查看自己的系统版本"><a href="#查看自己的系统版本" class="headerlink" title="查看自己的系统版本"></a><strong>查看自己的系统版本</strong></h2><pre><code>[zane4649@instance-2:~]$ cat /proc/versionLinux version 4.13.0-1011-gcp (buildd@lgw01-amd64-006) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.9)) #15-Ubuntu SMP Mon Feb 12 16:29:04 UTC 2018</code></pre><h2 id="卸载之前旧版本的Docker"><a href="#卸载之前旧版本的Docker" class="headerlink" title="卸载之前旧版本的Docker"></a><strong>卸载之前旧版本的Docker</strong></h2><pre><code>[zane4649@instance-2:~]$ sudo apt-get remove docker docker-engine docker.io</code></pre><h2 id="安装apt源依赖"><a href="#安装apt源依赖" class="headerlink" title="安装apt源依赖"></a><strong>安装apt源依赖</strong></h2><pre><code>因为要确保apt源使用https下载过程不被更改，因此要添加https传输的软件包和ca证书[zane4649@instance-2:~]$ sudo apt-get update[zane4649@instance-2:~]$ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common</code></pre><h2 id="添加Docker的官方GPG密钥"><a href="#添加Docker的官方GPG密钥" class="headerlink" title="添加Docker的官方GPG密钥"></a><strong>添加Docker的官方GPG密钥</strong></h2><pre><code>[zane4649@instance-2:~]$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></pre><h2 id="添加docker软件源"><a href="#添加docker软件源" class="headerlink" title="添加docker软件源"></a><strong>添加docker软件源</strong></h2><pre><code>[zane4649@instance-2:~]$ sudo add-apt-repository \                       &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \                       $(lsb_release -cs) \                       stable&quot;</code></pre><h2 id="更新Docker软件包索引"><a href="#更新Docker软件包索引" class="headerlink" title="更新Docker软件包索引"></a><strong>更新Docker软件包索引</strong></h2><pre><code>[zane4649@instance-2:~]$ sudo apt-get update</code></pre><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a><strong>安装Docker</strong></h2><pre><code>[zane4649@instance-2:~]$ sudo apt-get -y install docker-ce</code></pre><h2 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a><strong>启动Docker</strong></h2><pre><code>[zane4649@instance-2:~]$ sudo systemctl enable docker[zane4649@instance-2:~]$ sudo systemctl start docker</code></pre><h2 id="创建docker用户组"><a href="#创建docker用户组" class="headerlink" title="创建docker用户组"></a><strong>创建docker用户组</strong></h2><pre><code>默认情况，docker命令会使用Unix socket与docker建立通讯，而只有root和docker组的用户才可以访问docker引擎的Unix socket。因此要创建docker用户并加入docker组，因为root权限过大[zane4649@instance-2:~]$ sudo useradd -g docker docker[zane4649@instance-2:~]$ id dockeruid=1003(docker) gid=117(docker) groups=117(docker)[zane4649@instance-2:~]$</code></pre><h2 id="测试是否正确安装"><a href="#测试是否正确安装" class="headerlink" title="测试是否正确安装"></a><strong>测试是否正确安装</strong></h2><pre><code>[zane4649@instance-2:~]$ sudo docker run hello-world有以下反馈表示安装成功Hello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.(amd64) 3. The Docker daemon created a new container from that image which runs theexecutable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent itto your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://cloud.docker.com/For more examples and ideas, visit: https://docs.docker.com/engine/userguide/</code></pre><h2 id="运行一个容器"><a href="#运行一个容器" class="headerlink" title="运行一个容器"></a><strong>运行一个容器</strong></h2><pre><code>[zane4649@instance-2:~]$ sudo docker run -it ubuntu /bin/bashUnable to find image &apos;ubuntu:latest&apos; locallylatest: Pulling from library/ubuntu22dc81ace0ea: Pulling fs layer22dc81ace0ea: Pull complete1a8b3c87dba3: Pull complete91390a1c435a: Pull complete07844b14977e: Pull completeb78396653dae: Pull completeDigest: sha256:e348fbbea0e0a0e73ab0370de151e7800684445c509d46195aef73e090a49bd6Status: Downloaded newer image for ubuntu:latest[root@1d8f8e8f3afb:/]#  现在就已经在创建的容器里了[root@1d8f8e8f3afb:/]#[root@1d8f8e8f3afb:/#] zane4649@instance-2:~$ 退出容器[zane4649@instance-2:~]$[zane4649@instance-2:~]$ sudo docker ps -a 列出运行的容器CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                   PORTS               NAMES1d8f8e8f3afb        ubuntu              &quot;/bin/bash&quot;         2 minutes ago       Up 2 minutes                   jovial_cray86506e3fa3eb        hello-world         &quot;/hello&quot;            3 hours ago         Exited (0) 3 hours ago                   objective_franklinc86c09d8da04        hello-world         &quot;/hello&quot;            3 hours ago         Exited (0) 3 hours ago                   sleepy_wozniak[zane4649@instance-2:~]$</code></pre><h2 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a><strong>配置镜像加速器</strong></h2><pre><code>因为国内从Docker Hub 上拉镜像很慢，所以一般都会用国内的加速来提高速度!可选的加速器有：            Docker官方提供中国 reqistry mirror            阿里云加速器            DaoCloud加速器</code></pre><p>&emsp;&emsp;这里就演示一下阿里云加速器了，先去注册阿里云账户，然后会得到一个专属的加速器地址，根据提示修改即可!<br><img src="https://i.imgur.com/tgEMC2j.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/BKmp13Y.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker的安装&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://zhuwenbing.top/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Next主题 Pisces Scheme更改内容区域的宽度</title>
    <link href="http://zhuwenbing.top/2018/03/30/next%E4%BF%AE%E6%94%B9%E6%98%BE%E7%A4%BA%E5%AE%BD%E5%BA%A6/"/>
    <id>http://zhuwenbing.top/2018/03/30/next修改显示宽度/</id>
    <published>2018-03-30T11:31:17.127Z</published>
    <updated>2018-04-03T03:03:44.228Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5cOKOIE.png" alt=""></p><p><center><strong>Next 主题修改内容显示区域宽度</strong></center><br><a id="more"></a></p><p>&emsp;&emsp; 之前也修改过Pisces Scheme的宽度，但是移动端老显示不正常，最近看官方文档的时候，发现有个老哥给出了以下配置，抱着尝试的心态去改了一下，打开PC端确实内容显示区域加宽了不少，然后怀着忐忑的心理手机上打开了我的博客，Oh My God!!! 幸福来的这么突然吗！ 竟然显示正常！下面把方法分享一下(参数在图片下面)</p><p>移动端效果如图：<br><img src="https://i.imgur.com/mTdPoeX.png" alt=""></p><pre><code>正确的姿势如下：修改配置文件：\themes\next\source\css\_schemes\Pisces\layout.styl.header {      width: 80%;    }.container .main-inner {      width: 80%;    }.content-wrap {      width: calc(100% - 260px);    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5cOKOIE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;strong&gt;Next 主题修改内容显示区域宽度&lt;/strong&gt;&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://zhuwenbing.top/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>Centos7 编译安装MariaDB-10.1.22</title>
    <link href="http://zhuwenbing.top/2018/03/27/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85mysql/"/>
    <id>http://zhuwenbing.top/2018/03/27/编译安装mysql/</id>
    <published>2018-03-27T05:22:38.602Z</published>
    <updated>2017-09-27T06:25:44.876Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i.imgur.com/GKr7XTn.jpg" alt=""></p><p><strong>目的</strong>：使用源码包编译安装Mariadb <a id="more"></a></p><h2 id="卸载安装的mariadb"><a href="#卸载安装的mariadb" class="headerlink" title="卸载安装的mariadb"></a>卸载安装的mariadb</h2><pre><code>[root@localhost /]# rpm -qa | grep mariadbmariadb-libs-5.5.44-2.el7.centos.x86_64[root@localhost /]# rpm -e mariadb-libs-5.5.44-2.el7.centos.x86_64</code></pre><h2 id="创建用户和组"><a href="#创建用户和组" class="headerlink" title="创建用户和组"></a>创建用户和组</h2><pre><code>[root@localhost /]# groupadd  mysql[root@localhost /]# useradd -g mysql mysql</code></pre><h2 id="创建文件目录"><a href="#创建文件目录" class="headerlink" title="创建文件目录"></a>创建文件目录</h2><pre><code>[root@localhost /]# mkdir /mydata/data -pv[root@localhost /]# chown mysql.mysql data</code></pre><h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><pre><code>[root@localhost /]# yum groupinstall -y Development Tools #环境开发工具包[root@localhost /]# yum -y install gcc gcc-c++ make cmake ncurses ncurses-devel man ncurses libxml2 libxml2-devel openssl-devel bison bison-devel# cmake：由于从MySQL5.5版本开始弃用了常规的configure编译方法，所以需要cmake编译器，用于设置mysql的编译参数。（如：安装目录，数据存放目录，字符编码，排序规则等）# boost：从MySQL5.7.5开始Boost库是必需的，mysql源码中用到了C++的Boost库，要求必需安装Boost1.59.0或以上版本。# GCC：这是Linux下的C语言编译工具，MySQL源码编译完全由C和C++编写，要求必需安装GCC。# bison：Linux下C/C++语法分析器# ncurses：字符终端处理库。.........</code></pre><h2 id="编译准备"><a href="#编译准备" class="headerlink" title="编译准备"></a>编译准备</h2><pre><code>[root@localhost /]# tar -xvf mariadb-10.1.22.tar.gz -C /usr/local[root@localhost /]# cd /usr/local/[root@localhost /]# ln -sv mariadb-10.1.22 mysql #做软链接[root@localhost /]# chown -R root:mysql ./* #修改配置文件的属组</code></pre><h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><pre><code>[root@localhost mysql]#  cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql #Mysql安装的根目录             -DMYSQL_DATADIR=/mydata/data            #Mysql数据库文件存放路径             -DWITH_INNOBASE_STORAGbE_ENGINE=1       #添加InoooDB引擎              -DWITH_ARCHIVE_STORAGE_ENGINE=1         #添加ARCHIVE引擎             -DWITH_BLACKHOLE_STORAGE_ENGINE=1       #添加BLACKHOLE引擎             -DWITH_SSL=system -DWITH_ZLIB=system    #可以用systemd控制服务             -DWITH_LIBWRAP=0              #             -DMYSQL_UNIX_ADDR=/tmp/mysql.sock       #指定sock文件的位置             -DEFAULT_CHARSET=utf8 #Mysql默认字符集为utf-8               -DDEFAULT_COLLATION=utf8_general_ci     #支持默认字符集校对规则[root@localhost mysql]# make &amp;&amp; make install #编译并安装 </code></pre><h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><pre><code>四个数据库，information_schema ，performance_schema，test ，mysql源数据库（用户，权限，字段，字段名。。。。）, 自行脚本生成，脚本在mysql/scripts 执行一下就可以安装了[root@localhost mysql]# scripts/mysql_install_db --user=mysql --datadir=/mysql/data[root@localhost mysql]# scripts/mysql_install_db --help [root@localhost mysql]# ls /mydata/data/aria_log.00000001  ib_logfile0                multi-master.info  mysql-bin.indexaria_log_control   ib_logfile1                mysql              performance_schemaibdata1            localhost.localdomain.pid  mysql-bin.000001   test</code></pre><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><pre><code>[root@localhost mysql]# mkdir /etc/mysql[root@localhost mysql]# cp support-files/my-large.cnf /etc/mysql/my.cnf[root@localhost mysql]# vim /etc/mysql/my.cnf datadir = /mydata/data      #数据文件的路径innodb_file_per_table = on  #修改InnoDB为独立表空间模式skip_name_resolve = on      #跳过名称反解，将客户端连接IP反解成主机名，然后做权限检查</code></pre><h2 id="创建服务脚本"><a href="#创建服务脚本" class="headerlink" title="创建服务脚本"></a>创建服务脚本</h2><pre><code>[root@localhost mysql]# cp support-files/mysql.server /etc/rc.d/init.d/mysqld [root@localhost mysql]# chkconfig --add mysqld #设置开机启动[root@localhost mysql]# chkconfig --list mysqld [root@localhost mysql]# service mysqld start[root@localhost mysql]# ss -tnlp #查看3306是否被mysql监听LISTEN      0      80                     :::3306                               :::*   users:((&quot;mysqld&quot;,pid=5358,fd=21))</code></pre><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><pre><code>[root@localhost mysql]# vim /etc/profile.d/mysqld.shMYSQL_HOME=/usr/local/mysqlexport PATH=$MYSQL_HOME/bin:$PATH[root@localhost mysql]#  source /etc/profile.d/mysqld.sh #加载环境变量</code></pre><h2 id="连接Mysql"><a href="#连接Mysql" class="headerlink" title="连接Mysql"></a>连接Mysql</h2><pre><code>[root@localhost mysql]# mysqlWelcome to the MariaDB monitor.  Commands end with ; or \g.Your MariaDB connection id is 4Server version: 10.1.22-MariaDB Source distributionCopyright (c) 2000, 2016, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; </code></pre><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><pre><code>启动时报错：/usr/local/mysql//libexec/mysqld: Can&apos;t create/write to file &apos;/var/log/mariadb&apos; (Errcode: 13) 120516 15:23:19 [ERROR] Can&apos;t start server: can&apos;t create PID file: Permission denied  解决方法：chown mysql.mysql /var/log/mariadb/ -R</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i.imgur.com/GKr7XTn.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;：使用源码包编译安装Mariadb
    
    </summary>
    
      <category term="Mysql" scheme="http://zhuwenbing.top/categories/Mysql/"/>
    
    
      <category term="编译安装Mariadb-10.1" scheme="http://zhuwenbing.top/tags/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Mariadb-10-1/"/>
    
  </entry>
  
  <entry>
    <title>windows下安装RabbitMQ</title>
    <link href="http://zhuwenbing.top/2018/03/27/windows%E5%AE%89%E8%A3%85rabbitmq/"/>
    <id>http://zhuwenbing.top/2018/03/27/windows安装rabbitmq/</id>
    <published>2018-03-27T05:22:38.602Z</published>
    <updated>2017-10-09T03:37:48.231Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习Python第11天的课程，讲消息队列，当然说的就是RabbitMQ，于是就想起，写篇博客记录一下安装过程！<br><img src="https://i.imgur.com/RaoQK9b.png" alt=""></p><a id="more"></a><p><strong> 版本说明 </strong><br>    OS: win10_1703<br>    Erlang: 20.1<br>    RabbitMQ: 3.6.12</p><p><strong> 安装erlang </strong></p><pre><code>RabbitMQ是建立Erlang平台上，所以先要装上erlang我这里安装的版本是：otp_win64_20.1（各人按自己系统版本下载）官方下载地址：http://www.erlang.org/downloads</code></pre><p><strong>添加环境变量</strong><br><img src="https://i.imgur.com/1kYBja7.png" alt=""></p><p><strong>安装RabbitMQ</strong></p><pre><code>我这里下载的版本是：rabbitmq-server-3.6.12官方下载地址：http://www.rabbitmq.com/download.html</code></pre><p><strong>配置RabbitMQ</strong></p><pre><code>激活rabbitmq-plugins(C:\Program Files\RabbitMQ Server\rabbitmq_server-3.6.12\sbin\rabbitmq-plugins.bat)命令：rabbitmq-plugins enable rabbitmq_management需要重启服务才能生效</code></pre><p><img src="https://i.imgur.com/bcV9bg6.png" alt=""></p><p><strong>访问控制台</strong><br>     上面步骤都配置好后，浏览器地址栏输入：<a href="http://localhost:15672(" target="_blank" rel="external">http://localhost:15672(</a> 默认用户和密码都是guest)</p><p> <img src="https://i.imgur.com/4BWu5BR.png" alt=""></p><p>最后：简单的配置到这里就结束了，后续有其他的要求到时候再更新博客</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天学习Python第11天的课程，讲消息队列，当然说的就是RabbitMQ，于是就想起，写篇博客记录一下安装过程！&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/RaoQK9b.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://zhuwenbing.top/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://zhuwenbing.top/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Python学习之第五天</title>
    <link href="http://zhuwenbing.top/2018/03/27/python%E7%AC%AC%E4%BA%94%E5%A4%A9/"/>
    <id>http://zhuwenbing.top/2018/03/27/python第五天/</id>
    <published>2018-03-27T05:22:38.570Z</published>
    <updated>2017-09-27T10:42:25.726Z</updated>
    
    <content type="html"><![CDATA[<p>最近这段时间，利用业余时间学习了一下Python,写篇博客算是记录一下相关的知识点，方便以后查询，也算做个小总结！</p><p><img src="https://i.imgur.com/RYTHJeH.jpg" alt=""><br><a id="more"></a><br><strong>第五天学习主要类容：模块定义，导入，正则表达式等</strong></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h2><pre><code>模块：用来从逻辑上组织python代码（变量，函数，类，）本质就是.py结尾的python文件（文件名：test.py,对应的模块名：test）包：用来从逻辑上组织模块的，本质就是一个目录（必须要有一个__init__.py文件）</code></pre><h2 id="导入方法"><a href="#导入方法" class="headerlink" title="导入方法"></a><strong>导入方法</strong></h2><pre><code>import module_nameimport module1_name,module2_name#import module1_name 相当于把整个模块的代码复制给当前一个变量，然后调用from module_zane frome * #导入module_zane模块的所有，一般不建议这么用 from module_zane import m1,m2 #导入module_zane模块的方法from module_zane import name as new_name #从module_zane模块下导入一个模块（赋给另一个变量）#from 相当于只打开了module_name的一个方法</code></pre><h2 id="import本质"><a href="#import本质" class="headerlink" title="import本质"></a><strong>import本质</strong></h2><pre><code>导入&quot;模块&quot;的本质就是把python文件解释一遍导入&quot;包&quot;的本质就是执行该包下的__init__.py文件）import sys,osprint(sys.path)#print(os.path.abspath(__file__)) #abspath：获取当前文件的绝对路径#此时的路径E:/pycharm/s14/day5/module_test/main.py&quot;x = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))#os.path.dirname:获取路径名，这里因为module_test文件在day5路径下，所以要上找两层sys.path.append(x)  #把获取的路径sys.pathimport module_test</code></pre><h2 id="time和datetime模块"><a href="#time和datetime模块" class="headerlink" title="time和datetime模块"></a><strong>time和datetime模块</strong></h2><pre><code>import time     #导入time模块time.time()          #获取时间戳time.timezone()    #获取时区，中国在东8区time.altzone()    #夏令时和UTC(标准时)的差值time.daylight()    #是否使用了夏令时time.sleep()    #沉睡几秒time.gmtime()    #把时间戳转换成元祖，结果是UTC时区time.localtime()#把时间戳转换成元祖，结果是本地时区time.mktime()   #将元祖转换成时间戳time.strftime() #将元祖转换成字符串格式显示（例：time.strftime(&quot;%Y-%m:%d %H:%M:%S&quot;,x)）time.strptime() #将字符串转换成元祖形式（time.strptime(&apos;2017-09:06 22:19:00&apos;,&quot;%Y-%m:%d %H:%M:%S&quot;））time.astime()   #将元祖转换成字符转形式time.ctime()    #将时间戳转换成字符串形式时间加减：import datatimeprint(datetime.datetime.now()) #返回当前时间print(datetime.datetime.now() + datetime.timedelta(3)) #当前时间+3天print(datetime.datetime.now() + datetime.timedelta(-3)) #当前时间-3天print(datetime.datetime.now() + datetime.timedelta(hours=3)) #当前时间+3小时print(datetime.datetime.now() + datetime.timedelta(hours+30)) #当前时间+30分钟c_time = datetime.datetime.now() #当前时间：2017-09-06 22:53:53.191920print(c_time.replace(minute=3,hour=2)) #时间替换为：2017-09-06 02:03:53.191920</code></pre><h2 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a><strong>random模块</strong></h2><pre><code>import randomrandom.random() #0到1之间的随机数random.randit(1,3) #生成一个指定范围的整数 random.shuffle() #洗牌（例如：i=[1,2,3,4] random.shuffle(i) 输入为：[2,1,4,3）random.choice(&apos;afsdsgfd&apos;) #随机字符random.sample(&apos;afgagradf&apos;,3) #选取特定数量的字符练习：生成4位随机数import randomcheckcode=&apos;&apos;for i in range(4):    current=random.randint(1,9)        if current ==i:                tmp = chr(random.randint(65,90))           else:    tmp = random.randint(0,9)checkcode+=str(tmp)\print(checkcode)</code></pre><h2 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a><strong>os模块</strong></h2><pre><code>&quot;os&quot;模块是提供对操作系统进行调用的接口import osos.getcwd() #获取当前工作目录os.chdir(r&quot;C:\User&quot;) #切换目录os.curdir  #返回当前目录os.pardir  #获取当前目录的父目录os.makedirs(r&quot;C:\a\b\c&quot;) #递归创建目录os.removedirs(r&quot;C:\a\b\c&quot;) #递归删除目录（如果目录为空则删除上级目录）os.mkdir() #创建单级目录os.rmdir() #删除单级目录os.listdir(r&apos;D:&apos;) #列出D盘下所有文件夹os.remove() #删除一个文件os.rename(&quot;oldname&quot;,&quot;newname&quot;) #修改文件名os.stat(path/filename) #获取文件/目录信息os.sep #输出系统路径分隔符os.environ #输出当前系统的环境变量os.pathsep #输出用于分割文件路径的字符串os.system(dir,ipconfig) #执行系统命令os.path.abspath() #获取文件的绝对路径os.path.split() #将path分割成目录，文件名os.path.dirname(r&apos;C:\a\b\test.txt&apos;) #只获取路径（输出结果为：&apos;C:\\a\\b&apos;）os.path.basename(r&apos;C:\a\b\test.txt&apos;) #只获取文件名(输出结果为：‘test.txt’)os.path.exists(r&apos;D:\a&apos;) #判断路径是否存在（存在返回True,不存在返回False）os.path.file(path)  #判断是否为文件os.path.dir(path)  #判断是否为目录os.path.getatime(path) #获取文件或目录最后的存取时间(返回时间戳)os.path.getmtime(path) #获取文件或路径最后的修改时间(返回时间戳)</code></pre><h2 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a><strong>sys模块</strong></h2><pre><code>import syssys.argv #命令行参数List，第一个元素是程序本身路径sys.exit(n) #程序退出，正常返回&apos;0&apos;,其他返回&apos;1-254&apos;sys.version #获取Python版本信息sys.path    #返回模块搜索路径sys.platform #获取操作系统平台信息</code></pre><h2 id="shutil模块"><a href="#shutil模块" class="headerlink" title="shutil模块"></a><strong>shutil模块</strong></h2><pre><code>高级的文件，文件夹，压缩包处理模块shutil.copyfile(&quot;file_name1&quot;,&quot;file_name2&quot;) #复制文件shutil.copytree(&quot;source&quot;,&quot;new_name&quot;) #递归复制文件目录shutil.rmtree(&quot;file_name&quot;) #递归删除文件shutil.make_archive(&quot;压缩文件名&quot;，“type”,&quot;path&quot;) #压缩文件 (例：shutil.make_archive(&quot;shutil_test&quot;,&quot;gzip&quot;,&quot;D:\test.py&quot;))json &amp; picklejson 把python内存中的数据类型转换成字符串（dumps）,调用（loads）pickle 把python特有的类型和python的数据类型进行转换</code></pre><h2 id="json序列化"><a href="#json序列化" class="headerlink" title="json序列化"></a><strong>json序列化</strong></h2><pre><code>序列化就是把python对象编码转换成json格式的字符串import jsoninfo = {    &apos;name&apos;:&apos;zane&apos;,    &apos;age&apos;:22}f = open(&quot;test.txt&quot;,&apos;w&apos;)#print(json.dumps(info))f.write(json.dumps(info)) #dump序列化f.close()</code></pre><h2 id="json反序列化"><a href="#json反序列化" class="headerlink" title="json反序列化"></a><strong>json反序列化</strong></h2><pre><code>反序列化就是把json字符串解码转换成python数据对象import jsonf = open(&quot;test.txt&quot;,&apos;r&apos;)data = json.loads(f.read()) #反序列化loadsprint(data[&quot;age&quot;])f.close()</code></pre><h2 id="configparser模块"><a href="#configparser模块" class="headerlink" title="configparser模块"></a><strong>configparser模块</strong></h2><pre><code>用于生成和修改常见配置文档详情：http://www.cnblogs.com/alex3714/articles/5161349.html</code></pre><h2 id="hashlib模块"><a href="#hashlib模块" class="headerlink" title="hashlib模块"></a><strong>hashlib模块</strong></h2><pre><code>一般用于加密,python3.0里代替了md5模块和sha模块，主要提供了MD5,SHA1,SHA256,SHA512等算法import hashlib# f = hashlib.md5()f.update(b&apos;hello&apos;) #b表示byte类型f.update(b&apos;world&apos;)print(f.digest()) #digest:二进制hashprint(f.hexdigest()) #hexdigest:十六进制hash#md5hash = hashlib.md5()hash.update(b&apos;admin&apos;)print(hash.hexdigest())#sha1hash = hashlib.sha1()hash.update(b&apos;admin&apos;)print(hash.hexdigest())#sha256hash = hashlib.sha256()hash.update(b&apos;admin&apos;)print(hash.hexdigest())#sha512hash = hashlib.sha512()hash.update(b&apos;admin&apos;)print(hash.hexdigest())</code></pre><h2 id="hmac模块"><a href="#hmac模块" class="headerlink" title="hmac模块"></a><strong>hmac模块</strong></h2><pre><code>它内部对我们创建&quot;key&quot;和&quot;内容&quot;再进行处理然后再加密import hmacf = hmac.new(b&apos;123AVC&apos;,&apos;小鸡炖蘑菇&apos;.encode(encoding=&apos;utf-8&apos;))print(f.hexdigest())</code></pre><h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a><strong>re模块</strong></h2><pre><code>&quot;re&quot;模块一般用于正则表达式匹配re.match()      #文本从头开始搜索re.search()     #从整个文本开始搜索re.findall()    #把所有匹配到的字符放到以列表中的元素返回re.splitall()  #以匹配到的字符当作列表分隔符re.sub()        #匹配字符并替换(例:将数字替换成|并且只替换前面两个,                (re.sub(&quot;[0-9]+&quot;,&quot;|&quot;,&quot;abc12de3f45gh&quot;,count=2)) 结果为:&apos;abc|de|f45gh&apos;).         #匹配换行符之外的任意字符^         #匹配字符开头$         #匹配字符结尾+         #匹配前一个字符1次或多次?         #匹配前1个字符1次或0次(例:re.search(&quot;aa?&quot;,&quot;aaa123&quot;) 结果为:aa){m}      #匹配前一个字符m次(例：re.search(&quot;[0-9]{3}&quot;,&quot;aa1x2d456&quot;) 结果为456){n,m}     #匹配前一个字符n到m次(例：re.findall(&quot;[0-9]{1,3}&quot;,&quot;aa1x2d456&quot;) 结果为:1,2,456)|         #匹配左或|右的字符(例:re.search(&quot;abc|ABC&quot;,&quot;ABCxabcDN&quot;) 结果为:ABC)...        #分组匹配\A        #从字符开头匹配 (例：re.search(&quot;\A[0-9]+[a-z]\Z&quot;,&quot;1234a&quot;) 结果为:1234a)\Z        #从字符结尾匹配，同$\d        #匹配数字0-9\D        #匹配非数字意外的字符(包括特殊字符)\w        #匹配字母，数字\W        #匹配特殊字符\s       #匹配空白字符(例:re.search(&quot;\s+&quot;,&quot;a12gdf \r\n  &quot;) 结果为:\r\n\t)例：1,匹配R开头，a结尾字符ChenRonghua123  #re.search(&quot;R[a-z]+a&quot;)2,获取#之间的字符123#hello#     #re.search(&quot;#.+#&quot;)</code></pre><p>文档详细参考：<a href="http://www.cnblogs.com/alex3714/articles/5161349.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5161349.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近这段时间，利用业余时间学习了一下Python,写篇博客算是记录一下相关的知识点，方便以后查询，也算做个小总结！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/RYTHJeH.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://zhuwenbing.top/categories/Python/"/>
    
    
      <category term="Python" scheme="http://zhuwenbing.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 Jdk+Tomcat的安装</title>
    <link href="http://zhuwenbing.top/2018/03/27/tomcat/"/>
    <id>http://zhuwenbing.top/2018/03/27/tomcat/</id>
    <published>2018-03-27T05:22:38.570Z</published>
    <updated>2017-04-25T10:07:55.772Z</updated>
    
    <content type="html"><![CDATA[<p>Java Development Kit（JDK）是太阳微系统针对Java开发人员发布的免费软件开发工具包（SDK，Software development kit）。自从Java推出以来，JDK已经成为使用最广泛的Java SDK。由于JDK的一部分特性采用商业许可证，而非开源。因此，2006年太阳微系统宣布将发布基于GPL的开源JDK，使JDK成为自由软件。<a id="more"></a></p><p>目的：公司开发人员的需要</p><p>安装的版本：<br>jdk版本：1.8.0_121<br>tomcat版本：8.5.13</p><h2 id="Jdk的安装："><a href="#Jdk的安装：" class="headerlink" title="Jdk的安装："></a><strong>Jdk的安装</strong>：</h2><p><strong>先查询是否安装JDK</strong> </p><pre><code>[root@node1 ~]# java -version  #centos7 默认是装的openjdkOpenjdk version &quot;1.8.0_65&quot;OpenJDK Runtime Environment (build 1.8.0_65-b17)OpenJDK 64-Bit Server VM (build 25.65-b01, mixed mode) [root@node1 ~]# yum remove java-1.8.0-openjdk ##直接卸载[root@node1 ~]# java -version  #为什么还有在是吗？？？？Openjdk version &quot;1.8.0_65&quot;OpenJDK Runtime Environment (build 1.8.0_65-b17)OpenJDK 64-Bit Server VM (build 25.65-b01, mixed mode) 正确的方式卸载openjdk：[root@node1 ~]# rpm -qa | grep java #查看装了那些包java-1.7.0-openjdk-1.7.0.91-2.6.2.3.el7.x86_64java-1.7.0-openjdk-headless-1.7.0.91-2.6.2.3.el7.x86_64java-1.8.0-openjdk-headless-1.8.0.65-3.b17.el7.x86_64[root@node1 ~]# rpm -e --nodeps java-1.7.0-openjdk-1.7.0.91-2.6.2.3.el7.x86_64 ##三个都要卸载[root@node1 ~]# java -version #OK，这次卸载的很干净-bash: /bin/java: No such file or directory</code></pre><h2 id="下载你需要版本的jdk"><a href="#下载你需要版本的jdk" class="headerlink" title="下载你需要版本的jdk"></a><strong>下载你需要版本的jdk</strong></h2><pre><code>地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html [root@node1 ~]# rpm -ivh /usr/java/jdk1.7.0.79.rpm #安装JDK</code></pre><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a><strong>配置环境变量</strong></h2><pre><code>在/etc/profile尾部添加以下代码：JAVA_PATH #标记是java的内容export JAVA_HOME=/usr/java/jdk1.8.0_121 #export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar [root@node1 ~]# source /etc/profile #使配置生效</code></pre><p><strong>java -version  #查看是否安装成功</strong></p><h2 id="TOMCAT的配置和安装："><a href="#TOMCAT的配置和安装：" class="headerlink" title="TOMCAT的配置和安装："></a><strong>TOMCAT的配置和安装</strong>：</h2><p>Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。<br>由于Tomcat本身也内含了一个HTTP服务器，它也可以被视作一个单独的Web服务器。<br>但是，不能将Tomcat和Apache HTTP服务器混淆，Apache HTTP服务器是一个用C语言实现的HTTPWeb服务器；<br>这两个HTTP web server不是捆绑在一起的。Apache Tomcat包含了一个配置管理工具，<br>也可以通过编辑XML格式的配置文件来进行配置。</p><h2 id="下载并安装TOMCAT"><a href="#下载并安装TOMCAT" class="headerlink" title="下载并安装TOMCAT"></a><strong>下载并安装TOMCAT</strong></h2><pre><code>[root@node1 ~]# tar -zxvf tomcat-8.5.13.tar.gz tomcat #解压安装文件并命名为&quot;tomcat&quot;[root@node1 ~]# mv tomcat /usr/local/</code></pre><h2 id="启动tomcat"><a href="#启动tomcat" class="headerlink" title="启动tomcat"></a><strong>启动tomcat</strong></h2><pre><code>[root@node1 ~]# bash catalina.sh start [root@node1 ~]# curl http://localhost:8080 #能看到tomcat的欢迎页面表示ok</code></pre><h2 id="修改TOMCAT默认端口"><a href="#修改TOMCAT默认端口" class="headerlink" title="修改TOMCAT默认端口"></a><strong>修改TOMCAT默认端口</strong></h2><pre><code>[root@node1 ~]# vim /usr/local/tomcat/conf/server.xml**Connector port=&quot;**80**[S1] &quot; maxHttpHeaderSize=&quot;8192&quot;##默认端口是8080,看你需求修改maxThreads=&quot;150&quot; minSpareThreads=&quot;25&quot; maxSpareThreads=&quot;75&quot;enableLookups=&quot;false&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;100&quot;connectionTimeout=&quot;20000&quot; disableUploadTimeout=&quot;true&quot; /&gt;**[root@node1 bin]# ./shutdown.sh [root@node1 bin]# ./catalina.sh start #重新启动一下tomcat[root@node1 bin]# ss -tnlp #查看80、8005、8009是否为Java所监听    [root@node1 ~]#netstat -pant | grep 8005命令查看端口[root@node1 ~]#fuser -v -n tcp 8005 #查看8005监听状态-v 详细模式-n 指定一个不同的命名空间</code></pre><h2 id="放行防火墙端口"><a href="#放行防火墙端口" class="headerlink" title="放行防火墙端口"></a><strong>放行防火墙端口</strong></h2><pre><code>firewall-cmd --permanent --add-prot=80/tcpfirewall-cmd --reload</code></pre><h2 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a><strong>开机启动</strong></h2><pre><code>[root@node1 ~]# vim /etc/rc.d/rc.local添加下面三行内容：tomcat #标记是tomcat的内容export JAVA_HOME=/usr/java/jdk1.8.0_121 # 是jdk安装目录/usr/local/tomcat/bin/startup.sh start  #是tomcat安装的目录注意：修改rc.local文件添加执行权限： chmod +x rc.local</code></pre><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a><strong>遇到的问题</strong></h2><pre><code>如果执行配置文件报错1：touch:cannot touc &apos;/usr/local/kencery/tomcat/logs/catalina.out:NO such file or directory*:报这个错只需要 mkdir /usr/local/tomcat/logs 即可一般执行配置文件报错都会在/usr/local/tomcat/logs/catalina.out中显示如果执行配置文件报错2：/usr/local/tomcat/bin/catalina.sh:line 435: /usr/local/java/jdk1.7.0_79/bin/java: no such file directory/usr/local/tomcat/bin/catalina.sh:line 435: /usr/local/jdk6/jre/bin/java: no such file or directory/usr/local/tomcat/bin/catalina.sh:line 435: /usr/local/jdk1.7.0_79//jre/bin/java: no such file or directory*:报这个错 只需要打开配置文件 /usr/local/tomcat/bin/catalina.sh 然后在435行用#注释掉即可</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java Development Kit（JDK）是太阳微系统针对Java开发人员发布的免费软件开发工具包（SDK，Software development kit）。自从Java推出以来，JDK已经成为使用最广泛的Java SDK。由于JDK的一部分特性采用商业许可证，而非开源。因此，2006年太阳微系统宣布将发布基于GPL的开源JDK，使JDK成为自由软件。
    
    </summary>
    
      <category term="Tomcat" scheme="http://zhuwenbing.top/categories/Tomcat/"/>
    
    
      <category term="Tomcat" scheme="http://zhuwenbing.top/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 HA集群之Corosync+Pacemaker+NFS+Http+Ansible</title>
    <link href="http://zhuwenbing.top/2018/03/27/pacemaker+corosync/"/>
    <id>http://zhuwenbing.top/2018/03/27/pacemaker+corosync/</id>
    <published>2018-03-27T05:22:38.554Z</published>
    <updated>2017-09-26T03:25:20.417Z</updated>
    
    <content type="html"><![CDATA[<p>Corosync是OpenAIS发展到Wilson版本后衍生出来的开放性集群引擎工程。可以说Corosync是OpenAIS工程的一部分。OpenAIS从openais0.90开始独立成两部分，一个是Corosync；另一个是AIS标准接口Wilson。Corosync包含OpenAIS的核心框架用来对Wilson的标准接口的使用、管理。它为商用的或开源性的集群提供集群执行框架。Corosync执行高可用应用程序的通信组系统，它有以下特征：<br>（1）一个封闭的程序组（A closed process group communication model）通信模式<a id="more"></a>，这个模式提供一种虚拟的同步方式来保证能够复制服务器的状态。<br>（2）一个简单可用性管理组件（A simple availability manager），这个管理组件可以重新启动应用程序的进程当它失败后。<br>（3）一个配置和内存数据的统计（A configuration and statistics in-memory database），内存数据能够被设置，回复，接受通知的更改信息。<br>（4）一个定额的系统（A quorum  system）,定额完成或者丢失时通知应用程序。<br><strong>总结</strong>：Corosync是整合底层节点服务器，提供API个pacemaker的一个中间层</p><p>Pacemaker，是一个群集资源管理器。它实现最大可用性群集服务（亦称资源管理）的节点和资源级故障检测和恢复使用您的首选集群基础设施（OpenAIS的或Heaerbeat）提供的消息和成员能力。<br>它可以做乎任何规模的集群，并配备了一个强大的依赖模型，使管理员能够准确地表达群集资源之间的关系（包括顺序和位置）。几乎任何可以编写脚本，可以管理作为心脏起搏器集群的一部分。<br>pacemaker支持超过16个节点的控制</p><p>目的：利用Corosyn+Packemaker+NFS+Http实现Web高可用集群</p><p><strong>工作原理图</strong><br>（图片来源于网络）：<br><img src="http://i.imgur.com/SQ2c1OJ.png" alt=""></p><p><strong>架构图：</strong></p><p><img src="http://i.imgur.com/sNG4kIJ.jpg" alt=""></p><p>准备四台机器和一个虚拟IP：</p><pre><code>虚拟IP:192.168.1.60        node1:192.168.1.51  node1.comnode2:192.168.1.52  node2.comnfs  :192.168.1.53ansible:192.168.1.54</code></pre><h2 id="集群准备工作"><a href="#集群准备工作" class="headerlink" title="集群准备工作"></a><strong>集群准备工作</strong></h2><p>   两节点要时间同步，ssh访问互信，hosts名称解析一致,关闭selinux</p><pre><code>1.修改Hosts    [root@node1 ~]# vim /etc/hosts192.168.1.51 node1.com node1192.168.1.52 node2.com node2 [root@node1 ~]# uname -n        node1.com   其他节点和上面配置一样2.配置ansible主机[root@ansible ~]# yum -y install ansible （需要配置eple源）[root@ansible ~]# cp hosts{,.bak} ##复制一份备用[root@ansible ~]# vim /etc/ansible/hosts      [haservers]   ##定义一个ansible集群组192.168.1.51192.168.1.523.建立ssh公钥认证[root@ansible ~]# ssh-keygent -t rsa -P&apos;&apos;  ##生成公钥（一路回车就行了）[root@ansible ~]# ssh-copy-id -i .ssh/id_rsa.pub root@192.168.1.51 ##复制公钥到node1.com[root@ansible ~]# ssh-copy-id -i .ssh/id_rsa.pub root@192.168.1.52   ##复制到node2.com4.测试一下：[root@ansible ~]# ssh node1The authenticity of host &apos;node1 (192.168.1.51)&apos; can&apos;t be established.ECDSA key fingerprint is 85:a3:4b:1d:ab:2f:41:30:df:70:39:76:f4:08:be:02.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;node1&apos; (ECDSA) to the list of known hosts.Last login: Tue Feb 28 22:07:37 2017[root@node1 ~]#       ##没有输密码表示成功node2节点也试一下[root@ansible ~]# ansible all -m ping  ##使用ansible测试一下   192.168.1.51 | SUCCESS =&gt; {&quot;changed&quot;: false, &quot;ping&quot;: &quot;pong&quot; } 192.168.1.52 | SUCCESS =&gt; { &quot;changed&quot;: false,  &quot;ping&quot;: &quot;pong&quot;  }</code></pre><p>同步时间：</p><pre><code>[root@ansible ~]# ansible all -m yum -a &quot;name=ntpdate state=present&quot; ##各节点都装上时间服务器[root@ansible ~]# ansible all -m shell -a &quot;ntpdate cn.pool.ntp.org&quot; ##向国家时间服务器同步</code></pre><h2 id="安装corosync-pacemaker-crmsh"><a href="#安装corosync-pacemaker-crmsh" class="headerlink" title="安装corosync,pacemaker,crmsh "></a><strong>安装corosync,pacemaker,crmsh </strong></h2><pre><code>1.首先安装corosync和pacemaker由于corosync是pacemake的依赖包，所有安装完pacemaker后corosync自动被安装上  使用ansible安装:[root@ansible ~]# ansible all -m yum -a &quot;name=pacemaker state=present&quot;在2个node节点确认：[root@node1~]# rpm -qa pacemaker pacemaker-1.1.13-10.el7.x86_64[root@node1~]# rpm -qa corosync corosync-2.3.4-7.el7.x86_642.安装crmshcrmsh在yum仓库和epel源都没有需要去另外下载,下载后拷贝到ansible主机/crmsh  http://download.opensuse.org/repositories/network:/ha-clustering:/Stable/CentOS_CentOS-7/noarch/   [root@ansible ~]#ls /crmsh  asciidoc-8.6.9-32.2.noarch.rpm           crmsh-scripts-3.0.0-1.2.noarch.rpm   asciidoc-examples-8.6.9-32.2.noarch.rpm  crmsh-test-3.0.0-1.2.noarch.rpm  crmsh-3.0.0-1.2.noarch.rpm               python-parallax-1.0.1-28.2.noarch.rpm[root@ansible ~]# ansible all -m shell -a &apos;mkdir /root/crmsh&apos;[root@ansible ~]# ansible all -m copy -a &quot;src=/root/crmsh/ dest=/root/crmsh/&quot;[root@ansible ~]# ansible all -m shell -a &apos;yum -y install /root/crmsh/*.rpm&apos;   两个节点确认一下:[root@node1 ~]#crmcrm(live)#     ##表示crmsh安装成功</code></pre><h2 id="配置corosync和pacemaker并启动服务"><a href="#配置corosync和pacemaker并启动服务" class="headerlink" title="配置corosync和pacemaker并启动服务"></a><strong>配置corosync和pacemaker并启动服务</strong></h2><pre><code> corosync配置文件修改，ansible主机上修改并部署 [root@ansible ~]# yum -y install pacemaker [root@ansible ~]# cd /etc/corosync [root@ansible ~]# cp corosync.conf.example corosync.conf [root@ansible ~]# vim corosync.conf  # Please read the corosync.conf.5 manual page  totem {   ##集群信息       version: 2   ##版本    crypto_cipher: aes128   ##对称节点采用aes128加密方式，单项采用sha1加密    crypto_hash: sha1    interface {            ringnumber: 0 ##心跳信息传递的环号码，如果有多个接口传递心跳信息，则定义多个，每个环号不同            bindnetaddr: 192.168.1.0 ##心跳信息接口的网络地址            mcastaddr: 239.255.1.1   ##心跳信息传递时使用的组播地址            mcastport: 5405  ##组播端口            ttl: 1  ##防止心跳信息环路，限定心跳信息传递的ttl值，一般是集群节点个数减去1        }  }  logging { ##定义日志记录方式    fileline: off    to_stderr: no    to_logfile: yes  ##是否记录日志    logfile: /var/log/cluster/corosync.log  ##日志文件位置    to_syslog: no  ##是否记录到系统日志    debug: off   ##关闭调试模式    timestamp: on  ##时间戳标签    logger_subsys {  ##记录投票子系统的日志信息            subsys: QUORUM            debug: off    }}  quorum {            provider: corosync_votequorum  ##投票系统使用corosync自带  }  nodelist {  ##自定义的节点    node {            ring0_addr:node1.com  ##环0上的地址，如果此前定义了多个接口用于传递心跳信息，                则次处定义多个环上的不同地址，如ring1_addr:....            nodeid:1     }    node {            ring0_addr:node2.com            nodeid:2    }}</code></pre><p>创建认证文件</p><pre><code>[root@ansible ~]# corosync-keygen -l  ##由于corosync配置文件中定义了通信采用的加密方式进行，因此要生成秘钥文件使用ansible将配置文件及认证文件全部拷贝至节点服务器，注意authkey的权限（400或600）[root@ansible ~]# ansible all -m copy -a &quot;src=/etc/corosync/authkey mode=400 dest =/etc/corosync/authkey&quot;##复制认证文件到各节点    [root@ansible ~]# ansible all -m copy -a &quot;src=/etc/corosync/corosync.confdest=/etc/corosync/corosync.conf&quot;##复制corosync配置文件到各节点 </code></pre><p>进入节点主机进行验证:</p><pre><code>[root@node1~]# ll /etc/corosync/total 20-r--------. 1 root root  128 Feb 23 02:47 authkey-rw-r--r--. 1 root root 2999 Feb 27 22:32 corosync.conf-rw-r--r--. 1 root root 2881 Nov 20  2015 corosync.conf.example-rw-r--r--. 1 root root  767 Nov 20  2015 corosync.conf.example.udpu-rw-r--r--. 1 root root 3278 Nov 20  2015 corosync.xml.exampledrwxr-xr-x. 2 root root    6 Nov 20  2015 uidgid.d</code></pre><p>开启corosync和pacemaker服务：</p><pre><code>[root@ansible ~]# ansible all -m service -a &quot;name=corosync state=started&quot;   ##启动各节点的corosync服务[root@ansible ~]# ansible all -m service -a &quot;name=pacemaker state=started&quot;  ##启动各节点的pacemaker服务</code></pre><p>各节点查看服务状态：</p><pre><code>[root@node1~]# crm status Last updated: Tue Feb 28 23:32:05 2017         Last change: Tue Feb 28 22:03:05 2017 by root via cibadmin on node1.com Stack: corosync Current DC: node1.com (version 1.1.13-10.el7-44eb2dd) - partition with quorum 2 nodes and 3 resources configured Online: [ node1.com node2.com ]    ##node1和node同时在线表示成功</code></pre><h2 id="配置NFS服务"><a href="#配置NFS服务" class="headerlink" title="配置NFS服务"></a><strong>配置NFS服务</strong></h2><p>安装配置nfs服务</p><pre><code>[root@nfs server ~]# yum -y install nfs-utils  ##安装nfs[root@nfs server ~]# systemctl enable nfs.service  ##开机启动nfs[root@nfs server ~]# systemctl start  nfs.service  ##启动nfs[root@nfs server ~]# firewall-cmd --permanent --add-service=nfs ##防火墙放行nfs[root@nfs server ~]# firewall-cmd --permanent --add-service=rpc-bind[root@nfs server ~]# firewall-cmd --permanent --add-service=mountd[root@nfs server ~]# firewall-cmd --reload[root@nfs server ~]# mkdir /web/storage -pv[root@nfs server ~]# vim /etc/exportfs     /web/storage 192.168.1.0/24(rw)[root@nfs server ~]#exportfs -rv      ##(-r表示重读配置，-v显示共享情况)[root@nfs server ~]# systemctl restart nfs.service</code></pre><p><strong>使用ansible挂载nfs</strong></p><pre><code>[root@ansible ~]# ansible all -m yum -a &quot;name=nfs-utils state=present&quot;[root@ansible ~]# ansible all -m shell -a &apos;mount -t nfs 192.168.1.53:/web/storage /var/www/html&apos;    到node节点上查看是否挂载[root@node1 ~]# df -h Filesystem                 Size  Used Avail Use% Mounted on192.168.1.53:/web/storage   10G  4.1G  6.0G  41% /var/www/htmlansible卸载nfs（这里先卸载，因为后面集群会自动挂载）[root@ansible ~]# ansible all -m shell -a &apos;umount /var/www/html’</code></pre><h2 id="crmsh配置集群"><a href="#crmsh配置集群" class="headerlink" title="crmsh配置集群"></a><strong>crmsh配置集群</strong></h2><pre><code>   [root@node1~]# crm(live)cd configurecrm(live)configure# property no-quorum-policy=stop   ##关闭法定票数不足       crm(live)configure# property stonith-enabled=false  ##由于没有stonith设备，所以先将stonith关闭    crm(live)configure# rsc_defaults resource-stickiness=100 ##设定资源粘性值为100               crm(live)configure#primitive webip ocf:heartbeat:IPaddr params ip=192.168.1.60 ##定义虚拟IP                   定义完虚拟IP可以验证一下，看各节点是否都配置成功  [root@node1~]# ip addr                  2: eno16777736: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000             link/ether 00:0c:29:9b:93:76 brd ff:ff:ff:ff:ff:ff         inet 192.168.1.51/24 brd 192.168.1.255 scope global eno16777736             valid_lft forever preferred_lft forever                 inet 192.168.1.60/24 brd 192.168.1.255 scope global secondary eno16777736                 valid_lft forever preferred_lft forever                 inet6 fe80::20c:29ff:fe9b:9376/64 scope link                  valid_lft forever preferred_lft forever crm(live)configure# primitive webserver systemd:httpd op start timeout=100  op stop timeout=100 op monitor interval=60 timeout=100   ##定义使用的服务 crm(live)configure# primitive webstore ocf:heartbeat:Filesystem params directory=&quot;/var/www/html&quot;  fstype=nfs op start timeout=60s op stop timeout=60s op monitor interval=60 timeout=100       ##定义使用的存储设备 crm(live)configure# group   webservice  webip webstore webserver ##定义集群组，要按照资源顺序来 crm(live)configure# verify  ##校验 crm(live)configure# commit  ##提交配置确认并生效配置完成后查看是这样，表示成功  crm(live)# status       Last updated: Wed Mar  1 01:27:39 2017               Last change: Tue Feb 28 22:03:05 2017 by root via cibadmin on node1.com       Stack: corosync        Current DC: node1.com (version 1.1.13-10.el7-44eb2dd) - partition with quorum       2 nodes and 3 resources configured    Online: [ node1.com node2.com ]    Full list of resources:     Resource Group: webservice         webip        (ocf::heartbeat:IPaddr):    Started node1.com          webstore    (ocf::heartbeat:Filesystem):    Started node1.com          webserver    (systemd:httpd):    Started node1.com 可以用下面几种资源约束的方法：     crm(live)configure# location webstore_perfer webstore inf: node1.com ##使用location定义webstore对节点1的倾向性为正无穷crm(live)configure# colocation webserver_with_webip inf:webserver webip ##定义两个资源的粘性，必须在一起crm(live)configure# order webip_bef_webstore_bef_webserver mandatory: webip webstore webse    ##强制资源启动顺序    crm(live)resource# migrate webip node1.com  ##使用migrate进行资源转移</code></pre><h2 id="开始测试集群："><a href="#开始测试集群：" class="headerlink" title="开始测试集群："></a><strong>开始测试集群：</strong></h2><pre><code>[root@node1~]# echo The page is NFS Server &gt;&gt; /var/www/html/index.html[root@node1~]# curl http://192.168.1.60    The page is NFS Server     [root@node1~]# crm node standby ##停用当前节点[root@node1~]# crm status   Node node1.com: standby   Online: [ node2.com ]   Full list of resources:   Resource Group: webservice        webip         (ocf::heartbeat:IPaddr):    Started node2.com        webstore    (ocf::heartbeat:Filesystem):    Started node2.com        webserver    (systemd:httpd):    Started node2.com      此时节点已经转移到了node2</code></pre><p>  OK，到此结束，全部成功了     </p><h2 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title=" 遇到的问题："></a><strong> 遇到的问题：</strong></h2><pre><code>1、 2个节点双方都显示自己这一方在线，另一方不在线    解决方法：彻底关闭selinux2、[root@node1 ~]#crm status   ERROR: status: crm_mon (rc=107): Connection to cluster failed: Transport endpoint is not connected   解决方法：systemctl start packemaker.service  ##ok!</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Corosync是OpenAIS发展到Wilson版本后衍生出来的开放性集群引擎工程。可以说Corosync是OpenAIS工程的一部分。OpenAIS从openais0.90开始独立成两部分，一个是Corosync；另一个是AIS标准接口Wilson。Corosync包含OpenAIS的核心框架用来对Wilson的标准接口的使用、管理。它为商用的或开源性的集群提供集群执行框架。Corosync执行高可用应用程序的通信组系统，它有以下特征：&lt;br&gt;（1）一个封闭的程序组（A closed process group communication model）通信模式
    
    </summary>
    
      <category term="Cluster" scheme="http://zhuwenbing.top/categories/Cluster/"/>
    
    
      <category term="HA之Corosync+Pacemaker" scheme="http://zhuwenbing.top/tags/HA%E4%B9%8BCorosync-Pacemaker/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 搭建ntp时间服务器</title>
    <link href="http://zhuwenbing.top/2018/03/27/ntp-server/"/>
    <id>http://zhuwenbing.top/2018/03/27/ntp-server/</id>
    <published>2018-03-27T05:22:38.550Z</published>
    <updated>2017-04-25T09:50:22.067Z</updated>
    
    <content type="html"><![CDATA[<p>目的：解决实验环境中时间的一致性<br>NTP是Network Time Protocol的简写，即网络时间协议。多个主机可以通过NTP同步系统时间。<br>下面我们搭建一个NTP服务器，其他服务器都可以通过NTP服务器实现时间同步。<br>首先需要确保服务器时区设置是否正确，使用timedatectl查看设置时区（Asia/Shanghai）.</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作:"></a><strong>准备工作</strong>:</h2><pre><code>NTP服务器地址：    服务器：192.168.1.50客户端：192.168.1.51</code></pre><h2 id="RPM包检查："><a href="#RPM包检查：" class="headerlink" title="RPM包检查："></a><strong>RPM包检查</strong>：</h2><pre><code>[root@ntp server ~]# rpm -ql |grep ntp 没有安装就直接yum安装  [root@ntp server ~]# yum -y install ntp</code></pre><h2 id="开机启动ntp服务"><a href="#开机启动ntp服务" class="headerlink" title="开机启动ntp服务"></a><strong>开机启动ntp服务</strong></h2><pre><code>systemctl enable ntpdsystemctl start  ntpd</code></pre><h2 id="获取免费时间服务器地址"><a href="#获取免费时间服务器地址" class="headerlink" title="获取免费时间服务器地址"></a><strong>获取免费时间服务器地址</strong></h2><pre><code>http://www.pool.ntp.org/zone/cn</code></pre><h2 id="配置时间服务器"><a href="#配置时间服务器" class="headerlink" title="配置时间服务器:"></a><strong>配置时间服务器:</strong></h2><pre><code>[root@ntp server ~]# vim /etc/ntp.conf     server 0.cn.pool.ntp.orgserver 1.cn.pool.ntp.org    server 2.cn.pool.ntp.org    server 3.cn.pool.ntp.org    fudge 127.127.0.1 stratum 3     ##设置自身为3级Ntp serverNTPserver server 127.127.1.0 iburst  local clock  ##外部不可用时，使用本地时间    restrict 192.168.1.0 mask 255.255.255.0 nomodify  ## 设置客户端的限制，nomodify允许来自哪个段的IP来同步时间但不允许改ntp服务器参数</code></pre><h2 id="重启服务并防火墙放行"><a href="#重启服务并防火墙放行" class="headerlink" title="重启服务并防火墙放行"></a><strong>重启服务并防火墙放行</strong></h2><pre><code>systemctl restart ntpdfirewall-cmd --permanent--add-port=123/udp firewall-cmd --reload</code></pre><h2 id="检查-ntpq-p查看ntpd"><a href="#检查-ntpq-p查看ntpd" class="headerlink" title="检查 ntpq -p查看ntpd"></a><strong>检查 ntpq -p查看ntpd</strong></h2><h2 id="客户端测试"><a href="#客户端测试" class="headerlink" title="客户端测试  "></a><strong>客户端测试  </strong></h2><pre><code>[root@test ~]# ntpdate 192.168.1.5029 Mar 15:13:01 ntpdate[3895]: adjust time server 192.168.1.50 offset -0.019419 sec ##同步时间成功[root@test ~]# hwclock -w  ##重新写入硬件时钟</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目的：解决实验环境中时间的一致性&lt;br&gt;NTP是Network Time Protocol的简写，即网络时间协议。多个主机可以通过NTP同步系统时间。&lt;br&gt;下面我们搭建一个NTP服务器，其他服务器都可以通过NTP服务器实现时间同步。&lt;br&gt;首先需要确保服务器时区设置是否正确，使用timedatectl查看设置时区（Asia/Shanghai）.&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://zhuwenbing.top/categories/linux/"/>
    
    
      <category term="Ntp Server" scheme="http://zhuwenbing.top/tags/Ntp-Server/"/>
    
  </entry>
  
  <entry>
    <title>Centos7  Nginx利用“反向代理”实现“动静分离”</title>
    <link href="http://zhuwenbing.top/2018/03/27/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>http://zhuwenbing.top/2018/03/27/Nginx反向代理/</id>
    <published>2018-03-27T05:22:38.533Z</published>
    <updated>2017-09-26T03:24:40.599Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Nginx</strong>是一款免费的，开源的，高性能的HTTP服务软件，它不仅能够支持反向代理服务器，而且也可以当作IMAP/POP3代理服务。<br>nginx不采用每客户机一线程的设计模型，而是充分使用异步逻辑，削减了上下文调度开销，所以并发服务能力更强。整体采用模块化设计，有丰富的模块库和第三方模块库，配置灵活。在Linux操作系统下，nginx使用epoll事件模型，得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于epoll的高效事件模型kqueue。<br>而且它稳定，配置丰富，设置简单，支持热部署<a id="more"></a>，而且占用系统资源少，10000个keep-alive模式下connection仅需要2.5MB内存！！！（俄罗斯的产品果然是简单粗暴）</p><p><strong>Nginx工作模式</strong>：Master/worker<br>          一个主进程master生成一个或者多个work线程<br>          master:负责加载和分析配置文件<br>          work:处理并响应用户请求</p><p><strong>特性</strong>：<br>         异步，非阻塞，事件驱动<br>         文件IO: sendfile ，mmap</p><p><strong>核心模块</strong>：<br>          main: 主要用户配置错误日志，进程管理，权限控制<br>          event: 配置epoll,kqueue,select,poll</p><p><strong>rewrite模块</strong>：<br>          把用户请求的URL基于regex做检查，匹配时将替换为replacement指定的字符串<br>          如果replacement是以http：//开头，则替换结果会直接重定向返回客户端<br>          在同一个localtion中存在多个rewrite规则会自上而下逐个检查，可以使用flag控制此循环功能</p><p>last：提前结束本轮循环，进入下一轮，continue<br>break：终止了，不再循环<br>redirect：重定向，临时重定向，302<br>permanent：永久重定向，301，重写后生成的新url给客户端，由客户端对新url进行请求</p><p>例如：<br>  localtion / {<br>        rewrite (.<em>）.txt$ $1.html;<br>         }<br>请求的txt文件都变成html，重写，变成了一个新的url，然后被匹配<br>    再加上：<br>  location ~</em>.html\$ {<br>        rewrite (.*).html $1.txt;<br>        }<br>后，html又转化为txt了，就形成一个死循环，所以要在两个后面加上条件，break。</p><p>然后再加上个redirect，临时重定向<br>    location / {<br>         rewrite (.*).txt$ $1.html redirect;<br>        }</p><p><strong>upstream 模块</strong>：<br>           负载均衡，必须定义在http段落</p><p><strong>实验目的</strong>：利用Nginx反向代理，将用户请求的动态资源反代到Web1,静态资源反代到Web2</p><p>架构图：</p><p><img src="http://i.imgur.com/09Eqfpl.jpg" alt=""></p><h2 id="虚拟机实验环境"><a href="#虚拟机实验环境" class="headerlink" title="虚拟机实验环境"></a>虚拟机实验环境</h2><pre><code>1.关闭selinux和清空iptables2.所有主机同步时间3.Nginx反向代理服务器内网网卡选择VMNET8虚拟网络连接4.Web1部署LAMP平台，Web2部署httpd</code></pre><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><pre><code>  客户端IP：192.168.1.158  Nginx反向代理服务器IP：                外网：192.168.1.51                内网：192.168.42.130后端Web服务器IP：                Web1：192.168.42.128                Web2：192.168.42.129</code></pre><h2 id="服务安装"><a href="#服务安装" class="headerlink" title="服务安装"></a>服务安装</h2><pre><code>Nginx服务器安装nginx软件包：      [root@nginx /]# yum -y install nginx   ##需要配置好epel源Web1服务器配置搭建LAMP平台：[root@Web1 /]# yum -y install httpd mariadb-server php php-mysql php-gd libjpeg* php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-bcmath php-mhash新建测试页vim /var/www/html/index.php&lt;?phpphpinfo();?&gt;[root@Web1 /]# curl http://192.168.42.128能看到php测试页表示ok   Web2服务器配置httpd服务[root@Web2 /]# yum -y install httpd安装完后新建测试页curl http://192.168.42.129能看到表示ok</code></pre><h2 id="nginx配置反向代理"><a href="#nginx配置反向代理" class="headerlink" title="nginx配置反向代理"></a>nginx配置反向代理</h2><pre><code>[root@nginx nginx]# cp nginx.conf{,.bak}  ##先做备份主要配置： proxy_set_header NWC_TEST $remote_addr;  ##定义日志首部location / {        root /usr/share/nginx/html;        index   index.html index.htm;        proxy_pass http://192.168.42.129;}location ~ \.php$ {        proxy_pass http://192.168.42.128;        index   index.php index.html index.htm;}</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>http://192.168.1.51/index.php|index.html 能看到.php页面和.html页面的内容和WEB1,WEB2相同表明OK</code></pre><h2 id="设置RS的请求报文首部"><a href="#设置RS的请求报文首部" class="headerlink" title="设置RS的请求报文首部"></a>设置RS的请求报文首部</h2><pre><code>在nginx主机上添加proxy_set_header NWC_TEST $remote_addr;利用proxy_set_header指令，设置nginx反代用户请求到后端主机上时，为请求报文添加一个首部，首部名称为NWC_TEST,首部对应的值为$remote-addr对应的值，也就是真是客户端IP地址修改完nginx服务器，再到后端主机修改日志格式LogFormat &quot;%{NWC_TEST}i %h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%{Referer}i\&quot; \&quot;%{User-Agent}i\&quot;&quot; combined</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Nginx&lt;/strong&gt;是一款免费的，开源的，高性能的HTTP服务软件，它不仅能够支持反向代理服务器，而且也可以当作IMAP/POP3代理服务。&lt;br&gt;nginx不采用每客户机一线程的设计模型，而是充分使用异步逻辑，削减了上下文调度开销，所以并发服务能力更强。整体采用模块化设计，有丰富的模块库和第三方模块库，配置灵活。在Linux操作系统下，nginx使用epoll事件模型，得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于epoll的高效事件模型kqueue。&lt;br&gt;而且它稳定，配置丰富，设置简单，支持热部署
    
    </summary>
    
      <category term="Nginx" scheme="http://zhuwenbing.top/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://zhuwenbing.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 Mysql双主模型</title>
    <link href="http://zhuwenbing.top/2018/03/27/mysql%E5%8F%8C%E4%B8%BB%E6%A8%A1%E5%9E%8B/"/>
    <id>http://zhuwenbing.top/2018/03/27/mysql双主模型/</id>
    <published>2018-03-27T05:22:38.517Z</published>
    <updated>2017-09-26T03:23:58.145Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Mysql</strong>双主模型可以在一定程度上保证主库的高可用,在一台主库down掉之后,可以在极短的时间内切换到另一台主库上（尽可能减少主库宕机对业务造成的影响），减少了主从同步给线上主库带来的压力；<a id="more"></a></p><p><strong>目的：利用双主模型来提高系统的可用性</strong></p><p><strong>模型图</strong><br>（来源于网络）：<br><img src="http://i.imgur.com/UCkH4Eo.jpg" alt=""></p><p><strong>准备工作</strong><br>1、为了不影响实验结果，建议关闭Selinux和Iptables<br>2、两台服务器时间要同步<br>3、两台服务器都要启动中继日志，二进制日志<br>4、主服务器1: 192.168.1.60<br>      主服务器2：192.168.1.61</p><h2 id="安装Mariadb"><a href="#安装Mariadb" class="headerlink" title="安装Mariadb"></a><strong>安装Mariadb</strong></h2><p>[root@mysql-masster1 /]# yum -y install mariadb-server mariadb<br>第二台服务器一样直接安装</p><h2 id="修改主配置文件"><a href="#修改主配置文件" class="headerlink" title=" 修改主配置文件"></a><strong> 修改主配置文件</strong></h2><pre><code>Master1配置：[root@mysql-masster1 /]# vim /etc/my.cnf[mysqld]server_id=1       ##设定全局唯一的server_idlog_bin=master-log      ##启用二进制日志，指明二进制日志的存放路径及名称relay_log=relay-log    ##启用中继日志，指明中继日志的存放路径及名称    auto_increment_offset=1    ##避免自增长字段的冲突值，设置本机的自增长字段从1开始，每次增长2auto_increment_increment=2    skip-name-resolve=ON     ##禁止名称解析innodb-file-per-table=ON   ##innodb存储引擎每表一个表空间Master2配置：[root@mysql-masster2 /]# vim /etc/my.cnf[mysqld]server_id=2    ##设定全局唯一的server_idlog-bin=master-log  ##启用二进制日志，指明二进制日志的存放路径及名称    relay-log=relay-log  ##启用中继日志，指明中继日志的存放路径及名称auto_increment_offset=2  ##避免自增长字段的冲突值，设置本机的自增长字段从1开始，每次增长2auto_increment_increment=2skip-name-resolve=ON     ##禁止名称解析innodb-file-per-table=ON  ##innodb存储引擎每表一个表空间**Master1和Master2配置完成后，重新启动mariadb服务**</code></pre><h2 id="登录MySQL用户授权"><a href="#登录MySQL用户授权" class="headerlink" title="登录MySQL用户授权"></a><strong>登录MySQL用户授权</strong></h2><pre><code>Master1配置：[root@mysql-masster1 /]#mysql -uroot -p MariaDB [mysql]&gt; grant replication client,replication slave on *.* to &apos;repluser&apos;@&apos;192.168.1.61&apos; identified by &apos;redhat&apos;;  MariaDB [mysql]&gt; flush privileges;MariaDB [mysql]&gt; show master logs;  ##查看二进制日志列表和当前正在使用的二进制日志的文件位置MariaDB [mysql]&gt; show master status; +-------------------+----------+--------------+------------------+ | File              | Position | Binlog_Do_DB | Binlog_Ignore_DB | +-------------------+----------+--------------+------------------+ | master-log.000001 |   245|   |              |                  |  +-------------------+----------+--------------+------------------+    MariaDB [mysql]&gt; ls /var/lib/mysql/ 查询二进制文件是否存在Master2配置：[root@mysql-masster2 /]#mysql -uroot -p MariaDB [mysql]&gt; grant replication client,replication slave on *.* to &apos;repluser&apos;@&apos;192.168.1.60&apos; identified by &apos;redhat&apos;;MariaDB [mysql]&gt; flush privileges;MariaDB [mysql]&gt; show master logs;MariaDB [mysql]&gt; show master status;+-------------------+----------+--------------+------------------+| File              | Position | Binlog_Do_DB | Binlog_Ignore_DB |+-------------------+----------+--------------+------------------+| master-log.000003 |     2109 |              |                  |+-------------------+----------+--------------+------------------+MariaDB [mysql]&gt; ls /var/lib/mysql/</code></pre><h2 id="定义2个节点"><a href="#定义2个节点" class="headerlink" title="定义2个节点"></a><strong>定义2个节点</strong></h2><pre><code> 在两个节点上定义复制时的属性，启动复制线程  Master1的配置：      MariaDB [mysql]&gt; change master to                                  master_host=&apos;192.168.1.61&apos;,    ##指定的Master主机                 master_user=&apos;repluser&apos;,            ##以哪个用户的身份练上去             master_password=&apos;redhat&apos;,       ##连接用户的密码             master_log_file=&apos;master-log.000003&apos;,      ##主节点的二进制日志文件             master_log_pos=2109;    ##主节点的二进制日志所在位置Master2的配置：change master to master_host=&apos;192.168.1.60&apos;,master_user=&apos;repluser&apos;,master_password=&apos;redhat&apos;,master_log_file=&apos;master-log.000001&apos;,master_log_pos=245;</code></pre><h2 id="启动复制线程"><a href="#启动复制线程" class="headerlink" title="启动复制线程    "></a><strong>启动复制线程    </strong></h2><pre><code>[root@mysql-masster2 /]#mysql -uroot -p MariaDB [mysql]&gt;start slave; ##启动复制线程MariaDB [mysql]&gt;show salve status;             Slave_IO_Running:YES  ##IO线程和SQL线程Slave_SQL_Running:YES两个线程都是YES，表明成功了，如果IO线程状态是Connecting 请退出MySQL，这个地方稍微有点延迟,重新启动一下mariadb服务，再连进去查看线程状态</code></pre><h2 id="双主服务器互相验证"><a href="#双主服务器互相验证" class="headerlink" title="双主服务器互相验证"></a><strong>双主服务器互相验证</strong></h2><p>在Master1上创建一个testdb库，看Master2能否看见。<br>Master2在testdb库中创建t1表，Master1能看见表明成功<br>Master1在t1插入数据，Master能看见表示成功</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Mysql&lt;/strong&gt;双主模型可以在一定程度上保证主库的高可用,在一台主库down掉之后,可以在极短的时间内切换到另一台主库上（尽可能减少主库宕机对业务造成的影响），减少了主从同步给线上主库带来的压力；
    
    </summary>
    
      <category term="Mysql" scheme="http://zhuwenbing.top/categories/Mysql/"/>
    
    
      <category term="Mysql双主模型" scheme="http://zhuwenbing.top/tags/Mysql%E5%8F%8C%E4%B8%BB%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 LB集群之LVS（一）</title>
    <link href="http://zhuwenbing.top/2018/03/27/LVS+NAT/"/>
    <id>http://zhuwenbing.top/2018/03/27/LVS+NAT/</id>
    <published>2018-03-27T05:22:38.517Z</published>
    <updated>2017-09-26T03:23:30.659Z</updated>
    
    <content type="html"><![CDATA[<p><strong>LVS</strong>(linux virtue server)是一个虚拟的服务器集群系统。项目在1998年5月由章文嵩成立，是中国国内最早出现的自由软件项目之一。<br>LVS集群采用IP负载均衡技术和基于内容请求分发技术。调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。整个服务器集群的结构对客户是透明的，而且无需修改客户端和服务器端的程序。为此，在设计时需要考虑系统的透明性、可伸缩性、高可用性和易管理性。<a id="more"></a></p><p><strong>目的</strong>：利用LVS实现负载均衡</p><p>模型图：<br><img src="http://i.imgur.com/2tSFs0K.jpg" alt=""></p><h2 id="配置IP"><a href="#配置IP" class="headerlink" title="配置IP"></a><strong>配置IP</strong></h2><p>lvs eth0： 192.168.1.103（VIP）<br>    eth1： 192.168.201.138（DIP）<br>web1 eth0：192.168.201.137<br>       lo：192.168.201.103<br>web2 eth0：192.168.201.132<br>    lo ：192.168.201.103 </p><h2 id="安装http服务"><a href="#安装http服务" class="headerlink" title="安装http服务"></a><strong>安装http服务</strong></h2><p>[root@WEB1 ~]# yum -y install httpd<br>[root@WEB1 ~]# systemctl enable http.service<br>[root@WEB1 ~]# systemctl start  http.service<br>[root@WEB1 ~]# echo “1” &gt;/var/www/html/index.html<br>[root@WEB1 ~]# curl <a href="http://localhost" target="_blank" rel="external">http://localhost</a><br>WEB2同上</p><h2 id="安装ipvsadm"><a href="#安装ipvsadm" class="headerlink" title="安装ipvsadm"></a><strong>安装ipvsadm</strong></h2><p>[root@WEB1 ~]# yum -y install ipvsadm<br>[root@WEB1 ~]# modprobe ip_vs  #加载到内核<br>[root@WEB1 ~]# ipvsadm         #查看是否安装成功</p><h2 id="配置IPVS"><a href="#配置IPVS" class="headerlink" title="配置IPVS"></a><strong>配置IPVS</strong></h2><p>[root@WEB1 ~]#ipvsadm -C 清空原来表格内容<br>[root@WEB1 ~]# ipvsadm -A -t 192.168.1.103:80 -s rr #创建一个集群<br>  -A添加地址 -t指定vip tcp端口 -s指定算法<br>[root@WEB1 ~]# ipvsadm -a -t 192.168.1.103:80 -r 192.168.201.137:80 -m<br>  -a指定真实服务器 -t lvs上的vip -r 真实服务器<br>[root@WEB1 ~]# ipvsadm -a -t 192.168.1.103:80 -r 192.168.201.132:80 -m<br>  -a指定真实服务器 -t lvs上的vip -r 真实服务器<br>[root@WEB1 ~]# ipvsadm -L -n 查看<br>IP Virtual Server version 1.2.1(size=4096)<br>Prot LocalAddress:PortScheduler Flags<br>-&gt; RemoteAddress:Port Forward Weight ActiveConn InActConn<br>TCP 192.168.1.103 wrr persistent 20<br>-&gt; 192.168.201.137 Route 1 0 0<br>-&gt; 192.168.201.132 Route 1 0 0 </p><p>…表示成功了</p><h2 id="配置RS"><a href="#配置RS" class="headerlink" title="配置RS"></a><strong>配置RS</strong></h2><p>给WEB1服务器配置VIP<br>ifconfig lo 192.168.1.103 netmask 255.255.255.255<br>WEB2设置同上</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h2><p>浏览器输入VIP地址 192.168.1.103<br>看WEB1和WEB2是不是轮询响应，down掉一个还能否响应</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;LVS&lt;/strong&gt;(linux virtue server)是一个虚拟的服务器集群系统。项目在1998年5月由章文嵩成立，是中国国内最早出现的自由软件项目之一。&lt;br&gt;LVS集群采用IP负载均衡技术和基于内容请求分发技术。调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。整个服务器集群的结构对客户是透明的，而且无需修改客户端和服务器端的程序。为此，在设计时需要考虑系统的透明性、可伸缩性、高可用性和易管理性。
    
    </summary>
    
      <category term="Cluster" scheme="http://zhuwenbing.top/categories/Cluster/"/>
    
    
      <category term="Lvs+NAT" scheme="http://zhuwenbing.top/tags/Lvs-NAT/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 Mysql主从同步</title>
    <link href="http://zhuwenbing.top/2018/03/27/Mysql-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
    <id>http://zhuwenbing.top/2018/03/27/Mysql-主从同步/</id>
    <published>2018-03-27T05:22:38.517Z</published>
    <updated>2017-04-25T09:51:14.801Z</updated>
    
    <content type="html"><![CDATA[<p><strong>MySQL主从同步</strong>：MySQL的主从复制广泛用于数据库备份、故障转移、数据分析等场合<br>主从同步原理*：<br>通过设置在Master MySQL上的binlog(使其处于打开状态)，Slave MySQL上通过一个I/O线程从Master MySQL上读取binlog，再传输到Slave MySQL的中继日志中，<a id="more"></a>然后Slave MySQL的SQL线程从中继日志中读取中继日志，应用到Slave MySQL的数据库中。这样实现了主从数据同步功能。</p><p><strong>目的：主从复制能够有效的缓解数据库读写的压力</strong></p><p>模型图（图片来源于网络）：<br><img src="http://i.imgur.com/ZMwq5kZ.jpg" alt=""></p><h2 id="环境的准备"><a href="#环境的准备" class="headerlink" title="环境的准备"></a><strong>环境的准备</strong></h2><pre><code>1.Mysql主备之前版本必须一致2.为了不影响实验结果建议关闭&apos;Selinux&apos; 主服务器：mysql-master: 192.168.1.60从服务器：mysql_slave:  192.168.1.61</code></pre><p><strong>安装Mariadb</strong></p><pre><code>[root@mysql-master /]yum -y install mariadb mariadb-server [root@mysql-master /]systemctl enable mariadb.service      ##开机启动mariadb服务  [root@mysql-master /]systemctl start  mariadb.service      ##启动mariadb服务  [root@mysql-master /]mysql_secure_installation            ##初始化Mysql从服务器同上操作</code></pre><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a><strong>修改配置文件</strong></h2><pre><code>主服务器的配置文件（/etc/my.cnf）,开启日志功能，设置server_id 保证唯一[root@mysql-master tmp]# vim /etc/my.cnf加入以下两行内容[mysqld]server_id = 200      ##server_id 同步复制时标识该语句最初是从哪个server写入的log-bin=mysql-bin  ##开启二进制功能 保存退出，重启服务器</code></pre><h2 id="数据库授权"><a href="#数据库授权" class="headerlink" title="数据库授权"></a><strong>数据库授权</strong></h2><pre><code>[root@mysql-master /]# mysqldump -uroot -pMariaDB [mysql]&gt; grant replication slave,reload,super on *.* to &apos;slave&apos;@&apos;192.168.1.60&apos; identified by &apos;slavepass&apos;  MariaDB [mysql]&gt;flush privileges  ##重读授权表信息 注释：‘replication slave’拥有此权限可以查看从服务器，从主服务器读取二进制日志 ‘reload’权限，才可以执行flush [tables | logs | privileges]‘super’这个权限允许用户终止任何查询；修改全局变量的SET语句；使用CHANGE MASTER，PURGE MASTER LOGS。 MariaDB [mysql]&gt;show master status; ##查看主服务的状态  +----------------------+----------+--------------+------------------+ | File                 | Position | Binlog_Do_DB | Binlog_Ignore_DB | +----------------------+----------+--------------+------------------+ | mysql-bin.000002      |      245|              |                  | +----------------------+----------+--------------+------------------+</code></pre><h2 id="主从备份"><a href="#主从备份" class="headerlink" title="主从备份"></a><strong>主从备份</strong></h2><pre><code>为保证主DB server和从DB server的数据一致,这里采用主备份,从还原来实现初始数据一致MariaDB [mysql]&gt;flush tables with read lock;    ##加临时锁，表只读[root@mysql-master /]# mysqldump -uroot -p --all-   databases &gt; /home/backup.sql   ##复制所有数据库到/home/[root@mysql-master /]# unlock tables;  J##解锁[root@mysql-master /]# scp /home/backup.sql ‘root’@‘192.168.1.61’：/home/ ##将备份数据发送到从服务器，用于恢复</code></pre><h2 id="配置Slave"><a href="#配置Slave" class="headerlink" title="配置Slave"></a><strong>配置Slave</strong></h2><pre><code>[root@mysql-slave /]# vim /etc/my.cnf server_id=201 ##设置server_id</code></pre><h2 id="Slave还原备份数据"><a href="#Slave还原备份数据" class="headerlink" title="Slave还原备份数据"></a><strong>Slave还原备份数据</strong></h2><pre><code>[root@mysql-slave /]#systemctl restart mariadb.service[root@mysql-slave /]#mysql -uroot -p &lt; /home/backup.sql</code></pre><h2 id="连接Master服务器"><a href="#连接Master服务器" class="headerlink" title="连接Master服务器"></a><strong>连接Master服务器</strong></h2><pre><code>登陆从数据库,添加相关参数(主服务器的ip/端口/同步用户/密码/position号/读取哪个日志文件)[root@mysql-slave /]#mysql -uroot -pMariaDB [mysql]&gt;change master to master_host=&apos;192.168.1.60&apos;,master_user=&apos;slave&apos;,master_password=&apos;slavepass&apos;,        master_log_file=&apos;mysql-bin.000002&apos;,master_log_pos=245;     ##开启主从同步MariaDB [mysql]&gt;start slave;  ##查看主动同步状态MariaDB [mysql]&gt;show slave status\G; ##主要看下面2项，都是YES表示成功了Slave_IO_Running: YesSlave_SQL_Running: Yes</code></pre><h2 id="Master和Slave验证"><a href="#Master和Slave验证" class="headerlink" title="Master和Slave验证"></a><strong>Master和Slave验证</strong></h2><p>上面都没问题，那就开始测试了，去主服务断创建一个库，一张表，插入数据，再到从服务器来查看，如果数据一致表示没问题了</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a><strong>遇到的问题</strong></h2><pre><code>ERROR 2002 (HY000): Can&apos;t connect to local MySQL server through socket &apos;/tmp/mysql.sock&apos; (2) ####解决办法：在错误日志中，启动失败的原因极为明显，file ‘./mysql-bin。000004’ not found，failed to open！mysql开启了bin日志功能，到数据库根目录查看该文件是存在的，可能是文件权限的问题。[root@mysql-slave /]chown -R mysql:mysql /var/log/mysql[root@mysql-slave /]mysqld_safe &amp;     ##启动安全模式[root@mysql-slave /]systemctl stop mariadb.service[root@mysql-slave /]systemctl start mariadb.service###再重新初始化数据库，就可以登录了记得killall mysqld_safe mysql，因为不结束将不能开启二进制日志，结束安全模式进程然后[root@mysql-slave /]systemctl stop mariadb.service[root@mysql-slave /]systemctl start mariadb.service</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;MySQL主从同步&lt;/strong&gt;：MySQL的主从复制广泛用于数据库备份、故障转移、数据分析等场合&lt;br&gt;主从同步原理*：&lt;br&gt;通过设置在Master MySQL上的binlog(使其处于打开状态)，Slave MySQL上通过一个I/O线程从Master MySQL上读取binlog，再传输到Slave MySQL的中继日志中，
    
    </summary>
    
      <category term="Mysql" scheme="http://zhuwenbing.top/categories/Mysql/"/>
    
    
      <category term="Mysql主从同步" scheme="http://zhuwenbing.top/tags/Mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 LVS集群+Keepalived（二）</title>
    <link href="http://zhuwenbing.top/2018/03/27/LVS+Keepalived/"/>
    <id>http://zhuwenbing.top/2018/03/27/LVS+Keepalived/</id>
    <published>2018-03-27T05:22:38.502Z</published>
    <updated>2017-04-25T09:52:28.287Z</updated>
    
    <content type="html"><![CDATA[<p><strong>LVS</strong>是Linux Virtual Server的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统。本项目在1998年5月由章文嵩博士成立，是中国国内最早出现的自由软件项目之一。目前有三种IP负载均衡技术（NAT、DR、TUN），十种调度算法（rr|wrr|lc|wlc|lblc|lblcr|dh|sh|sed|nq）<a id="more"></a><br><strong>Keepalived</strong>在这里主要用作RealServer的健康状态检查以及Master主机和BackUP主机之间failover的实现下面，搭建基于LVS+Keepalived的高可用负载均衡集群，其中，LVS实现负载均衡，但是，简单的LVS不能监控后端节点是否健康，它只是基于具体的调度算法对后端服务节点进行访问。同时，单一的LVS又存在单点故障的风险。在这里，引进了Keepalived，可以实现以下几个功能：1. 检测后端节点是否健康2. 实现LVS本身的高可用</p><p><strong>目的：解决DR模型下Director单点故障</strong></p><p>模型图：<br><img src="http://i.imgur.com/XVzk8Wc.jpg" alt=""></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作:"></a><strong>准备工作:</strong></h2><pre><code>DR1:          vip :192.168.1.150  eno16777736:192.168.1.130     DR2 :             vip :192.168.1.150    eno16777736:192.168.1.131        RS1:    eno16777736:192.168.1.132    lo:192.168.1.150   netmask 255.255.255.255   ##4个255表示将广播域限制在本机RS2:    eno16777736:192.168.1.133    lo:192.168.1.150 netmask 255.255.255.255</code></pre><p>网络配置完成后都互相ping一下，看是不是都配通了</p><p>注意问题：<br>1.清空iptables规则 iptables  -t filter -F<br>2.关闭selinux  setenforce 0 </p><h2 id="安装httpd"><a href="#安装httpd" class="headerlink" title="安装httpd"></a><strong>安装httpd</strong></h2><pre><code>yum -y install httpdsystemctl enable httpd.service 开启启动httpd服务systemctl start  httpd.service 启动服务echo “WEB1”&gt;/var/www/html/index.html  在httpd下写一个测试网页curl http://localhost 测试一下看能不能看到“WEB1”  配置完后把VIP指向RS1ifconfig lo 192.168.1.150 netmask 255.255.255.0 【DR2】配置同上RS服务器上也要关闭防火墙，关闭selinux</code></pre><h2 id="安装ipvs"><a href="#安装ipvs" class="headerlink" title="安装ipvs"></a><strong>安装ipvs</strong></h2><pre><code>yum -y install ipvsadm modprobe ip_vs  #加载到内核 lsmod |grep ip_vs #查看是否有ipvs模块  【DR2】上同上配置</code></pre><h2 id="安装keepalived"><a href="#安装keepalived" class="headerlink" title="安装keepalived"></a><strong>安装keepalived</strong></h2><pre><code>yum -y install keepalived   systemctl enable keepalived 开机启动   systemctl start  keepalived 启动程序     yum -y install httpd ##这里装httpd做Server—server   echo &lt;h1System upgrade maintenance &lt;\h1&gt;/var/www/html/index.html  systemctl start httpd        </code></pre><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置:"></a><strong>修改配置</strong>:</h2><pre><code>vim /etc/keepalived/keepalived.conf配置文件如下：global_defs {notification_email {acassen@firewall.loc #设置报警邮件地址，可设置多个，每行一个failover@firewall.loc #需要开启右键报警以及本机的sendmail服务sysadmin@firewall.loc}notification_email_from Alexandre.Cassen@firewall.locsmtp_server 127.0.0.1  #设置SMTP Server地址smtp_connect_timeout 30router_id LVS_DEVEL}vrrp_instance VI_1 {state MASTER   #指定keepalived的角色，MASTER为主服务器，BACKUP为备用服务器interface eno16777736virtual_router_id 50priority 100 #定义优先级，数字越大，优先级越高，主Direvtor必须大于备用Directoradvert_int 1authentication {    auth_type PASS  #设置验证类型    auth_pass 1111  #设置验证密码,最好随机生成几位数字}virtual_ipaddress {  192.168.1.150    #设置主Director的VIP}virtual_server 192.168.1.150  80 { 设置VIP地址和端口 用空格隔开delay_loop 6     #设置健康检查时间，单位为秒lb_algo rr          #设置负载均衡调度算法，默认为rr，即轮循算法，最优秀的是wlc算法lb_kind DR        #设置LVS实现LB机制，有NAT,DR,TUN三种模式nat_mask 255.255.255.0persistence_timeout 50 #回话保持时间，单位为秒protocol TCP       #指定转发协议类型，有TCP和UDP两种real_server 192.168.1.132 80 {    weight 2    #配置节点权值，数字越大权值越高HTTP[_GET {       url {         path /          digest ff20ad2481f97b1754ef3e12ecd3a9cc        }        url {         path /mrtg/          digest 9b3a0c85a887a256d6939da88aabd8cd    connect_timeout 3        #表示3秒无响应，则超时        nb_get_retry 3        #表示重试次数        delay_before_retry 3    #表示重试间隔sorry_server 127.0.0.1 80  ##所有节点都down掉了，  soory_server可以当real_server使用，或者定义升级维护页面real_server 192.168.1.113 80 {    weight 1 # HTTP_GET {    #    url {      #    path /     #     digest ff20ad2481f97b1754ef3e12ecd3a9cc       # }        #url {         # path /mrtg/          #digest 9b3a0c85a887a256d6939da88aabd8cd       # }        connect_timeout 3        nb_get_retry 3        delay_before_retry 3        }}【DR2】配置大致同上，只需修改部分参数    1. 把state MASTER 改为 state BACKUP     2. 把priority 100 的优先值改成90然后保存即可</code></pre><h2 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a><strong>重启服务</strong></h2><pre><code>systemctl restart keepalived.service[DR1]#ipvsadm -L -n  出现以下信息表示配置成功，没有就返回上一步排错   IP Virtual Server version 1.2.1 (size=4096)   Prot LocalAddress:Port Scheduler Flags  -RemoteAddress:Port           Forward Weight   ActiveConn InActConn  TCP  192.168.1.150:80 rr persistent 50  -192.168.1.113:80             Route   1      0          0            -192.168.1.132:80             Route   2      0          0</code></pre><h2 id="抑制ARP响应"><a href="#抑制ARP响应" class="headerlink" title="抑制ARP响应"></a><strong>抑制ARP响应</strong></h2><pre><code>（防止将后端Real Server暴露在公网） 【DR1】# echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore   【DR1】# echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/lo/ arp_announce   【DR1】# echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignore   【DR1】# echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announcearp响应限制:   1）arp_ignore:    0 - (默认值): 回应任何网络接口上对任何本地IP地址的arp查询请求     1 - 只回答目标IP地址是来访网络接口本地地址的ARP查询请求   2）arp_announce:        0 - (默认) 在任意网络接口（eth0,eth1，lo）上的任何本地地址            2 - 对查询目标使用最适当的本地地址.在此模式下将忽略这个IP数据包的源地址并尝试选择与能与该地址通信的本地地址.        首要是选择所有的网络接口的子网中外出访问子网中包含该目标IP地址的本地地址.         如果没有合适的地址被发现,将选择当前的发送网络接口或其他的有可能接受到该ARP回应的网络接口来进行发送.</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h2><p>DR1和DR2上把keepalived服务都启动起来<br>systemctl keepalived status 查看服务当前状况<br>在浏览器输入“192.168.1.150” 看能否看到“WEB1”和“WEB2”<br>将DR2关掉看能否访问到“192.168.1.150”<br>还能看到“WEB1”“WEB2”<br>恭喜你 成功了！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;LVS&lt;/strong&gt;是Linux Virtual Server的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统。本项目在1998年5月由章文嵩博士成立，是中国国内最早出现的自由软件项目之一。目前有三种IP负载均衡技术（NAT、DR、TUN），十种调度算法（rr|wrr|lc|wlc|lblc|lblcr|dh|sh|sed|nq）
    
    </summary>
    
      <category term="Cluster" scheme="http://zhuwenbing.top/categories/Cluster/"/>
    
    
      <category term="Lvs+Keepalived" scheme="http://zhuwenbing.top/tags/Lvs-Keepalived/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 LAMP黄金组合之wordpress</title>
    <link href="http://zhuwenbing.top/2018/03/27/lamp+weordpress/"/>
    <id>http://zhuwenbing.top/2018/03/27/lamp+weordpress/</id>
    <published>2018-03-27T05:22:38.470Z</published>
    <updated>2017-09-26T03:18:32.366Z</updated>
    
    <content type="html"><![CDATA[<p>WordPress是一个注重美学、易用性和网络标准的个人信息发布平台。WordPress虽为免费的开源软件，但其价值无法用金钱来衡量。WordPress的图形设计在性能上易于操作、易于浏览；在外观上优雅大方、风格清新、色彩诱人。<br>使用WordPress可以搭建功能强大的网络信息发布平台，但更多的是应用于个性化的博客。针对博客的应用，WordPress能让您省却对后台技术的担心，集中精力做好网站的内容。<br><a id="more"></a><br><strong>目的：LAMP搭建wordpress博客</strong></p><pre><code>准备工作：1.上来先关闭防火墙 iptables -F2.ping以下网络是否通畅 ping www.baidu.com</code></pre><h2 id="安装Httpd"><a href="#安装Httpd" class="headerlink" title="安装Httpd"></a><strong>安装Httpd</strong></h2><pre><code>[root@wp ~]# yum -y install httpd[root@wp ~]# systemctl start  httpd.service   #启动httpd防火墙放行80端口以及http服务[root@wp ~]#firewell-cmd --permanent --add-service=http[root@wp ~]#fireewll-cmd --reload      #重启防火墙生效地址栏输入http://localhost 能看到apche测试页面即成功</code></pre><h2 id="安装mariadb"><a href="#安装mariadb" class="headerlink" title="安装mariadb"></a><strong>安装mariadb</strong></h2><pre><code>[root@wp ~]# yum -y install mariadb mariadb-server[root@wp ~]# systemctl enabled mariadb.service      #开机启动mysql[root@wp ~]# systemctl start mariadb.service      #启动mysql初始化mysql并设置密码：[root@wp ~]# mysql_secure_installation Enter current password for root (enter for none): #初次运行直接回车Set root password? [Y/n]  #是否设置root用户密码，输入y并回车或直接回车New password: #设置root用户的密码Re-enter new password: #再输入一次你设置的密码Remove anonymous users? [Y/n]  #是否删除匿名用户，回车Disallow root login remotely? [Y/n] #是否禁止root远程登录 ,回车,Remove test database and access to it? [Y/n] # 是否删除test数据库,回车Reload privilege tables now? [Y/n] #是否重新加载权限表，回车始化MariaDB完成，接下来测试登录 root@wp ~]# mysql -u root -p  #登录mysql </code></pre><h2 id="安装php"><a href="#安装php" class="headerlink" title="安装php"></a><strong>安装php</strong></h2><pre><code>[root@wp ~]# yum install php php-mysql php-gd libjpeg* php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-bcmath php-mhash[root@wp ~]# vim /var/www/html/index.php&lt;?phpphpinfo();?&gt;保存退出！  systemctl restart httpd.service  浏览器地址栏输入http://localhost 能看到php测试页面即成功</code></pre><h2 id="配置wordpress"><a href="#配置wordpress" class="headerlink" title="配置wordpress"></a><strong>配置wordpress</strong></h2><pre><code>进入wordpress目录  [root@wp ~]# cd /wordpress[root@wp ~]# cp wp-config-sample.php wp-config.php   #复制主配置文并改名为wp-config.php开始配置wp-config.php[root@wp ~]# vim wp-config.php/ ** MySQL settings - You can get this info from your web host ** ///** The name of the database for WordPress */define(&apos;DB_NAME&apos;, &apos;wordpressdb&apos;); #数据库名称/** MySQL database username */ #数据库用户名define(&apos;DB_USER&apos;, &apos;wordpressuser&apos;);/** MySQL database password */ #数据库密码define(&apos;DB_PASSWORD&apos;, &apos;wordpresspassword&apos;);wq保存退出配置完成后将wordpress目录下所有文件移动到/var/www/html下chown -R apache:apache /var/www/html/chmod -R 755 /var/www/html</code></pre><h2 id="mysql授权配置"><a href="#mysql授权配置" class="headerlink" title="mysql授权配置"></a><strong>mysql授权配置</strong></h2><pre><code>[root@wp ~]# mysql -u root -pMariaDB [mysql]&gt; create database  wordpressdb;  #（创建库）MariaDB [mysql]&gt; create user wordpressuser@localhost identified by &apos;wordpresspassword&apos;;  #（创建用户并设置密码）MariaDB [mysql]&gt; grant all privileges on  wordpressdb.* to wordpressuser@localhost;  #(给wordpressuser对wordpress授取所有权) MariaDB [mysql]&gt; flush privileges;    #（重读数据库变量）配置完重启服务:MariaDB [mysql]&gt; service httpd restartMariaDB [mysql]&gt; service  mariadb restart#我一般不喜欢用Phpmyadmin，直接用Navicat</code></pre><h2 id="配置Wordpress"><a href="#配置Wordpress" class="headerlink" title="配置Wordpress"></a><strong>配置Wordpress</strong></h2><p>浏览器地址栏输入<a href="http://localhost" target="_blank" rel="external">http://localhost</a><br>配置成功后应该是这个样子的，主题相关参数自行配置，<br>是不是很时尚，wordpress有很多时尚的主题自己选择一个安装吧吧<br><img src="http://i.imgur.com/VPlfHLE.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WordPress是一个注重美学、易用性和网络标准的个人信息发布平台。WordPress虽为免费的开源软件，但其价值无法用金钱来衡量。WordPress的图形设计在性能上易于操作、易于浏览；在外观上优雅大方、风格清新、色彩诱人。&lt;br&gt;使用WordPress可以搭建功能强大的网络信息发布平台，但更多的是应用于个性化的博客。针对博客的应用，WordPress能让您省却对后台技术的担心，集中精力做好网站的内容。&lt;br&gt;
    
    </summary>
    
      <category term="Web" scheme="http://zhuwenbing.top/categories/Web/"/>
    
    
      <category term="LAMP+Wordpress" scheme="http://zhuwenbing.top/tags/LAMP-Wordpress/"/>
    
  </entry>
  
</feed>
