<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python Psutil模块用法]]></title>
    <url>%2F2020%2F05%2F26%2Fpsutil%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[psutil是一个跨平台库(https://psutil.readthedocs.io/en/latest/) 能够轻松实现获取系统运行的进程和系统利用率（包括CPU、内存、磁盘、网络等）信息。它主要用来做系统监控，性能分析，进程管理。它实现了同等命令行工具提供的功能，如ps、top、lsof、netstat、ifconfig、who、df、kill、free、nice、ionice、iostat、iotop、uptime、pidof、tty、taskset、pmap等。目前支持32位和64位的Linux、Windows、OS X、FreeBSD和Sun Solaris 等操作系统. 一、安装Linux安装: [root@instance-9 ~]# install gcc python3-dev [root@instance-9 ~]# pip3 install psutil Windows安装： D:\&gt; pip install psutil 二、查看当前用户相关信息&gt;&gt;&gt; import psutil &gt;&gt;&gt; psutil.users() [suser(name=&apos;zane4649&apos;, terminal=&apos;pts/6&apos;, host=&apos;192.168.31.101&apos;, started=1590479232.0, pid=15216)] &gt;&gt;&gt; 三、当前系统启动时间 &gt;&gt;&gt; psutil.boot_time() 1581935267.0 &gt;&gt;&gt; 四、查看内存大小&gt;&gt;&gt; psutil.virtual_memory().total 615329792 字节显示看着不舒服 &gt;&gt;&gt; &gt;&gt;&gt; mem_info = psutil.virtual_memory() &gt;&gt;&gt; mem_info.total 615329792 &gt;&gt;&gt; mem_info.used 178503680 &gt;&gt;&gt; mem_info.free 278347776 &gt;&gt;&gt; 五、查看swap空间&gt;&gt;&gt; psutil.swap_memory() sswap(total=0, used=0, free=0, percent=0.0, sin=0, sout=0) &gt;&gt;&gt; 六、获取cpu核心数&gt;&gt;&gt; psutil.cpu_count() 1 &gt;&gt;&gt; 七、获取cpu物理核心数&gt;&gt;&gt; psutil.cpu_count(logical=False) 1 &gt;&gt;&gt; 八、查看cpu使用率&gt;&gt;&gt; psutil.cpu_percent(interval=1, percpu=True) 0.4 &gt;&gt;&gt; 九、查看cpu空闲情况&gt;&gt;&gt; psutil.cpu_times() scputimes(user=110763.46, nice=294.71, system=171144.99, idle=7235852.97, iowait=1103.63, irq=0.0, softirq=173.03, steal=0.0, guest=0.0, guest_nice=0.0) &gt;&gt;&gt; 十、查看cpu平均使用率for i in range(10): stats = psutil.cpu_percent(interval = 1, percpu = True) print(stats) 十一、查看磁盘分区&gt;&gt;&gt; len(psutil.disk_partitions()) 1 &gt;&gt;&gt; 十二、查看磁盘使用率 &gt;&gt;&gt; psutil.disk_usage(&apos;/&apos;) sdiskusage(total=10725883904, used=3042398208, free=7683485696, percent=28.4) &gt;&gt;&gt; 十三、查看IO使用率 &gt;&gt;&gt; psutil.disk_io_counters() sdiskio(read_count=1267423, write_count=2259240, read_bytes=43593847296, write_bytes=32287985664, read_time=12220244, write_time=22429833, read_merged_count=6235, write_merged_count=439942, busy_time=5365109 &gt;&gt;&gt; 十三、获取网络读写字节个数 &gt;&gt;&gt; psutil.net_io_counters() snetio(bytes_sent=75090284050, bytes_recv=60619202739, packets_sent=53111418, packets_recv=65103399, errin=0, errout=0, dropin=0, dropout=0) &gt;&gt;&gt; 十四、查看网络接口状态 &gt;&gt;&gt; psutil.net_if_stats() {&apos;eth0&apos;: snicstats(isup=True, duplex=&lt;NicDuplex.NIC_DUPLEX_UNKNOWN: 0&gt;, speed=65535, mtu=1460), &apos;lo&apos;: snicstats(isup=True, duplex=&lt;NicDuplex.NIC_DUPLEX_UNKNOWN: 0&gt;, speed=0, mtu=65536)} &gt;&gt;&gt; 十五、查看网络接口信息 &gt;&gt;&gt; psutil.net_if_addrs() {&apos;lo&apos;: [snicaddr(family=&lt;AddressFamily.AF_INET: 2&gt;, address=&apos;127.0.0.1&apos;, netmask=&apos;255.0.0.0&apos;, broadcast=None, ptp=None), snicaddr(family=&lt;AddressFamily.AF_INET6: 10&gt;, address=&apos;::1&apos;, netmask=&apos;ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff&apos;, broadcast=None, ptp=None), snicaddr(family=&lt;AddressFamily.AF_PACKET: 17&gt;, address=&apos;00:00:00:00:00:00&apos;, netmask=None, broadcast=None, ptp=None)], &apos;eth0&apos;: [snicaddr(family=&lt;AddressFamily.AF_INET: 2&gt;, address=&apos;10.170.0.3&apos;, netmask=&apos;255.255.255.255&apos;, &gt;&gt;&gt; 十六、查看网络连接信息 &gt;&gt;&gt; psutil.net_connections() [sconn(fd=-1, family=&lt;AddressFamily.AF_INET: 2&gt;, type=&lt;SocketKind.SOCK_DGRAM: 2&gt;, laddr=addr(ip=&apos;0.0.0.0&apos;, port=5050), raddr=(), status=&apos;NONE&apos;, pid=7288), sconn(fd=-1, family=&lt;AddressFamily.AF_INET6: 23&gt;, type=&lt;SocketKind.SOCK_DGRAM: 2&gt;, laddr=addr(ip=&apos;::&apos;, port=5353), raddr=(), status=&apos;NONE&apos;, pid=12872), sconn(fd=-1, family=&lt;AddressFamily.AF_INET6: 23&gt;, type=&lt;SocketKind.SOCK_DGRAM: 2&gt;, laddr=addr(ip=&apos;::&apos;, port=3702), raddr=(), status=&apos;NONE&apos;, pid=2308), sconn(fd=-1, family=&lt;AddressFamily.AF_INET: 2&gt; 十八、查看pid相关 psutil.pids() #获取所有进程PID psutil.test() #列出所有进程信息，类似top命令 psutil.pid_exists(29306) #判断进程是否存在 p = psutil.Process(1160) #查看1160进程的信息 print(p.name()) #查看进程的名称 print(p.exe()) #查看exe进程的路径 print(p.cwd()) #进程工作目录 print(p.cmdline()) #进程启动的命令行 print(p.ppid()) #父进程ID print(p.parent()) #查看父进程 print(p.children()) #查看子进程列表 print(p.status())#查看进程的状态 print(p.username()) #查看进程运行的用户 print(p.create_time()) #查看进程运行的时间 print(p.cpu_times()) #查看进程使用cpu信息 print(p.memory_info()) #进程使用内存信息 print(p.open_files()) #进程打开的文件 print(p.connections()) #进程的网络连接 print(p.num_threads()) #进程的线程数量 print(p.threads()) #进程的所有线程信息 print(p.environ()) #进程的环境变量 print(p.kill()) #kill当前进程 十九、列出所有进程 for pids in psutil.process_iter([&apos;pid&apos;, &apos;name&apos;]): print(pids.info) 二十、其他 from subprocess import PIPE p = psutil.Popen([&apos;D:/Software/python3.7/python.exe&apos;, &apos;-c&apos;, &quot;print(&apos;hello Python.&apos;)&quot; ], stdout = PIPE) print(p.name()) print(p.status()) print(p.username()) print(p.cpu_times) print(p.wait(timeout=2))]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python"生成器"和"迭代器"]]></title>
    <url>%2F2019%2F09%2F25%2FPython%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Python生成器和迭代器的相关概念好像挺不好理解的，相关的资料写的都挺模糊的，最根本的概念都没说清楚….什么是生成器？ 什么是迭代器？ 带着这两个疑问，结合自己的理解，来总结一下，暂时的理解是这样，后面学习深入了，有了新的理解再回来更新！ 1、生成器(generator)是什么？ 生成器就是一个返回可迭代对象的函数，调用生成器函数的时候(yield)，生成器没有数据，保存的是算法，这种函数就叫生成器函数. 在使用的时候，可以通过next()方法一个个进行迭代返回数据，当函数终止的时候会自动抛出：StopIteration。 生成器函数： &gt;&gt;&gt; def func(n): ... yield n*2 ... &gt;&gt;&gt; g = func(5) &gt;&gt;&gt; g &lt;generator object func at 0x0000028F09CDA570&gt; &gt;&gt;&gt; next(g) 10 &gt;&gt;&gt; 生成器表达式： &gt;&gt;&gt; g = (i for i in range(6)) &gt;&gt;&gt; g &lt;generator object &lt;genexpr&gt; at 0x0000028F09E1A408&gt; &gt;&gt;&gt; #可以看到g只是一个对象 &gt;&gt;&gt; type(g) &lt;class &apos;generator&apos;&gt; &gt;&gt;&gt; next(g) 0 &gt;&gt;&gt; next(g) 1 &gt;&gt;&gt; next(g) 2 &gt;&gt;&gt; next(g) 3 &gt;&gt;&gt; next(g) 4 &gt;&gt;&gt; next(g) 5 &gt;&gt;&gt; next(g) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; StopIteration &gt;&gt;&gt; 2、迭代器(Iterator)又是什么？ 迭代器就是通过迭代操作(for循环)的对象，迭代器本身是可迭代的，通过iter()方法通把一个可迭代的对象封装成迭代器， 通过next()方法对可迭代的迭代器进行迭代，也可以说任何实现了next()方法的对象都可以称为迭代器，例如生成器也可以算迭代器。 迭代器表达式： &gt;&gt;&gt; ( i for i in iter(range(10))) &lt;generator object &lt;genexpr&gt; at 0x0000028F09E1A408&gt; &gt;&gt;&gt; g=( i for i in iter(range(10))) &gt;&gt;&gt; type(g) &lt;class &apos;generator&apos;&gt; &gt;&gt;&gt; &gt;&gt;&gt; g &lt;generator object &lt;genexpr&gt; at 0x0000028F09E1A390&gt; &gt;&gt;&gt; next(g) 0 &gt;&gt;&gt; next(g) 1 &gt;&gt;&gt; next(g) 2 &gt;&gt;&gt; 3、总结: 生成器和迭代器其实很相似，也有一些不一样的 通过实现迭代器对应的 iter() 方法和 next() 方法，可以定义为迭代器 生成器通过生成器函数来产生，生成器函数可以用常规的def语句来定义，但是不是return返回，而是通过yield一次返回一个结果]]></content>
      <categories>
        <category>编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python基本数据解构]]></title>
    <url>%2F2019%2F09%2F08%2Fpython02%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;文章主要内容是List，Tuple，Bytes，Bytearray的数据结构相关，包括判断数据类型，数据结构的一些基本增删改查，update,remove,insert,clear等,以及 “浅复制” 和 “深复制” 等知识 Python数据解构数据结构分类数值型： int、float、conmplex、bool 序列对象： 字符串 str 列表 list tuple 键值对： 集合 set 字典 dict 类型判断type(obj)，返回类型，而不是字符串 isinstance(obj,calss_or_tuple),返回布尔值 举例： &gt;&gt;&gt; a=123 &gt;&gt;&gt; type(a) &lt;class &apos;int&apos;&gt; &gt;&gt;&gt; &gt;&gt;&gt; type(b) &lt;class &apos;str&apos;&gt; &gt;&gt;&gt; &gt;&gt;&gt; isinstance(a,str) False &gt;&gt;&gt; isinstance(a,int) True &gt;&gt;&gt; &gt;&gt;&gt; type(1+True) &lt;class &apos;int&apos;&gt; 列表listlist特性 列表内的个体称为元素，由若干个元素组成列表 元素是可以任意对象，int,str,obj,list 列表内元素有顺序，可以使用索引 线性的数据结构 用[]表示 列表是可变的 &gt;&gt;&gt; lst=list() &gt;&gt;&gt; lst &gt;&gt;&gt; lst=[2,5,7,&apos;ab&apos;] &gt;&gt;&gt; lst=lst(range(5)) &gt;&gt;&gt; lst [0, 1, 2, 3, 4] &gt;&gt;&gt; 列表索引访问索引也叫下标 正索引：从左至右，从0开始 负索引：从右至左，从-1开始 正负索引不能超出界限，否则会报错:IndexError 列表通过所应访问：list[index]，index就是索引，使用中括号访问 索引查询: &gt;&gt;&gt; a=[1,2,3,4,5] #从0开始 &gt;&gt;&gt; a[1] 2 &gt;&gt;&gt; a[:-1] [1, 2, 3, 4] &gt;&gt;&gt; a[0:2] [1, 2] &gt;&gt;&gt; a[1:4] [2, 3, 4] &gt;&gt;&gt; a[-3:-1] [3, 4] &gt;&gt;&gt; 列表元素“增删改查“操作通过索引修改元素： &gt;&gt;&gt; a=[1,2,3,4,5] &gt;&gt;&gt; a[1]=&apos;a&apos; &gt;&gt;&gt; a [1, &apos;a&apos;, 3, 4, 5] &gt;&gt;&gt; append增加，(实在list尾部增加蒜素) &gt;&gt;&gt; a.append(6) &gt;&gt;&gt; a [1, &apos;a&apos;, 3, 4, 5, 6] &gt;&gt;&gt; insert插入，(指定索引位置插入元素) &gt;&gt;&gt; a.insert(0,9) #在索引为 “0” 的位置插入 “9” &gt;&gt;&gt; a [9, 1, &apos;a&apos;, 3, 4, 5, 6] &gt;&gt;&gt; extend拓展,(在列表末尾一次性追加另一个序列中的多个值,用新列表扩展原来的列表) &gt;&gt;&gt; b=(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;) &gt;&gt;&gt; a.extend(b) &gt;&gt;&gt; a [9, 1, &apos;a&apos;, 3, 4, 5, 6, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;] &gt;&gt;&gt; remove删除，(在列表从左到右查找第一个匹配的值，移除该元素) &gt;&gt;&gt; a=[1,3,1,4] &gt;&gt;&gt; a.remove(1) &gt;&gt;&gt; a [3, 1, 4] &gt;&gt;&gt; pop删除，(不指定索引，就弹出列表最后一个值) &gt;&gt;&gt; a=[1,2,3,4,5,6,7] &gt;&gt;&gt; a.pop() 7 &gt;&gt;&gt; a [1, 2, 3, 4, 5, 6] &gt;&gt;&gt; a.pop(0) #指定弹出索引为 0 的元素 1 &gt;&gt;&gt; a [2, 3, 4, 5, 6] &gt;&gt;&gt; clear，清空列表所有元素，剩下一个空列表 &gt;&gt;&gt; a=[1，2, 3, 4, 5] &gt;&gt;&gt; a.clear() &gt;&gt;&gt; a [] &gt;&gt;&gt; 列表其他操作reverse反转操作 &gt;&gt;&gt; a=[1,2,3,4,5] &gt;&gt;&gt; a.reverse() &gt;&gt;&gt; a [5, 4, 3, 2, 1] &gt;&gt;&gt; sort排序 &gt;&gt;&gt; a=[9,6,3,7,2,8] &gt;&gt;&gt; a.sort() &gt;&gt;&gt; a [2, 3, 6, 7, 8, 9] &gt;&gt;&gt; 列表复制In [1]: lst0 = list(range(4)) In [2]: lst0 Out[2]: [0, 1, 2, 3] In [3]: lst2 = list(range(4)) In [4]: print(lst0 == lst2) True In [5]: lst1 = lst0 In [6]: lst1[2] = 10 In [7]: print(lst0) [0, 1, 10, 3] copy复制，为浅复制 &gt;&gt;&gt; lst0=[1,[2,3,4],5] &gt;&gt;&gt; lst2 = lst0.copy() &gt;&gt;&gt; lst2 [1, [2, 3, 4], 5] 浅复制后元素的地址空间是一致的 &gt;&gt;&gt; lst2 = lst0.copy() &gt;&gt;&gt; id(lst0[1][2]) 140710918730832 &gt;&gt;&gt; id(lst2[1][2]) 140710918730832 &gt;&gt;&gt; lst2[1][2]=9 #可以看到修改lst2的值，lst0也会被修改 &gt;&gt;&gt; lst2 [1, [2, 3, 9], 5] &gt;&gt;&gt; lst0 [1, [2, 3, 9], 5] &gt;&gt;&gt; 浅复制修改完2个列表元素的空间地址一起被修改 &gt;&gt;&gt; lst2[1][2]=9 &gt;&gt;&gt; id(lst2[1][2]) 140710918730544 &gt;&gt;&gt; id(lst0[1][2]) 140710918730544 &gt;&gt;&gt; deepcopy,深copy &gt;&gt;&gt; import copy &gt;&gt;&gt; lst0=[1,[2,3,4],5] &gt;&gt;&gt; lst2=copy.deepcopy(lst0) &gt;&gt;&gt; lst2[1][2]=6 #深copy不会修改lst0的值 &gt;&gt;&gt; id(lst2[1][2]) #可以看到深copy和之前浅copy的地址是不一致的 140710918730672 &gt;&gt;&gt; lst2 [1, [2, 3, 6], 5] &gt;&gt;&gt; lst0 [1, [2, 3, 9], 5] 浅复制和深复制的区别： 浅复制遇到引用类型，就是只复制了父类型，不会对子类也复制，用的是同一块地址 深复制就是重新开辟了一个新的地址空间， 是完全独立的 白话解释： 浅复制：分手后藕断丝连 深复制：离婚 元组tuple:一个有序的元素组成的集合，使用小括号()表示 元组是 “不可变” 对象 元组的定义及初始化 &gt;&gt;&gt; t=tuple(range(5)) &gt;&gt;&gt; t (0, 1, 2, 3, 4) &gt;&gt;&gt; t=(1) &gt;&gt;&gt; type(t) #没加逗号，类型为int &lt;class &apos;int&apos;&gt; &gt;&gt;&gt; t=(1,) #元组要加逗号 &gt;&gt;&gt; type(t) &lt;class &apos;tuple&apos;&gt; &gt;&gt;&gt; 元组的元素访问： 索引查询： -支持索引（下标） -正索引：从左到右，从0开始 -负索引：从右到左，从-1开始 正负索引不可超界，否则会报错:IndexError &gt;&gt;&gt; t=(1,2,4,5,6) &gt;&gt;&gt; t[1] #访问第一个元素 2 &gt;&gt;&gt; t[1:4] #访问第一到第四之间的元素 (2, 4, 5) &gt;&gt;&gt; t[1:] #访问下标1后面的所有元素 (2, 4, 5, 6) &gt;&gt;&gt; t[:-2] #访问下标-2之前的元素 (1, 2, 4) &gt;&gt;&gt; t[2:-1] #访问第二个到下标为-1之间的元素 (4, 5) count：返回匹配的次数 &gt;&gt;&gt; t=(1,2,1,3,1,1) &gt;&gt;&gt; t.count(1) #匹配 “1” 的次数 4 &gt;&gt;&gt; len：返回元素的个数 &gt;&gt;&gt; t (1, 2, 1, 3, 1, 1) &gt;&gt;&gt; len(t) #元组 &quot;t&quot; 一共有6个元素 6 &gt;&gt;&gt; 元组只能读，增、改、删的方法都没有 命名元组namedtuple：namedtuple是继承自tuple的子类,namedtuple创建一个和tuple类似的对象，而且对象可以拥有可访问的属性 &gt;&gt;&gt; from collections import namedtuple #定义了一个namedtuple类型point,并包含了x,y2个属性 &gt;&gt;&gt; point=namedtuple(&apos;point&apos;,[&apos;x&apos;,&apos;y&apos;]) &gt;&gt;&gt; p=point(23,45) &gt;&gt;&gt; p.x 23 &gt;&gt;&gt; p.y 45 &gt;&gt;&gt; bytes和bytearraybytes：不可变字节序列 bytearray：字节数组，可变序列 bytes操作 &gt;&gt;&gt; b&apos;abcd&apos;.replace(b&apos;a&apos;,b&apos;b&apos;) b&apos;bbcd&apos; &gt;&gt;&gt; b&apos;abcd&apos;.find(b&apos;b&apos;) 1 &gt;&gt;&gt; bytes.hex()：返回16进制表示字符串 &gt;&gt;&gt; &apos;abc&apos;.encode().hex() &apos;616263&apos; &gt;&gt;&gt; bytearray基本定义:（返回一个新字节数组），元素可变 &gt;&gt;&gt; bytearray() bytearray(b&apos;&apos;) &gt;&gt;&gt; bytearray(b&apos;&apos;) bytearray(b&apos;&apos;) &gt;&gt;&gt; bytearray([1,2,3]) bytearray(b&apos;\x01\x02\x03&apos;) &gt;&gt;&gt; bytearray(&apos;abcd&apos;,&apos;utf8&apos;) bytearray(b&apos;abcd&apos;) &gt;&gt;&gt; bytearray.append(int)：在尾部追加一个元素 bytearray(b&apos;abc&apos;) &gt;&gt;&gt; b.append(12) &gt;&gt;&gt; b bytearray(b&apos;abc\x0c&apos;) &gt;&gt;&gt; bytearray.insert(int)：在指定索引插入一个元素 &gt;&gt;&gt; b.insert(1,90) #在索引为1的位置插入一个值 &gt;&gt;&gt; b bytearray(b&apos;5Zabc\x0c&apos;) &gt;&gt;&gt; bytearray.remove(value)：移除对应的值 &gt;&gt;&gt; b.remove(90) &gt;&gt;&gt; b bytearray(b&apos;5abc\x0c&apos;) &gt;&gt;&gt; bytearray.pop(index)：从指定索引移除元素，默认从尾部开始 &gt;&gt;&gt; b.pop() 12 &gt;&gt;&gt; b bytearray(b&apos;5abc&apos;) &gt;&gt;&gt; bytearray.reverse()：翻转bytearray &gt;&gt;&gt; b bytearray(b&apos;5abc&apos;) &gt;&gt;&gt; b.reverse() &gt;&gt;&gt; b bytearray(b&apos;cba5&apos;) &gt;&gt;&gt; bytearray.clear()：清空bytearry &gt;&gt;&gt; b bytearray(b&apos;cba5&apos;) &gt;&gt;&gt; b.clear() &gt;&gt;&gt; b bytearray(b&apos;&apos;) &gt;&gt;&gt; 编码与解码编码：字符串按照不同的字符集编码encode返回字节序列bytes bytes.encode(encoding=&apos;utf-8&apos;,errors=&quot;strict&quot;) --&gt; bytes 解码：字节序列按照不同字符集解码decode返回字符串 bytes.decode(encoding=&apos;utf-8&apos;,errors=&quot;strict&quot;) --&gt; str bytearray.decode(encoding=&apos;utf-8&apos;,errors=&quot;strict&quot;) --&gt; str 来个例子: &gt;&gt;&gt; &quot;中国&quot;.encode(&apos;utf-8&apos;) b&apos;\xe4\xb8\xad\xe5\x9b\xbd&apos; #将中文解码成bytes &gt;&gt;&gt; &gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe5\x9b\xbd&apos;.decode() #将bytes解码成中文 &apos;中国&apos; &gt;&gt;&gt;]]></content>
      <categories>
        <category>编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Centos7安装 OpenResty]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%AE%89%E8%A3%85Openresty%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;简介：OpenResty® 是由“章亦春”基于 Nginx 与 Lua 开源的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。OpenResty® 通过汇聚各种设计精良的 Nginx 模块（主要由 OpenResty 团队自主开发），从而将 Nginx 有效地变成一个强大的通用 Web 应用平台。这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。OpenResty® 的目标是让你的Web服务直接跑在 Nginx 服务内部，充分利用 Nginx 的非阻塞 I/O 模型，不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。 1、基于centos7安装步骤如下：相关依赖[root@master wls]# yum -y install pcre-devel openssl-devel gcc curl perl wget 2、下载openresty[root@master wls]# wget https://openresty.org/download/openresty-1.15.8.1.tar.gz [root@master wls]# tar -xf openresty-1.15.8.1.tar.gz 3、编译openresty[root@master wls]# cd openresty-1.15.8.1/ [root@master wls]# ./configure --prefix=/wls/openresty \ --with-luajit \ --without-http_redis2_module \ --with-http_iconv_module \ --with-http_postgres_module [root@master wls]# make &amp;&amp; make install 4、启动服务[root@master wls]# cd /wls/openresty/bin [root@master wls]# ./openresty 查看服务是否启动成功 [root@master bin]# ss -tnlp|grep 80 LISTEN 0 128 *:80 *:* users:((&quot;openresty&quot;,pid=38259,fd=6),(&quot;openresty&quot;,pid=38258,fd=6)) 5、开放防火墙[root@master wls]# firewall-cmd --zone=public --add-port=80/tcp --permanent [root@master wls]# firewall-cmd --reload 6、浏览器验证在浏览器地址栏输入：服务器地址+端口 7、压力测试[root@master openresty]# yum -y install httpd-tools [root@master openresty]# ab -c1000 -n50000 http://192.168.31.100:80/ -c：每次并发数为1000个 -n：共发送50000个请求 详细请求过程 This is ApacheBench, Version 2.3 &lt;$Revision: 1430300 $&gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Server Software: openresty/1.15.8.1 #服务器软件 Server Hostname: 192.168.31.100 #主机名 Server Port: 80 #请求端口 Document Path: / #文件路径 Document Length: 649 bytes #页面字节数 Concurrency Level: 1000 #请求的并发数 Time taken for tests: 8.090 seconds #总访问时间 Complete requests: 50000 #请求完成数量 Failed requests: 0 #请求失败数量 Write errors: 0 Total transferred: 44400000 bytes #请求总数据大小 HTML transferred: 32450000 bytes #html页面实例总字节数 Requests per second: 6180.73 [#/sec] (mean) #每秒多少请求，服务器的吞吐量 Time per request: 161.793 [ms] (mean) #用户平均请求等待时间 Time per request: 0.162 [ms] (mean, across all concurrent requests) #服务器处理时间 Transfer rate: 5359.85 [Kbytes/sec] received #每秒获取的数据长度 Percentage of the requests served within a certain time (ms) 50% 23 #50%用户请求在23ms内返回 66% 30 #66%用户请求在30ms内返回 75% 33 #75%用户请求在33ms内返回 80% 40 #80%用户请求在40ms内返回 90% 172 #90%用户请求在172ms内返回 95% 1031 #95%用户请求在1031ms内返回 98% 1071 #1071%用户请求在1071ms内返回 99% 1451 #99%用户请求在1451ms内返回 100% 7071 (longest request) #100%用户请求在7071ms内返回]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>openresty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python练习题]]></title>
    <url>%2F2019%2F09%2F05%2Fpython02_%E7%BB%83%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[文章主要内容如下： 打印空心正方形 求奇数的和 判断学生成绩 求1到5的阶乘之和 求5以内的素数 求圆的面积和周长 数字排序 九九乘法表 闪电符号 斐波那契 1，打印空心正方形代码如下： for i in range(1,12): if i == 1 or i == 11: print(&apos;+&apos; * 20) else: print(&apos;+&apos; + (&apos; &apos; * 18) + &apos;+&apos;) 输出结果： PS D:\Software\python_object&gt; ++++++++++++++++++++ + + + + + + + + + + + + + + + + + + ++++++++++++++++++++ PS D:\Software\python_object&gt; 2，求100以内所有奇数的和代码如下： sum = 0 for i in range(1,100,2): sum +=i print(sum) 输出结果： PS D:\Software\python_object&gt; 2500 PS D:\Software\python_object&gt; 3，判断学生成绩，成绩等级A-E,其中90分以上为A, 80分-89分为B, 70-79分为C,60-69分为D，60分以下为E代码如下： score=int(input(&quot;pleas input your socre: &quot;)) if score &gt;= 90: print(&quot;A&quot;) elif score &gt;= 80 and score &lt;= 89: print(&quot;B&quot;) elif score &gt;= 70 and score &lt;= 79: print(&quot;C&quot;) elif score &gt;= 60 and score &lt;= 69: print(&quot;D&quot;) else: print(&quot;E&quot;) 输出结果： PS D:\Software\python_object&gt; pleas input your socre: 89 B PS D:\Software\python_object&gt; pleas input your socre: 53 E PS D:\Software\python_object&gt; 4，求1到5的阶乘之和代码如下： s = 1 sum = 0 for i in range(1,6): s = s*i sum += s print(s) print(sum) 输出结果： PS D:\Software\python_object&gt; 120 153 PS D:\Software\python_object&gt; 5，求5以内的素数代码如下 num = int(input(&quot;plese ainput a prime number: &quot;)) for i in range(2,num): if num % i == 0: print(i,&quot; is not prime number!&quot;) break else: print(i,&quot;is a prime number!&quot;) 输出结果： PS D:\Software\python_object&gt; plese ainput a prime number: 5 2 is a prime number! 3 is a prime number! 4 is a prime number! PS D:\Software\python_object&gt; 6，给一个半径，求圆的面积和周长代码如下： r =int(input(&quot;请输入半径: &quot;)) print(&quot;面积:&quot;,2*3.14*r) print(&quot;周长:&quot;,3.14*(r**2)) 输出结果： PS D:\Software\python_object&gt; 请输入半径: 5 面积: 31.400000000000002 周长: 78.5 PS D:\Software\python_object&gt; 7，输入2个数，比较大小后，从小到大排序打印代码如下： a=int(input(&quot;please input a first number: &quot;)) b=int(input(&quot;please input a second number: &quot;)) if a &gt; b: print(b,a) else: print(a,b) 输出结果： PS D:\Software\python_object&gt; please input a first number: 4 please input a second number: 1 1 4 PS D:\Software\python_object&gt; please input a first number: 3 please input a second number: 1 1 3 8，打印九九乘法表第一种，代码如下： for i in range(1,10): for j in range(1,i+1): print(&quot;%d*%d=%d &quot;%(j,i,j*i)+&quot;\t&quot;,end=(&quot;&quot;)) print(&quot;&quot;) 输出结果： PS D:\Software\python_object&gt; 1*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 PS D:\Software\python_object&gt; 第二种，利用列表解析式 print(&apos;\n&apos;.join([&apos;&apos;.join([&apos;%s*%s=%-3s&apos; % (x,y,y*x) for x in range(1,y+1)]) for y in range(1,10)])) 输出结果： PS D:\Software\python_object&gt; 1*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 9，打印闪电符号代码如下： for i in range(-3,4): if i &lt; 0: a = -i print(&quot; &quot;*a+(4-a)*&quot;@&quot;) elif i == 0: print(&quot;@&quot;*7) else: print(&quot; &quot;*3+&quot;@&quot;*(4-i)) 输出结果： PS D:\Software\python_object&gt; @ @@ @@@ @@@@@@@ @@@ @@ @ PS D:\Software\python_object&gt; 10，求10项目内斐波那契数代码如下： def feibo(n): if n &lt;= 1: return n else: return(feibo(n-1)+feibo(n-2)) num =int(input(&quot;你需要打印到第几项: &quot;)) for i in range(num): print(feibo(i)) 输出结果： PS D:\Software\python_object&gt; 你需要打印到第几项: 5 0 1 1 2 3 PS D:\Software\python_object&gt; 编写一个函数，能够接收2个参数，返回最大值和最小值代码如下： def sum_numbers(x,y,*args): print(&apos;最大值&apos;，min(x,y,*args)） print(&apos;最小值&apos;，max(x,y,*args)） print(sum_numbers(5,6,2,4,9,0)) 输出结果： PS D:\Software\python_object&gt; 最小是： 0 最大是： 9 编写一个函数，接收一个参数n，n为正整数，要求数字必须对齐 def trangles(n): for i in range(1,n+1): for j in range(n,0,-1): if i &lt; j: print(&apos; &apos; * len(str(j)),end=&apos; &apos;) else: print(j,end=&apos; &apos;) print() PS D:\Software\python_object&gt; trangles(10) 1 2 1 3 2 1 4 3 2 1 5 4 3 2 1 6 5 4 3 2 1 7 6 5 4 3 2 1 8 7 6 5 4 3 2 1 9 8 7 6 5 4 3 2 1 10 9 8 7 6 5 4 3 2 1]]></content>
      <categories>
        <category>编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python基础语法]]></title>
    <url>%2F2019%2F09%2F04%2Fpython01_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近在学习Python相关的知识，学习了很久，知识真的是很长时间不用就会忘记，重新学习看网上的文档很混乱，还是自己总结比较好，需要用的时候找起来也方便。python是一门解释性语言，动态语言，强类型语言，这些又是什么意思呢，查看网上的解释和自己的理解，分享一下。 文章主要涉及Python以下内容： 转义序列 算数运算符 位运算符 比较运算符 逻辑运算符 成员运算符 身份运算符 语言分类编译语言：编辑器把代码程序编译成一个文件才能执行的语言，(例如.exe) 解释语言：一边解释，一边执行 两者的区别： 白话解释：编译语言就像炒菜，非要把菜炒好了才能吃 解释语言就像吃火锅，可以一边煮一边吃 静态和动态语言静态语言：使用前必须声明变量类型，类型不能再改变，编译的时候会检查 动态语言：不用事先声明变量，随时可以赋值为其他类型 强弱类型语言强类型语言：不同类型之间操作，必须先“强制类型转换”为同一类型,如python print(&apos;a&apos;+1) 弱类型语言：不同类型之间可以操作，自动隐士转换，如javaScript中console(1+&apos;a&apos;) python基础语法： 转义序列转义符主要有：\\ \t \r \n \&apos; \&quot; \用法： &gt;&gt;&gt; print(&apos;c:\user\test&apos;) File &quot;&lt;stdin&gt;&quot;, line 1 SyntaxError: (unicode error) &apos;unicodeescape&apos; codec can&apos;t decode bytes in position 2-3: truncated \uXXXX escape &gt;&gt;&gt; print(&apos;c:\\user\\test&apos;) c:\user\test &gt;&gt;&gt; 算数运算符 算数运算符主要有6种：+ - * / % ** 自然数除/的结果是浮点数，整除// 例子： &gt;&gt;&gt; 2 * 3 乘 6 &gt;&gt;&gt; 6 / 3 除 2.0 &gt;&gt;&gt; 6//3 整除 2 &gt;&gt;&gt; 10 % 3 取模 1 &gt;&gt;&gt; 2 ** 2 幂运算 4 位运算符位运算符主要有6种： &amp;：按位与运算，参与的运算的2个值，如果相应位都是1，则该位的结果为1，否则为0 |：按位或运算，只要对应的2个二进制有一个为1时，则结果为1 ^：按位异或运算，当2个对应的二进位想异时，结果为1 ~：按位取反运算，对数据的每个二进制位取反，即1变成0,0变成1 &lt;&lt;：左移位运算，运算的各二进位全部左移若干位，高位丢弃，低位补0 &gt;&gt;：右移位运算，运算的各二进位全部右移若干位，高位丢弃，低位补0 例子： &gt;&gt;&gt; a=60 &gt;&gt;&gt; b=13 &gt;&gt;&gt; a &amp; b 12 &gt;&gt;&gt; a | b 61 &gt;&gt;&gt; ~a -61 &gt;&gt;&gt; a ^ b 49 &gt;&gt;&gt; a &lt;&lt; 2 向左边移动2位 240 &gt;&gt;&gt; a &gt;&gt; 2 向右边移动2位 15 &gt;&gt;&gt; 解答“&amp;运算”为什么结果是12： 60在二进制表示：0011 1100 13再二进制表示：0000 1101 按&amp;位运算符号的定义，结果为：0000 1100 比较运算符比较运算符主要有6种： ==：比较对象是否相等 !=：，比较两个对象是否不相等 &gt;：返回a是否大于b &lt;：返回a是否小于b &gt;=：返回a是否大于等于b &lt;=：返回a是否小于等于b 所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。 &gt;&gt;&gt; a=60 &gt;&gt;&gt; b=13 &gt;&gt;&gt; a == b False &gt;&gt;&gt; a != b True &gt;&gt;&gt; a &gt; b True &gt;&gt;&gt; a &lt; b False &gt;&gt;&gt; a &gt;= b True &gt;&gt;&gt; a &lt;= b False &gt;&gt;&gt; 逻辑运算符逻辑运算符主要有3种： and 如果 a 为 False，a and b 返回 False，否则它返回 b 的计算值。 or 如果 a 为 True，它返回 a 的值，否则它返回 b 的计算值。 not 如果 a 为 True，返回 False 。如果 a 为 False，它返回 True。 &gt;&gt;&gt; a and b a为True所以返回b的值 13 &gt;&gt;&gt; a or b a为True所以返回a的值 60 &gt;&gt;&gt; not a a为True所以返回False False 成员运算符成员运算符主要有2种： in：如果在指定的序列找打了值返回True，否则为False not in:如果没有在指定的序列找打值返回True,否则返回True &gt;&gt;&gt; lst =(1,3,6,8,4) &gt;&gt;&gt; 2 in lst False &gt;&gt;&gt; 3 in lst True &gt;&gt;&gt; 9 not in lst True &gt;&gt;&gt; 8 not in lst False &gt;&gt;&gt; 身份运算符身份运算符主要有2种： is：判断2个标识符是不是引用自一个对象 is not：判断2个标识符是不是引用自不同对象 &gt;&gt;&gt; a = 20 &gt;&gt;&gt; b = 20 &gt;&gt;&gt; id(a) 140710943307184 &gt;&gt;&gt; id(b) 140710943307184 &gt;&gt;&gt; &gt;&gt;&gt; a is b True &gt;&gt;&gt; id(a) is id(b) False &gt;&gt;&gt; a is not b False &gt;&gt;&gt; id(a) is not id(b) True &gt;&gt;&gt;]]></content>
      <categories>
        <category>编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python基本排序算法]]></title>
    <url>%2F2019%2F08%2F27%2FPython%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本篇主要学习一下Python几种基本算法排序，冒泡排序，选择排序，插入排序，希尔排序，快速排序，堆排序等等。用博客记录一下，方便后面需要的时候过来复习，有新的思路也会慢慢过来修改更新！ 冒泡法排序&emsp;&emsp;冒泡法排序是一种简单的排序算法，它的原理是，重复的遍历要排序的列表，一次比较2个元素，如果他们的排序错误就把他们的位置交换过来，直到没有需要再交换的元素，表明该列表已经排序完成。 代码如下： li=[10,6,4,5,7,9,2,1,3,8] for i in range(len(li)-1): #列表中一共有10个数，两两比较，因此实际次数为9 for j in range(len(li)-1-i): #每次冒泡确认一个最大值，因此只需要n-1冒泡 if li[j] &gt; li[j+1]: #判断前面的数是否大于后面的数 li[j],li[j+1] = li[j+1],li[j] #如果大于则交换位置 print(li) 处理过程： [6, 10, 4, 5, 7, 9, 2, 1, 3, 8] [6, 4, 10, 5, 7, 9, 2, 1, 3, 8] [6, 4, 5, 10, 7, 9, 2, 1, 3, 8] [6, 4, 5, 7, 10, 9, 2, 1, 3, 8] [6, 4, 5, 7, 9, 10, 2, 1, 3, 8] [6, 4, 5, 7, 9, 2, 10, 1, 3, 8] [6, 4, 5, 7, 9, 2, 1, 10, 3, 8] [6, 4, 5, 7, 9, 2, 1, 3, 10, 8] [6, 4, 5, 7, 9, 2, 1, 3, 8, 10] [4, 6, 5, 7, 9, 2, 1, 3, 8, 10] [4, 5, 6, 7, 9, 2, 1, 3, 8, 10] [4, 5, 6, 7, 2, 9, 1, 3, 8, 10] [4, 5, 6, 7, 2, 1, 9, 3, 8, 10] [4, 5, 6, 7, 2, 1, 3, 9, 8, 10] [4, 5, 6, 7, 2, 1, 3, 8, 9, 10] [4, 5, 6, 2, 7, 1, 3, 8, 9, 10] [4, 5, 6, 2, 1, 7, 3, 8, 9, 10] [4, 5, 6, 2, 1, 3, 7, 8, 9, 10] [4, 5, 2, 6, 1, 3, 7, 8, 9, 10] [4, 5, 2, 1, 6, 3, 7, 8, 9, 10] [4, 5, 2, 1, 3, 6, 7, 8, 9, 10] [4, 2, 5, 1, 3, 6, 7, 8, 9, 10] [4, 2, 1, 5, 3, 6, 7, 8, 9, 10] [4, 2, 1, 3, 5, 6, 7, 8, 9, 10] [2, 4, 1, 3, 5, 6, 7, 8, 9, 10] [2, 1, 4, 3, 5, 6, 7, 8, 9, 10] [2, 1, 3, 4, 5, 6, 7, 8, 9, 10] [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 最后结果： PS D:\Software\python_object&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] PS D:\Software\python_object&gt; 选择排序&emsp;&emsp;选择排序也是简单排序的一种，它的原理是将序列中按最小的元素一个个取出来然后进行排序，直到所有元素排序完毕。结果分为“升序”和“降序”。 ”降序“ ： list= [1,7,3,9,2,4,5,6,8] n = len(list) for i in range(n): max = i for j in range(i+1,n): if list[max] &lt; list[j]: max = j if i != max: tmp = list[i] list[i] = list[max] list[max] = tmp print(list) 结果如下： PS D:\Software\python_object&gt; [9, 8, 7, 6, 5, 4, 3, 2, 1] PS D:\Software\python_object&gt; “升序” ： list= [1,7,3,9,2,4,5,6,8] n = len(list) for i in range(0, n): min = i for j in range(i + 1, n): if list[j] &lt; list[min]: min = j list[min], list[i] = list[i], list[min] print(list) 结果如下： PS D:\Software\python_object&gt; [1, 2, 4, 5, 6, 3, 8, 7, 9] PS D:\Software\python_object&gt;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建Docker私有仓库]]></title>
    <url>%2F2018%2F04%2F18%2Fdocker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 仓库是存放镜像的地方，每个服务器可以有多个仓库，而每个仓库下面有多个镜像。仓库分为公库和私库，官方的公共仓库就是docker Hub,不过国内被墙。今天就来创建一个私有仓库docker registry是官方提供的工具，用来构建私有镜像仓库 启动registry镜像[root@ubuntu:~]# docker run -d -p 5000:5000 --restart=always --name registry registry Unable to find image &apos;registry:latest&apos; locally latest: Pulling from library/registry 81033e7c1d6a: Pull complete b235084c2315: Pull complete c692f3a6894b: Pull complete ba2177f3a70e: Pull complete a8d793620947: Pull complete Digest: sha256:672d519d7fd7bbc7a448d17956ebeefe225d5eb27509d8dc5ce67ecb4a0bce54 Status: Downloaded newer image for registry:latest e97c298aabcdb30b1901b33b03768c78bcda3643c3255084ad3cbe4df68e6a8c 将registry镜像启动私有仓库，仓库会被创建在容器/var/lib/registry目录下， 使用-v参数来讲镜像文件放到本地/opt/data/registry下 报错： [root@ubuntu:~]# docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry registry 08ccd61cfc5fe2fdcbee16aede38807ca80239141f5e6dd6adf3cb825ef76f62 docker: Error response from daemon: driver failed programming external connectivity on endpoint unruffled_villani (b12b514dc8419abf708dca81f227997b4957f0cb3f52432978b25760b4f7a9dc): Bind for 0.0.0.0:5000 failed: port is already allocated. 停掉占用端口的容器即可 [root@ubuntu:/]# docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry registry 49bc7964d631d1c45058a1b03305106c13afb959eb4c794c6fed9233c1c1ce1b [root@ubuntu:/]# cd /opt/data/ [root@ubuntu:/opt/data]# ls registry 可以看到registry目录，表示成功了 docker tag将test/ubuntu v1.0 这个镜像标记为 127.0.0.0:5000/ubuntu:latest [root@ubuntu:/opt/data]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE test/ubuntu v1.0 072cd43a3a6a 2 hours ago 85.8MB &lt;none&gt; &lt;none&gt; 0ccd5ef276a3 47 hours ago 85.8MB ubuntu latest c9d990395902 2 days ago 113MB ubuntu 17.10 14107f6d2c97 2 days ago 99.1MB centos latest e934aafc2206 8 days ago 199MB registry latest d1fd7d86a825 3 months ago 33.3MB [root@ubuntu:/opt/data]# docker tag test/ubuntu:v1.0 127.0.0.0:5000/ubuntu:latest [root@ubuntu:/opt/data]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE 127.0.0.0:5000/ubuntu latest 072cd43a3a6a 2 hours ago 85.8MB test/ubuntu v1.0 072cd43a3a6a 2 hours ago 85.8MB &lt;none&gt; &lt;none&gt; 0ccd5ef276a3 47 hours ago 85.8MB ubuntu latest c9d990395902 2 days ago 113MB ubuntu 17.10 14107f6d2c97 2 days ago 99.1MB centos latest e934aafc2206 8 days ago 199MB registry latest d1fd7d86a825 3 months ago 33.3MB [root@ubuntu:/opt/data]# docker push上传标记的镜像 [root@ubuntu:/opt/data]# docker push 127.0.0.1:5000/ubuntu The push refers to repository [127.0.0.1:5000/ubuntu] 414667feb05a: Pushed latest: digest: sha256:c408657b59e55a1ca24e7b5165bdf620031c79d5b803b2df68b12ed249dfe951 size: 528 curl查看仓库中的镜像可以看到 {&quot;repositories&quot;:[&quot;ubuntu&quot;]} 表示上传成功 [root@ubuntu:/opt/data]# curl 127.0.0.1:5000/v2/_catalog {&quot;repositories&quot;:[&quot;ubuntu&quot;]} 验证：删除已经创建的127.0.0.1:5000/ubuntu镜像，再从私有仓库下载刚创建的镜像 [root@ubuntu:/opt/data]# docker image rm 127.0.0.1:5000/ubuntu Untagged: 127.0.0.1:5000/ubuntu:latest Untagged: 127.0.0.1:5000/ubuntu@sha256:c408657b59e55a1ca24e7b5165bdf620031c79d5b803b2df68b12ed249dfe951 这里可以看到镜像已经被删除了 [root@ubuntu:/opt/data]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE test/ubuntu v1.0 072cd43a3a6a 2 hours ago 85.8MB &lt;none&gt; &lt;none&gt; 0ccd5ef276a3 47 hours ago 85.8MB ubuntu latest c9d990395902 2 days ago 113MB ubuntu 17.10 14107f6d2c97 2 days ago 99.1MB centos latest e934aafc2206 8 days ago 199MB registry latest d1fd7d86a825 3 months ago 33.3MB 重新从仓库下载带有127.0.0.1:5000/ubuntu标签的镜像 [root@ubuntu:/opt/data]# docker pull 127.0.0.1:5000/ubuntu Using default tag: latest latest: Pulling from ubuntu Digest: sha256:c408657b59e55a1ca24e7b5165bdf620031c79d5b803b2df68b12ed249dfe951 Status: Downloaded newer image for 127.0.0.1:5000/ubuntu:latest 这样就下载成功了 [root@ubuntu:/opt/data]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE 127.0.0.1:5000/ubuntu latest 072cd43a3a6a 2 hours ago 85.8MB test/ubuntu v1.0 072cd43a3a6a 2 hours ago 85.8MB &lt;none&gt; &lt;none&gt; 0ccd5ef276a3 47 hours ago 85.8MB ubuntu latest c9d990395902 2 days ago 113MB ubuntu 17.10 14107f6d2c97 2 days ago 99.1MB centos latest e934aafc2206 8 days ago 199MB registry latest d1fd7d86a825 3 months ago 33.3MB [root@ubuntu:/opt/data]# 注意：不使用127.0.0.1:5000这个地址作为仓库地址，将无法推送镜像，因为docker默认不允许使用https的方式推送镜像]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 常用命令]]></title>
    <url>%2F2018%2F04%2F17%2Fdocker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[docker用起来还是很方便的，而且命令也容易，常用的命令如下：docker rundocker psdocker inspectdocker attach…. docker run运行一个容器Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...] [flags] [root@ubuntu:~]# docker run -it ubuntu /bin/bash [root@c32ec2b3f49a:/]# ls bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var [root@c32ec2b3f49a:/]# -i 为容器打开标准输出 -t 给打开的容器运行一个伪tty终端 docker ps 列出容器[root@ubuntu:~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c32ec2b3f49a ubuntu &quot;/bin/bash&quot; 2 minutes ago Up 2 minutes hopeful_bose 4f078216cfef ubuntu &quot;/bin/bash&quot; 47 hours ago Up 47 hours competent_sammet 41432143ef92 ubuntu &quot;/bin/bash&quot; 47 hours ago Up 47 hours hardcore_payne 929860f00fa4 ubuntu &quot;/bin/bash&quot; 47 hours ago Up 47 hours competent_perlman d2170af637a4 centos &quot;/bin/bash&quot; 47 hours ago Up 47 hours epic_stallman 3ac68df6d5de ubuntu &quot;/bin/bash&quot; 2 days ago Up 2 days blissful_northcutt 8b9e5cc28561 ubuntu &quot;/bin/bash&quot; 2 days ago Up 2 days cranky_stallman [root@ubuntu:~]# docker ps -l CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c32ec2b3f49a ubuntu &quot;/bin/bash&quot; 2 minutes ago Up 2 minutes hopeful_bose -a 列出所有的容器 -l 最新创建的容器 docker inspect列出镜像信息Usage: docker inspect [OPTIONS] NAME|ID [NAME|ID...] [flags] [root@ubuntu:~]# docker inspect c32ec2b3f49a hopeful_bose [ { &quot;Id&quot;: &quot;c32ec2b3f49a5774bef44f88c00c1303d760c142fc0b528ad33c61208cf97725&quot;, &quot;Created&quot;: &quot;2018-04-15T14:01:11.956052589Z&quot;, &quot;Path&quot;: &quot;/bin/bash&quot;, &quot;Args&quot;: [], &quot;State&quot;: { &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 6180, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2018-04-15T14:01:12.390885359Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; ... ... docker attach进入后台运行的容器Usage: docker attach [OPTIONS] CONTAINER [flags] [root@ubuntu:~]# docker run -it ubuntu /bin/bash [root@40fe9f37c774:/]# [root@40fe9f37c774:/]# root@ubuntu:~# [root@ubuntu:~]# 注意：在刚创建的容器里，&quot;Ctrl+d&quot;直接退出并结束进程，使用&quot;Ctrl+P+Q&quot;(大写)退出不结束进程 [root@ubuntu:~]# docker attach 40fe9f37c774 [root@40fe9f37c774:/]# [root@40fe9f37c774:/]# docker exec 命令Usage: docker exec [OPTIONS] CONTAINER COMMAND [ARG...] [flags] [root@ubuntu:~]# docker run -itd ubuntu cd92f0ec9d4018f24ee4a06edd17f38d382dbed174bc578825d72e42219f6653 [root@ubuntu:~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES cd92f0ec9d40 ubuntu &quot;/bin/bash&quot; 16 seconds ago Up 16 seconds upbeat_blackwell [root@ubuntu:~]# docker exec -it cd92f0ec9d40 bash root@cd92f0ec9d40:/# ls bin dev home lib64 mnt proc run srv tmp var boot etc lib media opt root sbin sys usr [root@cd92f0ec9d40:/]# exit [root@ubuntu:~]# docker exec -it cd92f0ec9d40 bash [root@cd92f0ec9d40:/]# 可以看到使用了exec命令后，exit退出容器也不会停止 列出所有容器 [root@ubuntu:~]# docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES cd92f0ec9d40 ubuntu &quot;/bin/bash&quot; 39 minutes ago Up 39 minu docker export导出容器快照[root@ubuntu:~]# docker export cd92f0ec9d40 &gt;/tmp/ubuntu.tar [root@ubuntu:~]# ls /tmp/ ubuntu.tar unity_support_test.0 docker import导入容器快照[root@ubuntu:~]# cat /tmp/ubuntu.tar |docker import - test/ubuntu:v1.0 sha256:0ccd5ef276a3b175b14d9b031fba85bbdf44e8d5819a62d49564333398f0e9dc [root@ubuntu:~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE test/ubuntu v1.0 072cd43a3a6a About a minute ago 85.8MB docker rm 删除容器[root@ubuntu:~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1862e1300c97 ubuntu &quot;/bin/bash&quot; 46 hours ago Up 46 hours stupefied_chebyshev 4f078216cfef ubuntu &quot;/bin/bash&quot; 46 hours ago Up 46 hours competent_sammet 41432143ef92 ubuntu &quot;/bin/bash&quot; 46 hours ago Up 46 hours hardcore_payne 929860f00fa4 ubuntu &quot;/bin/bash&quot; 47 hours ago Up 47 hours competent_perlman d2170af637a4 centos &quot;/bin/bash&quot; 47 hours ago Up 47 hours epic_stallman 3ac68df6d5de ubuntu &quot;/bin/bash&quot; 47 hours ago Up 47 hours blissful_northcutt 8b9e5cc28561 ubuntu &quot;/bin/bash&quot; 47 hours ago Up 47 hours cranky_stallman [root@ubuntu:~]# docker container rm 1862e1300c97 Error response from daemon: You cannot remove a running container cd92f0ec9d4018f24ee4a06edd17f38d382dbed174bc578825d72e42219f6653. Stop the container before attempting removal or force remove 注意：因为当前容器是正在运行的，所以直接停止会报错，加上参数-f，docker会发送sigkill信号给容器 [root@ubuntu:~]# docker container rm -f 1862e1300c97 1862e1300c97 [root@ubuntu:~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4f078216cfef ubuntu &quot;/bin/bash&quot; 46 hours ago Up 46 hours competent_sammet 41432143ef92 ubuntu &quot;/bin/bash&quot; 46 hours ago Up 46 hours hardcore_payne 929860f00fa4 ubuntu &quot;/bin/bash&quot; 47 hours ago Up 47 hours competent_perlman d2170af637a4 centos &quot;/bin/bash&quot; 47 hours ago Up 47 hours epic_stallman 3ac68df6d5de ubuntu &quot;/bin/bash&quot; 47 hours ago Up 47 hours blissful_northcutt 8b9e5cc28561 ubuntu &quot;/bin/bash&quot; 47 hours ago Up 47 hours cranky_stallman [root@ubuntu:~]# prune清除所有处于终止状态的容器[root@ubuntu:~]# docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES cd92f0ec9d40 ubuntu &quot;/bin/bash&quot; 46 hours ago Exited (0) 6 minutes ago upbeat_blackwell 4f078216cfef ubuntu &quot;/bin/bash&quot; 46 hours ago Up 46 hours competent_sammet 51783f7ff529 ubuntu &quot;/bin/bash&quot; 46 hours ago Exited (0) 46 hours ago competent_chebyshev 41432143ef92 ubuntu &quot;/bin/bash&quot; 47 hours ago Up 47 hours hardcore_payne 4e80f171f0dd ubuntu &quot;/bin/bash&quot; 47 hours ago Exited (0) 47 hours ago xenodochial_dijkstra e34b31703aac ubuntu:17.10 &quot;/bin/sh -c &apos;whilr t…&quot; 47 hours ago Exited (0) 47 hours ago reverent_bhaskara 929860f00fa4 ubuntu &quot;/bin/bash&quot; 47 hours ago Up 47 hours competent_perlman af27e78a0078 ubuntu &quot;/bin/bash&quot; 47 hours ago Exited (0) 47 hours ago goofy_hamilton d4306e006205 ubuntu &quot;/bin/echo &apos; hello w…&quot; 47 hours ago Exited (0) 47 hours ago relaxed_albattani 6134f0d591a5 ubuntu &quot;/bin/hello world&quot; 47 hours ago Created determined_heisenberg d2170af637a4 centos &quot;/bin/bash&quot; 47 hours ago Up 47 hours epic_stallman 3ac68df6d5de ubuntu &quot;/bin/bash&quot; 47 hours ago Up 47 hours blissful_northcutt 8b9e5cc28561 ubuntu &quot;/bin/bash&quot; 47 hours ago Up 47 hours cranky_stallman [root@ubuntu:~]# docker container prune WARNING! This will remove all stopped containers. Are you sure you want to continue? [y/N] y Deleted Containers: cd92f0ec9d4018f24ee4a06edd17f38d382dbed174bc578825d72e42219f6653 51783f7ff529e82fa852921bfe1f567f97345e9fb2934808803954e24a24a1e9 4e80f171f0ddaebde20a79e643585e8ace4e515804b423b6da04a67bf49c346a e34b31703aaca5931468cee0df8763d4dc78df36bb7ed5ba0e0c09729f8ec825 af27e78a00784aea88258f4d528f35c1cd616f68a76d3dbf222104061f533ba5 d4306e006205fb89b3ca64b5efe4e73591bfce0b283c208733cf1e8f5ca6fe58 6134f0d591a50ae081db0c91d6d8fc1efda0c9588424fa6890daa01a84e115b0 Total reclaimed space: 8B 可以看到终止的容器已经被清理掉了 [root@ubuntu:~]# docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4f078216cfef ubuntu &quot;/bin/bash&quot; 46 hours ago Up 46 hours competent_sammet 41432143ef92 ubuntu &quot;/bin/bash&quot; 47 hours ago Up 47 hours hardcore_payne 929860f00fa4 ubuntu &quot;/bin/bash&quot; 47 hours ago Up 47 hours competent_perlman d2170af637a4 centos &quot;/bin/bash&quot; 47 hours ago Up 47 hours epic_stallman 3ac68df6d5de ubuntu &quot;/bin/bash&quot; 47 hours ago Up 47 hours blissful_northcutt 8b9e5cc28561 ubuntu &quot;/bin/bash&quot; 47 hours ago Up 47 hours cranky_stallman [root@ubuntu:~]# docker stop停止一个容器[root@ubuntu:~]# docker run -it ubuntu /bin/bash [root@2a1de0464580:/]# [root@ubuntu:~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2a1de0464580 ubuntu &quot;/bin/bash&quot; 41 seconds ago Up 40 seconds romantic_bhaskara [root@ubuntu:~]# docker stop 2a1de0464580 2a1de0464580 docker search拉取镜像[root@ubuntu:~]# docker search centos NAME DESCRIPTION STARS OFFICIAL AUTOMATED centos The official build of CentOS. 4188 [OK] ansible/centos7-ansible Ansible on Centos7 108 [OK] jdeathe/centos-ssh CentOS-6 6.9 x86_64 / CentOS-7 7.4.1708 x86_… 94 [OK] consol/centos-xfce-vnc Centos container with &quot;headless&quot; VNC session… 52 [OK] imagine10255/centos6-lnmp-php56 centos6-lnmp-php56 40 [OK] tutum/centos Simple CentOS docker image with SSH access 38 gluster/gluster-centos Official GlusterFS Image [ CentOS-7 + Glust… 26 [OK] centos/mysql-57-centos7 MySQL 5.7 SQL database server 23 openshift/base-centos7 A Centos7 derived base image for Source-To-I… 22 kinogmt/centos-ssh CentOS with SSH 19 [OK] centos/python-35-centos7 Platform for building and running Python 3.5… 19 centos/postgresql-96-centos7 PostgreSQL is an advanced Object-Relational … 12 openshift/jenkins-2-centos7 A Centos7 based Jenkins v2.x image for use w… 11 centos/httpd-24-centos7 Platform for running Apache httpd 2.4 or bui… 10 openshift/mysql-55-centos7 DEPRECATED: A Centos7 based MySQL v5.5 image… 6 openshift/wildfly-101-centos7 A Centos7 based WildFly v10.1 image for use … 3 openshift/jenkins-1-centos7 DEPRECATED: A Centos7 based Jenkins v1.x ima… 3 pivotaldata/centos-gpdb-dev CentOS image for GPDB development. Tag names… 3 pivotaldata/centos Base centos, freshened up a little with a Do… 1 pivotaldata/centos-mingw Using the mingw toolchain to cross-compile t… 1 blacklabelops/centos CentOS Base Image! Built and Updates Daily! 1 [OK] openshift/php-55-centos7 DEPRECATED: A Centos7 based PHP v5.5 image f… 1 pivotaldata/centos-gcc-toolchain CentOS with a toolchain, but unaffiliated wi… 0 smartentry/centos centos with smartentry 0 [OK] jameseckersall/sonarr-centos Sonarr on CentOS 7 0 [OK] root@ubuntu:~# 可以看到拉取的镜像返回了很多内容，包括：镜像名称，描述，收藏数，是否是官方创建，是否为自动创建 列出所有镜像 Usage: docker images [OPTIONS] [REPOSITORY[:TAG]] [root@ubuntu:~]# docker images -a REPOSITORY TAG IMAGE ID CREATED SIZE test/ubuntu v1.0 072cd43a3a6a About an hour ago 85.8MB &lt;none&gt; &lt;none&gt; 0ccd5ef276a3 46 hours ago 85.8MB ubuntu latest c9d990395902 2 days ago 113MB ubuntu 17.10 14107f6d2c97 2 days ago 99.1MB centos latest e934aafc2206 8 days ago 199MB [root@ubuntu:~]# -a 显示所有镜像 -q 显示镜像ID docker pull下载镜像到本地[root@ubuntu:~]# docker pull centos Using default tag: latest latest: Pulling from library/centos Digest: sha256:989b936d56b1ace20ddf855a301741e52abca38286382cba7f44443210e96d16 Status: Image is up to date for centos:latest root@ubuntu:~#]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初识Docker 一]]></title>
    <url>%2F2018%2F04%2F02%2F%E5%88%9D%E8%AF%86Docker1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。Docker分为CE和EE。CE即社区版，免费开源。EE即企业版，安全性更高，需要付费使用。 Docker 三个基本概念·镜像（Images）·容器（Container）·仓库（Registry） Docker镜像&emsp;&emsp;就是一个层叠的只读文件系统，底端是一个引导文件系统，当容器启动之后引导文件系统就会被卸载，上一层是只读的root文件系统，或者更上一层还有其他文件系统，Docker“联合加载”会将这种叠加在一起的文件系统整合在一起，而这种整合在一起的文件系统，就是Docker镜像。它主要提供一些容器运行时需要的程序，库，资源，配置(环境变量，用户)。镜像不会包含任何动态内容，内容结构也不会被改变。 Docker容器&emsp;&emsp;容器就实质是一个进程，当启动一个容器时，Docker会在镜像最顶层加载一个“读写层”，容器就是在这个读写层执行的。Docker第一次启动时，这个“读写层”是空白的，当修改一个文件时，Docker会从文件系统底层的“只读层”复制到“读写层”，该文件只读版本依然存在但是被“读写层”改文件的副本所隐藏，这就是Docker的“写时复制”。 镜像和容器的关系&emsp;&emsp;镜像是静止的定义，容器是镜像运行时的实体，容器可以被创建，启动，停止和删除等。（这个地方花了很长时间才区分开镜像和容器的本质区别） Docker仓库&emsp;&emsp;当镜像构建完成后，如果要拿到其他服务器上使用时，就需要一个集中管理，分发镜像的服务，这就是Docker仓库(分为共有和私有)。 如果还是不清楚，可以参考这个：http://dockone.io/article/783 Docker依赖Linux内核特性Docker依赖Linux内核2大特性： ·NameSpace ·Cgroups NameSpace: 将特定的全局系统资源(网络，文件系统，进程等)，通过抽象的方法使NameSpace进程实现资源隔离 Cgroups: 用于资源限定，设置优先级和资源计量和资源控制]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Docker 二]]></title>
    <url>%2F2018%2F04%2F02%2F%E5%88%9D%E8%AF%86docker%202%2F</url>
    <content type="text"><![CDATA[Docker的安装 &emsp;&emsp; 说明：我用的是Ubuntu(16.04）,洛杉矶VPS，所以没配置镜像加速(国内主机的话还是配置一下) 查看自己的系统版本[zane4649@instance-2:~]$ cat /proc/version Linux version 4.13.0-1011-gcp (buildd@lgw01-amd64-006) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.9)) #15-Ubuntu SMP Mon Feb 12 16:29:04 UTC 2018 卸载之前旧版本的Docker[zane4649@instance-2:~]$ sudo apt-get remove docker docker-engine docker.io 安装apt源依赖因为要确保apt源使用https下载过程不被更改，因此要添加https传输的软件包和ca证书 [zane4649@instance-2:~]$ sudo apt-get update [zane4649@instance-2:~]$ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common 添加Docker的官方GPG密钥[zane4649@instance-2:~]$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 添加docker软件源[zane4649@instance-2:~]$ sudo add-apt-repository \ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable&quot; 更新Docker软件包索引[zane4649@instance-2:~]$ sudo apt-get update 安装Docker[zane4649@instance-2:~]$ sudo apt-get -y install docker-ce 启动Docker[zane4649@instance-2:~]$ sudo systemctl enable docker [zane4649@instance-2:~]$ sudo systemctl start docker 创建docker用户组默认情况，docker命令会使用Unix socket与docker建立通讯，而只有root和docker组的用户 才可以访问docker引擎的Unix socket。因此要创建docker用户并加入docker组，因为root权限过大 [zane4649@instance-2:~]$ sudo useradd -g docker docker [zane4649@instance-2:~]$ id docker uid=1003(docker) gid=117(docker) groups=117(docker) [zane4649@instance-2:~]$ 测试是否正确安装[zane4649@instance-2:~]$ sudo docker run hello-world 有以下反馈表示安装成功 Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://cloud.docker.com/ For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ 运行一个容器[zane4649@instance-2:~]$ sudo docker run -it ubuntu /bin/bash Unable to find image &apos;ubuntu:latest&apos; locally latest: Pulling from library/ubuntu 22dc81ace0ea: Pulling fs layer 22dc81ace0ea: Pull complete 1a8b3c87dba3: Pull complete 91390a1c435a: Pull complete 07844b14977e: Pull complete b78396653dae: Pull complete Digest: sha256:e348fbbea0e0a0e73ab0370de151e7800684445c509d46195aef73e090a49bd6 Status: Downloaded newer image for ubuntu:latest [root@1d8f8e8f3afb:/]# 现在就已经在创建的容器里了 [root@1d8f8e8f3afb:/]# [root@1d8f8e8f3afb:/#] zane4649@instance-2:~$ 退出容器 [zane4649@instance-2:~]$ [zane4649@instance-2:~]$ sudo docker ps -a 列出运行的容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1d8f8e8f3afb ubuntu &quot;/bin/bash&quot; 2 minutes ago Up 2 minutes jovial_cray 86506e3fa3eb hello-world &quot;/hello&quot; 3 hours ago Exited (0) 3 hours ago objective_franklin c86c09d8da04 hello-world &quot;/hello&quot; 3 hours ago Exited (0) 3 hours ago sleepy_wozniak [zane4649@instance-2:~]$ 配置镜像加速器因为国内从Docker Hub 上拉镜像很慢，所以一般都会用国内的加速来提高速度! 可选的加速器有： Docker官方提供中国 reqistry mirror 阿里云加速器 DaoCloud加速器 &emsp;&emsp;这里就演示一下阿里云加速器了，先去注册阿里云账户，然后会得到一个专属的加速器地址，根据提示修改即可!]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Next主题 Pisces Scheme更改内容区域的宽度]]></title>
    <url>%2F2018%2F03%2F30%2Fnext%E4%BF%AE%E6%94%B9%E6%98%BE%E7%A4%BA%E5%AE%BD%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[Next 主题修改内容显示区域宽度 &emsp;&emsp; 之前也修改过Pisces Scheme的宽度，但是移动端老显示不正常，最近看官方文档的时候，发现有个老哥给出了以下配置，抱着尝试的心态去改了一下，打开PC端确实内容显示区域加宽了不少，然后怀着忐忑的心理手机上打开了我的博客，Oh My God!!! 幸福来的这么突然吗！ 竟然显示正常！下面把方法分享一下(参数在图片下面) 移动端效果如图： 正确的姿势如下： 修改配置文件：\themes\next\source\css\_schemes\Pisces\layout.styl .header { width: 80%; } .container .main-inner { width: 80%; } .content-wrap { width: calc(100% - 260px); }]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Centos7 编译安装MariaDB-10.1.22]]></title>
    <url>%2F2018%2F03%2F27%2F%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85mysql%2F</url>
    <content type="text"><![CDATA[目的：使用源码包编译安装Mariadb 卸载安装的mariadb[root@localhost /]# rpm -qa | grep mariadb mariadb-libs-5.5.44-2.el7.centos.x86_64 [root@localhost /]# rpm -e mariadb-libs-5.5.44-2.el7.centos.x86_64 创建用户和组[root@localhost /]# groupadd mysql [root@localhost /]# useradd -g mysql mysql 创建文件目录[root@localhost /]# mkdir /mydata/data -pv [root@localhost /]# chown mysql.mysql data 安装依赖包[root@localhost /]# yum groupinstall -y Development Tools #环境开发工具包 [root@localhost /]# yum -y install gcc gcc-c++ make cmake ncurses ncurses-devel man ncurses libxml2 libxml2-devel openssl-devel bison bison-devel # cmake：由于从MySQL5.5版本开始弃用了常规的configure编译方法，所以需要cmake编译器，用于设置mysql的编译参数。（如：安装目录，数据存放目录，字符编码，排序规则等） # boost：从MySQL5.7.5开始Boost库是必需的，mysql源码中用到了C++的Boost库，要求必需安装Boost1.59.0或以上版本。 # GCC：这是Linux下的C语言编译工具，MySQL源码编译完全由C和C++编写，要求必需安装GCC。 # bison：Linux下C/C++语法分析器 # ncurses：字符终端处理库。 ......... 编译准备[root@localhost /]# tar -xvf mariadb-10.1.22.tar.gz -C /usr/local [root@localhost /]# cd /usr/local/ [root@localhost /]# ln -sv mariadb-10.1.22 mysql #做软链接 [root@localhost /]# chown -R root:mysql ./* #修改配置文件的属组 开始编译[root@localhost mysql]# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql #Mysql安装的根目录 -DMYSQL_DATADIR=/mydata/data #Mysql数据库文件存放路径 -DWITH_INNOBASE_STORAGbE_ENGINE=1 #添加InoooDB引擎 -DWITH_ARCHIVE_STORAGE_ENGINE=1 #添加ARCHIVE引擎 -DWITH_BLACKHOLE_STORAGE_ENGINE=1 #添加BLACKHOLE引擎 -DWITH_SSL=system -DWITH_ZLIB=system #可以用systemd控制服务 -DWITH_LIBWRAP=0 # -DMYSQL_UNIX_ADDR=/tmp/mysql.sock #指定sock文件的位置 -DEFAULT_CHARSET=utf8 #Mysql默认字符集为utf-8 -DDEFAULT_COLLATION=utf8_general_ci #支持默认字符集校对规则 [root@localhost mysql]# make &amp;&amp; make install #编译并安装 初始化数据库四个数据库，information_schema ，performance_schema，test ，mysql源数据库（用户，权限，字段，字段名。。。。）, 自行脚本生成，脚本在mysql/scripts 执行一下就可以安装了 [root@localhost mysql]# scripts/mysql_install_db --user=mysql --datadir=/mysql/data [root@localhost mysql]# scripts/mysql_install_db --help [root@localhost mysql]# ls /mydata/data/ aria_log.00000001 ib_logfile0 multi-master.info mysql-bin.index aria_log_control ib_logfile1 mysql performance_schema ibdata1 localhost.localdomain.pid mysql-bin.000001 test 创建配置文件[root@localhost mysql]# mkdir /etc/mysql [root@localhost mysql]# cp support-files/my-large.cnf /etc/mysql/my.cnf [root@localhost mysql]# vim /etc/mysql/my.cnf datadir = /mydata/data #数据文件的路径 innodb_file_per_table = on #修改InnoDB为独立表空间模式 skip_name_resolve = on #跳过名称反解，将客户端连接IP反解成主机名，然后做权限检查 创建服务脚本[root@localhost mysql]# cp support-files/mysql.server /etc/rc.d/init.d/mysqld [root@localhost mysql]# chkconfig --add mysqld #设置开机启动 [root@localhost mysql]# chkconfig --list mysqld [root@localhost mysql]# service mysqld start [root@localhost mysql]# ss -tnlp #查看3306是否被mysql监听 LISTEN 0 80 :::3306 :::* users:((&quot;mysqld&quot;,pid=5358,fd=21)) 设置环境变量[root@localhost mysql]# vim /etc/profile.d/mysqld.sh MYSQL_HOME=/usr/local/mysql export PATH=$MYSQL_HOME/bin:$PATH [root@localhost mysql]# source /etc/profile.d/mysqld.sh #加载环境变量 连接Mysql[root@localhost mysql]# mysql Welcome to the MariaDB monitor. Commands end with ; or \g. Your MariaDB connection id is 4 Server version: 10.1.22-MariaDB Source distribution Copyright (c) 2000, 2016, Oracle, MariaDB Corporation Ab and others. Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement. MariaDB [(none)]&gt; 遇到的问题启动时报错： /usr/local/mysql//libexec/mysqld: Can&apos;t create/write to file &apos;/var/log/mariadb&apos; (Errcode: 13) 120516 15:23:19 [ERROR] Can&apos;t start server: can&apos;t create PID file: Permission denied 解决方法： chown mysql.mysql /var/log/mariadb/ -R]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>编译安装Mariadb-10.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下安装RabbitMQ]]></title>
    <url>%2F2018%2F03%2F27%2Fwindows%E5%AE%89%E8%A3%85rabbitmq%2F</url>
    <content type="text"><![CDATA[今天学习Python第11天的课程，讲消息队列，当然说的就是RabbitMQ，于是就想起，写篇博客记录一下安装过程！ 版本说明 OS: win10_1703 Erlang: 20.1 RabbitMQ: 3.6.12 安装erlang RabbitMQ是建立Erlang平台上，所以先要装上erlang 我这里安装的版本是：otp_win64_20.1（各人按自己系统版本下载） 官方下载地址：http://www.erlang.org/downloads 添加环境变量 安装RabbitMQ 我这里下载的版本是：rabbitmq-server-3.6.12 官方下载地址：http://www.rabbitmq.com/download.html 配置RabbitMQ 激活rabbitmq-plugins (C:\Program Files\RabbitMQ Server\rabbitmq_server-3.6.12\sbin\rabbitmq-plugins.bat) 命令：rabbitmq-plugins enable rabbitmq_management 需要重启服务才能生效 访问控制台 上面步骤都配置好后，浏览器地址栏输入：http://localhost:15672( 默认用户和密码都是guest) 最后：简单的配置到这里就结束了，后续有其他的要求到时候再更新博客]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习之第五天]]></title>
    <url>%2F2018%2F03%2F27%2Fpython%E7%AC%AC%E4%BA%94%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[最近这段时间，利用业余时间学习了一下Python,写篇博客算是记录一下相关的知识点，方便以后查询，也算做个小总结！ 第五天学习主要类容：模块定义，导入，正则表达式等 定义模块：用来从逻辑上组织python代码（变量，函数，类，） 本质就是.py结尾的python文件（文件名：test.py,对应的模块名：test） 包：用来从逻辑上组织模块的，本质就是一个目录（必须要有一个__init__.py文件） 导入方法import module_name import module1_name,module2_name #import module1_name 相当于把整个模块的代码复制给当前一个变量，然后调用 from module_zane frome * #导入module_zane模块的所有，一般不建议这么用 from module_zane import m1,m2 #导入module_zane模块的方法 from module_zane import name as new_name #从module_zane模块下导入一个模块（赋给另一个变量） #from 相当于只打开了module_name的一个方法 import本质导入&quot;模块&quot;的本质就是把python文件解释一遍 导入&quot;包&quot;的本质就是执行该包下的__init__.py文件） import sys,os print(sys.path) #print(os.path.abspath(__file__)) #abspath：获取当前文件的绝对路径 #此时的路径E:/pycharm/s14/day5/module_test/main.py&quot; x = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) #os.path.dirname:获取路径名，这里因为module_test文件在day5路径下，所以要上找两层 sys.path.append(x) #把获取的路径sys.path import module_test time和datetime模块import time #导入time模块 time.time() #获取时间戳 time.timezone() #获取时区，中国在东8区 time.altzone() #夏令时和UTC(标准时)的差值 time.daylight() #是否使用了夏令时 time.sleep() #沉睡几秒 time.gmtime() #把时间戳转换成元祖，结果是UTC时区 time.localtime()#把时间戳转换成元祖，结果是本地时区 time.mktime() #将元祖转换成时间戳 time.strftime() #将元祖转换成字符串格式显示（例：time.strftime(&quot;%Y-%m:%d %H:%M:%S&quot;,x)） time.strptime() #将字符串转换成元祖形式（time.strptime(&apos;2017-09:06 22:19:00&apos;,&quot;%Y-%m:%d %H:%M:%S&quot;）） time.astime() #将元祖转换成字符转形式 time.ctime() #将时间戳转换成字符串形式 时间加减： import datatime print(datetime.datetime.now()) #返回当前时间 print(datetime.datetime.now() + datetime.timedelta(3)) #当前时间+3天 print(datetime.datetime.now() + datetime.timedelta(-3)) #当前时间-3天 print(datetime.datetime.now() + datetime.timedelta(hours=3)) #当前时间+3小时 print(datetime.datetime.now() + datetime.timedelta(hours+30)) #当前时间+30分钟 c_time = datetime.datetime.now() #当前时间：2017-09-06 22:53:53.191920 print(c_time.replace(minute=3,hour=2)) #时间替换为：2017-09-06 02:03:53.191920 random模块import random random.random() #0到1之间的随机数 random.randit(1,3) #生成一个指定范围的整数 random.shuffle() #洗牌（例如：i=[1,2,3,4] random.shuffle(i) 输入为：[2,1,4,3） random.choice(&apos;afsdsgfd&apos;) #随机字符 random.sample(&apos;afgagradf&apos;,3) #选取特定数量的字符 练习：生成4位随机数 import random checkcode=&apos;&apos; for i in range(4): current=random.randint(1,9) if current ==i: tmp = chr(random.randint(65,90)) else: tmp = random.randint(0,9) checkcode+=str(tmp)\ print(checkcode) os模块&quot;os&quot;模块是提供对操作系统进行调用的接口 import os os.getcwd() #获取当前工作目录 os.chdir(r&quot;C:\User&quot;) #切换目录 os.curdir #返回当前目录 os.pardir #获取当前目录的父目录 os.makedirs(r&quot;C:\a\b\c&quot;) #递归创建目录 os.removedirs(r&quot;C:\a\b\c&quot;) #递归删除目录（如果目录为空则删除上级目录） os.mkdir() #创建单级目录 os.rmdir() #删除单级目录 os.listdir(r&apos;D:&apos;) #列出D盘下所有文件夹 os.remove() #删除一个文件 os.rename(&quot;oldname&quot;,&quot;newname&quot;) #修改文件名 os.stat(path/filename) #获取文件/目录信息 os.sep #输出系统路径分隔符 os.environ #输出当前系统的环境变量 os.pathsep #输出用于分割文件路径的字符串 os.system(dir,ipconfig) #执行系统命令 os.path.abspath() #获取文件的绝对路径 os.path.split() #将path分割成目录，文件名 os.path.dirname(r&apos;C:\a\b\test.txt&apos;) #只获取路径（输出结果为：&apos;C:\\a\\b&apos;） os.path.basename(r&apos;C:\a\b\test.txt&apos;) #只获取文件名(输出结果为：‘test.txt’) os.path.exists(r&apos;D:\a&apos;) #判断路径是否存在（存在返回True,不存在返回False） os.path.file(path) #判断是否为文件 os.path.dir(path) #判断是否为目录 os.path.getatime(path) #获取文件或目录最后的存取时间(返回时间戳) os.path.getmtime(path) #获取文件或路径最后的修改时间(返回时间戳) sys模块import sys sys.argv #命令行参数List，第一个元素是程序本身路径 sys.exit(n) #程序退出，正常返回&apos;0&apos;,其他返回&apos;1-254&apos; sys.version #获取Python版本信息 sys.path #返回模块搜索路径 sys.platform #获取操作系统平台信息 shutil模块高级的文件，文件夹，压缩包处理模块 shutil.copyfile(&quot;file_name1&quot;,&quot;file_name2&quot;) #复制文件 shutil.copytree(&quot;source&quot;,&quot;new_name&quot;) #递归复制文件目录 shutil.rmtree(&quot;file_name&quot;) #递归删除文件 shutil.make_archive(&quot;压缩文件名&quot;，“type”,&quot;path&quot;) #压缩文件 (例：shutil.make_archive(&quot;shutil_test&quot;,&quot;gzip&quot;,&quot;D:\test.py&quot;)) json &amp; pickle json 把python内存中的数据类型转换成字符串（dumps）,调用（loads） pickle 把python特有的类型和python的数据类型进行转换 json序列化序列化就是把python对象编码转换成json格式的字符串 import json info = { &apos;name&apos;:&apos;zane&apos;, &apos;age&apos;:22 } f = open(&quot;test.txt&quot;,&apos;w&apos;) #print(json.dumps(info)) f.write(json.dumps(info)) #dump序列化 f.close() json反序列化反序列化就是把json字符串解码转换成python数据对象 import json f = open(&quot;test.txt&quot;,&apos;r&apos;) data = json.loads(f.read()) #反序列化loads print(data[&quot;age&quot;]) f.close() configparser模块用于生成和修改常见配置文档 详情：http://www.cnblogs.com/alex3714/articles/5161349.html hashlib模块一般用于加密,python3.0里代替了md5模块和sha模块，主要提供了MD5,SHA1,SHA256,SHA512等算法 import hashlib # f = hashlib.md5() f.update(b&apos;hello&apos;) #b表示byte类型 f.update(b&apos;world&apos;) print(f.digest()) #digest:二进制hash print(f.hexdigest()) #hexdigest:十六进制hash #md5 hash = hashlib.md5() hash.update(b&apos;admin&apos;) print(hash.hexdigest()) #sha1 hash = hashlib.sha1() hash.update(b&apos;admin&apos;) print(hash.hexdigest()) #sha256 hash = hashlib.sha256() hash.update(b&apos;admin&apos;) print(hash.hexdigest()) #sha512 hash = hashlib.sha512() hash.update(b&apos;admin&apos;) print(hash.hexdigest()) hmac模块它内部对我们创建&quot;key&quot;和&quot;内容&quot;再进行处理然后再加密 import hmac f = hmac.new(b&apos;123AVC&apos;,&apos;小鸡炖蘑菇&apos;.encode(encoding=&apos;utf-8&apos;)) print(f.hexdigest()) re模块&quot;re&quot;模块一般用于正则表达式匹配 re.match() #文本从头开始搜索 re.search() #从整个文本开始搜索 re.findall() #把所有匹配到的字符放到以列表中的元素返回 re.splitall() #以匹配到的字符当作列表分隔符 re.sub() #匹配字符并替换(例:将数字替换成|并且只替换前面两个, (re.sub(&quot;[0-9]+&quot;,&quot;|&quot;,&quot;abc12de3f45gh&quot;,count=2)) 结果为:&apos;abc|de|f45gh&apos;) . #匹配换行符之外的任意字符 ^ #匹配字符开头 $ #匹配字符结尾 + #匹配前一个字符1次或多次 ? #匹配前1个字符1次或0次(例:re.search(&quot;aa?&quot;,&quot;aaa123&quot;) 结果为:aa) {m} #匹配前一个字符m次(例：re.search(&quot;[0-9]{3}&quot;,&quot;aa1x2d456&quot;) 结果为456) {n,m} #匹配前一个字符n到m次(例：re.findall(&quot;[0-9]{1,3}&quot;,&quot;aa1x2d456&quot;) 结果为:1,2,456) | #匹配左或|右的字符(例:re.search(&quot;abc|ABC&quot;,&quot;ABCxabcDN&quot;) 结果为:ABC) ... #分组匹配 \A #从字符开头匹配 (例：re.search(&quot;\A[0-9]+[a-z]\Z&quot;,&quot;1234a&quot;) 结果为:1234a) \Z #从字符结尾匹配，同$ \d #匹配数字0-9 \D #匹配非数字意外的字符(包括特殊字符) \w #匹配字母，数字 \W #匹配特殊字符 \s #匹配空白字符(例:re.search(&quot;\s+&quot;,&quot;a12gdf \r\n &quot;) 结果为:\r\n\t) 例： 1,匹配R开头，a结尾字符 ChenRonghua123 #re.search(&quot;R[a-z]+a&quot;) 2,获取#之间的字符 123#hello# #re.search(&quot;#.+#&quot;) 文档详细参考：http://www.cnblogs.com/alex3714/articles/5161349.html]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 Jdk+Tomcat的安装]]></title>
    <url>%2F2018%2F03%2F27%2Ftomcat%2F</url>
    <content type="text"><![CDATA[Java Development Kit（JDK）是太阳微系统针对Java开发人员发布的免费软件开发工具包（SDK，Software development kit）。自从Java推出以来，JDK已经成为使用最广泛的Java SDK。由于JDK的一部分特性采用商业许可证，而非开源。因此，2006年太阳微系统宣布将发布基于GPL的开源JDK，使JDK成为自由软件。 目的：公司开发人员的需要 安装的版本：jdk版本：1.8.0_121tomcat版本：8.5.13 Jdk的安装：先查询是否安装JDK [root@node1 ~]# java -version #centos7 默认是装的openjdk Openjdk version &quot;1.8.0_65&quot; OpenJDK Runtime Environment (build 1.8.0_65-b17) OpenJDK 64-Bit Server VM (build 25.65-b01, mixed mode) [root@node1 ~]# yum remove java-1.8.0-openjdk ##直接卸载 [root@node1 ~]# java -version #为什么还有在是吗？？？？ Openjdk version &quot;1.8.0_65&quot; OpenJDK Runtime Environment (build 1.8.0_65-b17) OpenJDK 64-Bit Server VM (build 25.65-b01, mixed mode) 正确的方式卸载openjdk： [root@node1 ~]# rpm -qa | grep java #查看装了那些包 java-1.7.0-openjdk-1.7.0.91-2.6.2.3.el7.x86_64 java-1.7.0-openjdk-headless-1.7.0.91-2.6.2.3.el7.x86_64 java-1.8.0-openjdk-headless-1.8.0.65-3.b17.el7.x86_64 [root@node1 ~]# rpm -e --nodeps java-1.7.0-openjdk-1.7.0.91-2.6.2.3.el7.x86_64 ##三个都要卸载 [root@node1 ~]# java -version #OK，这次卸载的很干净 -bash: /bin/java: No such file or directory 下载你需要版本的jdk地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html [root@node1 ~]# rpm -ivh /usr/java/jdk1.7.0.79.rpm #安装JDK 配置环境变量在/etc/profile尾部添加以下代码： JAVA_PATH #标记是java的内容 export JAVA_HOME=/usr/java/jdk1.8.0_121 # export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar [root@node1 ~]# source /etc/profile #使配置生效 java -version #查看是否安装成功 TOMCAT的配置和安装：Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。由于Tomcat本身也内含了一个HTTP服务器，它也可以被视作一个单独的Web服务器。但是，不能将Tomcat和Apache HTTP服务器混淆，Apache HTTP服务器是一个用C语言实现的HTTPWeb服务器；这两个HTTP web server不是捆绑在一起的。Apache Tomcat包含了一个配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。 下载并安装TOMCAT[root@node1 ~]# tar -zxvf tomcat-8.5.13.tar.gz tomcat #解压安装文件并命名为&quot;tomcat&quot; [root@node1 ~]# mv tomcat /usr/local/ 启动tomcat[root@node1 ~]# bash catalina.sh start [root@node1 ~]# curl http://localhost:8080 #能看到tomcat的欢迎页面表示ok 修改TOMCAT默认端口[root@node1 ~]# vim /usr/local/tomcat/conf/server.xml **Connector port=&quot;**80**[S1] &quot; maxHttpHeaderSize=&quot;8192&quot;##默认端口是8080,看你需求修改 maxThreads=&quot;150&quot; minSpareThreads=&quot;25&quot; maxSpareThreads=&quot;75&quot; enableLookups=&quot;false&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;100&quot; connectionTimeout=&quot;20000&quot; disableUploadTimeout=&quot;true&quot; /&gt;** [root@node1 bin]# ./shutdown.sh [root@node1 bin]# ./catalina.sh start #重新启动一下tomcat [root@node1 bin]# ss -tnlp #查看80、8005、8009是否为Java所监听 [root@node1 ~]#netstat -pant | grep 8005命令查看端口 [root@node1 ~]#fuser -v -n tcp 8005 #查看8005监听状态 -v 详细模式 -n 指定一个不同的命名空间 放行防火墙端口firewall-cmd --permanent --add-prot=80/tcp firewall-cmd --reload 开机启动[root@node1 ~]# vim /etc/rc.d/rc.local 添加下面三行内容： tomcat #标记是tomcat的内容 export JAVA_HOME=/usr/java/jdk1.8.0_121 # 是jdk安装目录 /usr/local/tomcat/bin/startup.sh start #是tomcat安装的目录 注意：修改rc.local文件添加执行权限： chmod +x rc.local 遇到的问题如果执行配置文件报错1： touch:cannot touc &apos;/usr/local/kencery/tomcat/logs/catalina.out:NO such file or directory *:报这个错只需要 mkdir /usr/local/tomcat/logs 即可 一般执行配置文件报错都会在/usr/local/tomcat/logs/catalina.out中显示 如果执行配置文件报错2： /usr/local/tomcat/bin/catalina.sh:line 435: /usr/local/java/jdk1.7.0_79/bin/java: no such file directory /usr/local/tomcat/bin/catalina.sh:line 435: /usr/local/jdk6/jre/bin/java: no such file or directory /usr/local/tomcat/bin/catalina.sh:line 435: /usr/local/jdk1.7.0_79//jre/bin/java: no such file or directory *:报这个错 只需要打开配置文件 /usr/local/tomcat/bin/catalina.sh 然后在435行用#注释掉即可]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 HA集群之Corosync+Pacemaker+NFS+Http+Ansible]]></title>
    <url>%2F2018%2F03%2F27%2Fpacemaker%2Bcorosync%2F</url>
    <content type="text"><![CDATA[Corosync是OpenAIS发展到Wilson版本后衍生出来的开放性集群引擎工程。可以说Corosync是OpenAIS工程的一部分。OpenAIS从openais0.90开始独立成两部分，一个是Corosync；另一个是AIS标准接口Wilson。Corosync包含OpenAIS的核心框架用来对Wilson的标准接口的使用、管理。它为商用的或开源性的集群提供集群执行框架。Corosync执行高可用应用程序的通信组系统，它有以下特征：（1）一个封闭的程序组（A closed process group communication model）通信模式，这个模式提供一种虚拟的同步方式来保证能够复制服务器的状态。（2）一个简单可用性管理组件（A simple availability manager），这个管理组件可以重新启动应用程序的进程当它失败后。（3）一个配置和内存数据的统计（A configuration and statistics in-memory database），内存数据能够被设置，回复，接受通知的更改信息。（4）一个定额的系统（A quorum system）,定额完成或者丢失时通知应用程序。总结：Corosync是整合底层节点服务器，提供API个pacemaker的一个中间层 Pacemaker，是一个群集资源管理器。它实现最大可用性群集服务（亦称资源管理）的节点和资源级故障检测和恢复使用您的首选集群基础设施（OpenAIS的或Heaerbeat）提供的消息和成员能力。它可以做乎任何规模的集群，并配备了一个强大的依赖模型，使管理员能够准确地表达群集资源之间的关系（包括顺序和位置）。几乎任何可以编写脚本，可以管理作为心脏起搏器集群的一部分。pacemaker支持超过16个节点的控制 目的：利用Corosyn+Packemaker+NFS+Http实现Web高可用集群 工作原理图（图片来源于网络）： 架构图： 准备四台机器和一个虚拟IP： 虚拟IP:192.168.1.60 node1:192.168.1.51 node1.com node2:192.168.1.52 node2.com nfs :192.168.1.53 ansible:192.168.1.54 集群准备工作 两节点要时间同步，ssh访问互信，hosts名称解析一致,关闭selinux 1.修改Hosts [root@node1 ~]# vim /etc/hosts 192.168.1.51 node1.com node1 192.168.1.52 node2.com node2 [root@node1 ~]# uname -n node1.com 其他节点和上面配置一样 2.配置ansible主机 [root@ansible ~]# yum -y install ansible （需要配置eple源） [root@ansible ~]# cp hosts{,.bak} ##复制一份备用 [root@ansible ~]# vim /etc/ansible/hosts [haservers] ##定义一个ansible集群组 192.168.1.51 192.168.1.52 3.建立ssh公钥认证 [root@ansible ~]# ssh-keygent -t rsa -P&apos;&apos; ##生成公钥（一路回车就行了） [root@ansible ~]# ssh-copy-id -i .ssh/id_rsa.pub root@192.168.1.51 ##复制公钥到node1.com [root@ansible ~]# ssh-copy-id -i .ssh/id_rsa.pub root@192.168.1.52 ##复制到node2.com 4.测试一下： [root@ansible ~]# ssh node1 The authenticity of host &apos;node1 (192.168.1.51)&apos; can&apos;t be established. ECDSA key fingerprint is 85:a3:4b:1d:ab:2f:41:30:df:70:39:76:f4:08:be:02. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added &apos;node1&apos; (ECDSA) to the list of known hosts. Last login: Tue Feb 28 22:07:37 2017 [root@node1 ~]# ##没有输密码表示成功 node2节点也试一下 [root@ansible ~]# ansible all -m ping ##使用ansible测试一下 192.168.1.51 | SUCCESS =&gt; { &quot;changed&quot;: false, &quot;ping&quot;: &quot;pong&quot; } 192.168.1.52 | SUCCESS =&gt; { &quot;changed&quot;: false, &quot;ping&quot;: &quot;pong&quot; } 同步时间： [root@ansible ~]# ansible all -m yum -a &quot;name=ntpdate state=present&quot; ##各节点都装上时间服务器 [root@ansible ~]# ansible all -m shell -a &quot;ntpdate cn.pool.ntp.org&quot; ##向国家时间服务器同步 安装corosync,pacemaker,crmsh 1.首先安装corosync和pacemaker 由于corosync是pacemake的依赖包，所有安装完pacemaker后corosync自动被安装上 使用ansible安装: [root@ansible ~]# ansible all -m yum -a &quot;name=pacemaker state=present&quot; 在2个node节点确认： [root@node1~]# rpm -qa pacemaker pacemaker-1.1.13-10.el7.x86_64 [root@node1~]# rpm -qa corosync corosync-2.3.4-7.el7.x86_64 2.安装crmsh crmsh在yum仓库和epel源都没有需要去另外下载,下载后拷贝到ansible主机/crmsh http://download.opensuse.org/repositories/network:/ha-clustering:/Stable/CentOS_CentOS-7/noarch/ [root@ansible ~]#ls /crmsh asciidoc-8.6.9-32.2.noarch.rpm crmsh-scripts-3.0.0-1.2.noarch.rpm asciidoc-examples-8.6.9-32.2.noarch.rpm crmsh-test-3.0.0-1.2.noarch.rpm crmsh-3.0.0-1.2.noarch.rpm python-parallax-1.0.1-28.2.noarch.rpm [root@ansible ~]# ansible all -m shell -a &apos;mkdir /root/crmsh&apos; [root@ansible ~]# ansible all -m copy -a &quot;src=/root/crmsh/ dest=/root/crmsh/&quot; [root@ansible ~]# ansible all -m shell -a &apos;yum -y install /root/crmsh/*.rpm&apos; 两个节点确认一下: [root@node1 ~]#crm crm(live)# ##表示crmsh安装成功 配置corosync和pacemaker并启动服务 corosync配置文件修改，ansible主机上修改并部署 [root@ansible ~]# yum -y install pacemaker [root@ansible ~]# cd /etc/corosync [root@ansible ~]# cp corosync.conf.example corosync.conf [root@ansible ~]# vim corosync.conf # Please read the corosync.conf.5 manual page totem { ##集群信息 version: 2 ##版本 crypto_cipher: aes128 ##对称节点采用aes128加密方式，单项采用sha1加密 crypto_hash: sha1 interface { ringnumber: 0 ##心跳信息传递的环号码，如果有多个接口传递心跳信息，则定义多个，每个环号不同 bindnetaddr: 192.168.1.0 ##心跳信息接口的网络地址 mcastaddr: 239.255.1.1 ##心跳信息传递时使用的组播地址 mcastport: 5405 ##组播端口 ttl: 1 ##防止心跳信息环路，限定心跳信息传递的ttl值，一般是集群节点个数减去1 } } logging { ##定义日志记录方式 fileline: off to_stderr: no to_logfile: yes ##是否记录日志 logfile: /var/log/cluster/corosync.log ##日志文件位置 to_syslog: no ##是否记录到系统日志 debug: off ##关闭调试模式 timestamp: on ##时间戳标签 logger_subsys { ##记录投票子系统的日志信息 subsys: QUORUM debug: off } } quorum { provider: corosync_votequorum ##投票系统使用corosync自带 } nodelist { ##自定义的节点 node { ring0_addr:node1.com ##环0上的地址，如果此前定义了多个接口用于传递心跳信息， 则次处定义多个环上的不同地址，如ring1_addr:.... nodeid:1 } node { ring0_addr:node2.com nodeid:2 } } 创建认证文件 [root@ansible ~]# corosync-keygen -l ##由于corosync配置文件中定义了通信采用的加密方式进行，因此要生成秘钥文件 使用ansible将配置文件及认证文件全部拷贝至节点服务器，注意authkey的权限（400或600） [root@ansible ~]# ansible all -m copy -a &quot;src=/etc/corosync/authkey mode=400 dest =/etc/corosync/authkey&quot;##复制认证文件到各节点 [root@ansible ~]# ansible all -m copy -a &quot;src=/etc/corosync/corosync.confdest=/etc/corosync/corosync.conf&quot;##复制corosync配置文件到各节点 进入节点主机进行验证: [root@node1~]# ll /etc/corosync/ total 20 -r--------. 1 root root 128 Feb 23 02:47 authkey -rw-r--r--. 1 root root 2999 Feb 27 22:32 corosync.conf -rw-r--r--. 1 root root 2881 Nov 20 2015 corosync.conf.example -rw-r--r--. 1 root root 767 Nov 20 2015 corosync.conf.example.udpu -rw-r--r--. 1 root root 3278 Nov 20 2015 corosync.xml.example drwxr-xr-x. 2 root root 6 Nov 20 2015 uidgid.d 开启corosync和pacemaker服务： [root@ansible ~]# ansible all -m service -a &quot;name=corosync state=started&quot; ##启动各节点的corosync服务 [root@ansible ~]# ansible all -m service -a &quot;name=pacemaker state=started&quot; ##启动各节点的pacemaker服务 各节点查看服务状态： [root@node1~]# crm status Last updated: Tue Feb 28 23:32:05 2017 Last change: Tue Feb 28 22:03:05 2017 by root via cibadmin on node1.com Stack: corosync Current DC: node1.com (version 1.1.13-10.el7-44eb2dd) - partition with quorum 2 nodes and 3 resources configured Online: [ node1.com node2.com ] ##node1和node同时在线表示成功 配置NFS服务安装配置nfs服务 [root@nfs server ~]# yum -y install nfs-utils ##安装nfs [root@nfs server ~]# systemctl enable nfs.service ##开机启动nfs [root@nfs server ~]# systemctl start nfs.service ##启动nfs [root@nfs server ~]# firewall-cmd --permanent --add-service=nfs ##防火墙放行nfs [root@nfs server ~]# firewall-cmd --permanent --add-service=rpc-bind [root@nfs server ~]# firewall-cmd --permanent --add-service=mountd [root@nfs server ~]# firewall-cmd --reload [root@nfs server ~]# mkdir /web/storage -pv [root@nfs server ~]# vim /etc/exportfs /web/storage 192.168.1.0/24(rw) [root@nfs server ~]#exportfs -rv ##(-r表示重读配置，-v显示共享情况) [root@nfs server ~]# systemctl restart nfs.service 使用ansible挂载nfs [root@ansible ~]# ansible all -m yum -a &quot;name=nfs-utils state=present&quot; [root@ansible ~]# ansible all -m shell -a &apos;mount -t nfs 192.168.1.53:/web/storage /var/www/html&apos; 到node节点上查看是否挂载 [root@node1 ~]# df -h Filesystem Size Used Avail Use% Mounted on 192.168.1.53:/web/storage 10G 4.1G 6.0G 41% /var/www/html ansible卸载nfs（这里先卸载，因为后面集群会自动挂载） [root@ansible ~]# ansible all -m shell -a &apos;umount /var/www/html’ crmsh配置集群 [root@node1~]# crm(live)cd configure crm(live)configure# property no-quorum-policy=stop ##关闭法定票数不足 crm(live)configure# property stonith-enabled=false ##由于没有stonith设备，所以先将stonith关闭 crm(live)configure# rsc_defaults resource-stickiness=100 ##设定资源粘性值为100 crm(live)configure#primitive webip ocf:heartbeat:IPaddr params ip=192.168.1.60 ##定义虚拟IP 定义完虚拟IP可以验证一下，看各节点是否都配置成功 [root@node1~]# ip addr 2: eno16777736: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:0c:29:9b:93:76 brd ff:ff:ff:ff:ff:ff inet 192.168.1.51/24 brd 192.168.1.255 scope global eno16777736 valid_lft forever preferred_lft forever inet 192.168.1.60/24 brd 192.168.1.255 scope global secondary eno16777736 valid_lft forever preferred_lft forever inet6 fe80::20c:29ff:fe9b:9376/64 scope link valid_lft forever preferred_lft forever crm(live)configure# primitive webserver systemd:httpd op start timeout=100 op stop timeout=100 op monitor interval=60 timeout=100 ##定义使用的服务 crm(live)configure# primitive webstore ocf:heartbeat:Filesystem params directory=&quot;/var/www/html&quot; fstype=nfs op start timeout=60s op stop timeout=60s op monitor interval=60 timeout=100 ##定义使用的存储设备 crm(live)configure# group webservice webip webstore webserver ##定义集群组，要按照资源顺序来 crm(live)configure# verify ##校验 crm(live)configure# commit ##提交配置确认并生效 配置完成后查看是这样，表示成功 crm(live)# status Last updated: Wed Mar 1 01:27:39 2017 Last change: Tue Feb 28 22:03:05 2017 by root via cibadmin on node1.com Stack: corosync Current DC: node1.com (version 1.1.13-10.el7-44eb2dd) - partition with quorum 2 nodes and 3 resources configured Online: [ node1.com node2.com ] Full list of resources: Resource Group: webservice webip (ocf::heartbeat:IPaddr): Started node1.com webstore (ocf::heartbeat:Filesystem): Started node1.com webserver (systemd:httpd): Started node1.com 可以用下面几种资源约束的方法： crm(live)configure# location webstore_perfer webstore inf: node1.com ##使用location定义webstore对节点1的倾向性为正无穷 crm(live)configure# colocation webserver_with_webip inf:webserver webip ##定义两个资源的粘性，必须在一起 crm(live)configure# order webip_bef_webstore_bef_webserver mandatory: webip webstore webse ##强制资源启动顺序 crm(live)resource# migrate webip node1.com ##使用migrate进行资源转移 开始测试集群：[root@node1~]# echo The page is NFS Server &gt;&gt; /var/www/html/index.html [root@node1~]# curl http://192.168.1.60 The page is NFS Server [root@node1~]# crm node standby ##停用当前节点 [root@node1~]# crm status Node node1.com: standby Online: [ node2.com ] Full list of resources: Resource Group: webservice webip (ocf::heartbeat:IPaddr): Started node2.com webstore (ocf::heartbeat:Filesystem): Started node2.com webserver (systemd:httpd): Started node2.com 此时节点已经转移到了node2 OK，到此结束，全部成功了 遇到的问题：1、 2个节点双方都显示自己这一方在线，另一方不在线 解决方法：彻底关闭selinux 2、[root@node1 ~]#crm status ERROR: status: crm_mon (rc=107): Connection to cluster failed: Transport endpoint is not connected 解决方法：systemctl start packemaker.service ##ok!]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>HA之Corosync+Pacemaker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 搭建ntp时间服务器]]></title>
    <url>%2F2018%2F03%2F27%2Fntp-server%2F</url>
    <content type="text"><![CDATA[目的：解决实验环境中时间的一致性NTP是Network Time Protocol的简写，即网络时间协议。多个主机可以通过NTP同步系统时间。下面我们搭建一个NTP服务器，其他服务器都可以通过NTP服务器实现时间同步。首先需要确保服务器时区设置是否正确，使用timedatectl查看设置时区（Asia/Shanghai）. 准备工作:NTP服务器地址： 服务器：192.168.1.50 客户端：192.168.1.51 RPM包检查：[root@ntp server ~]# rpm -ql |grep ntp 没有安装就直接yum安装 [root@ntp server ~]# yum -y install ntp 开机启动ntp服务systemctl enable ntpd systemctl start ntpd 获取免费时间服务器地址http://www.pool.ntp.org/zone/cn 配置时间服务器:[root@ntp server ~]# vim /etc/ntp.conf server 0.cn.pool.ntp.org server 1.cn.pool.ntp.org server 2.cn.pool.ntp.org server 3.cn.pool.ntp.org fudge 127.127.0.1 stratum 3 ##设置自身为3级Ntp server NTPserver server 127.127.1.0 iburst local clock ##外部不可用时，使用本地时间 restrict 192.168.1.0 mask 255.255.255.0 nomodify ## 设置客户端的限制，nomodify允许来自哪个段的IP来同步时间但不允许改ntp服务器参数 重启服务并防火墙放行systemctl restart ntpd firewall-cmd --permanent--add-port=123/udp firewall-cmd --reload 检查 ntpq -p查看ntpd客户端测试 [root@test ~]# ntpdate 192.168.1.50 29 Mar 15:13:01 ntpdate[3895]: adjust time server 192.168.1.50 offset -0.019419 sec ##同步时间成功 [root@test ~]# hwclock -w ##重新写入硬件时钟]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Ntp Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 Nginx利用“反向代理”实现“动静分离”]]></title>
    <url>%2F2018%2F03%2F27%2FNginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[Nginx是一款免费的，开源的，高性能的HTTP服务软件，它不仅能够支持反向代理服务器，而且也可以当作IMAP/POP3代理服务。nginx不采用每客户机一线程的设计模型，而是充分使用异步逻辑，削减了上下文调度开销，所以并发服务能力更强。整体采用模块化设计，有丰富的模块库和第三方模块库，配置灵活。在Linux操作系统下，nginx使用epoll事件模型，得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于epoll的高效事件模型kqueue。而且它稳定，配置丰富，设置简单，支持热部署，而且占用系统资源少，10000个keep-alive模式下connection仅需要2.5MB内存！！！（俄罗斯的产品果然是简单粗暴） Nginx工作模式：Master/worker 一个主进程master生成一个或者多个work线程 master:负责加载和分析配置文件 work:处理并响应用户请求 特性： 异步，非阻塞，事件驱动 文件IO: sendfile ，mmap 核心模块： main: 主要用户配置错误日志，进程管理，权限控制 event: 配置epoll,kqueue,select,poll rewrite模块： 把用户请求的URL基于regex做检查，匹配时将替换为replacement指定的字符串 如果replacement是以http：//开头，则替换结果会直接重定向返回客户端 在同一个localtion中存在多个rewrite规则会自上而下逐个检查，可以使用flag控制此循环功能 last：提前结束本轮循环，进入下一轮，continuebreak：终止了，不再循环redirect：重定向，临时重定向，302permanent：永久重定向，301，重写后生成的新url给客户端，由客户端对新url进行请求 例如： localtion / { rewrite (.）.txt$ $1.html; }请求的txt文件都变成html，重写，变成了一个新的url，然后被匹配 再加上： location ~.html\$ { rewrite (.*).html $1.txt; }后，html又转化为txt了，就形成一个死循环，所以要在两个后面加上条件，break。 然后再加上个redirect，临时重定向 location / { rewrite (.*).txt$ $1.html redirect; } upstream 模块： 负载均衡，必须定义在http段落 实验目的：利用Nginx反向代理，将用户请求的动态资源反代到Web1,静态资源反代到Web2 架构图： 虚拟机实验环境1.关闭selinux和清空iptables 2.所有主机同步时间 3.Nginx反向代理服务器内网网卡选择VMNET8虚拟网络连接 4.Web1部署LAMP平台，Web2部署httpd 网络配置 客户端IP：192.168.1.158 Nginx反向代理服务器IP： 外网：192.168.1.51 内网：192.168.42.130 后端Web服务器IP： Web1：192.168.42.128 Web2：192.168.42.129 服务安装Nginx服务器安装nginx软件包： [root@nginx /]# yum -y install nginx ##需要配置好epel源 Web1服务器配置搭建LAMP平台： [root@Web1 /]# yum -y install httpd mariadb-server php php-mysql php-gd libjpeg* php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-bcmath php-mhash 新建测试页 vim /var/www/html/index.php &lt;?php phpinfo(); ?&gt; [root@Web1 /]# curl http://192.168.42.128 能看到php测试页表示ok Web2服务器配置httpd服务 [root@Web2 /]# yum -y install httpd 安装完后新建测试页 curl http://192.168.42.129 能看到表示ok nginx配置反向代理[root@nginx nginx]# cp nginx.conf{,.bak} ##先做备份 主要配置： proxy_set_header NWC_TEST $remote_addr; ##定义日志首部 location / { root /usr/share/nginx/html; index index.html index.htm; proxy_pass http://192.168.42.129; } location ~ \.php$ { proxy_pass http://192.168.42.128; index index.php index.html index.htm; } 测试http://192.168.1.51/index.php|index.html 能看到.php页面和.html页面的内容和WEB1,WEB2相同表明OK 设置RS的请求报文首部在nginx主机上添加 proxy_set_header NWC_TEST $remote_addr; 利用proxy_set_header指令，设置nginx反代用户请求到后端主机上时，为请求报文添加一个首部， 首部名称为NWC_TEST,首部对应的值为$remote-addr对应的值，也就是真是客户端IP地址 修改完nginx服务器，再到后端主机修改日志格式 LogFormat &quot;%{NWC_TEST}i %h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%{Referer}i\&quot; \&quot;%{User-Agent}i\&quot;&quot; combined]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 LB集群之LVS（一）]]></title>
    <url>%2F2018%2F03%2F27%2FLVS%2BNAT%2F</url>
    <content type="text"><![CDATA[LVS(linux virtue server)是一个虚拟的服务器集群系统。项目在1998年5月由章文嵩成立，是中国国内最早出现的自由软件项目之一。LVS集群采用IP负载均衡技术和基于内容请求分发技术。调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。整个服务器集群的结构对客户是透明的，而且无需修改客户端和服务器端的程序。为此，在设计时需要考虑系统的透明性、可伸缩性、高可用性和易管理性。 目的：利用LVS实现负载均衡 模型图： 配置IPlvs eth0： 192.168.1.103（VIP） eth1： 192.168.201.138（DIP）web1 eth0：192.168.201.137 lo：192.168.201.103web2 eth0：192.168.201.132 lo ：192.168.201.103 安装http服务[root@WEB1 ~]# yum -y install httpd[root@WEB1 ~]# systemctl enable http.service[root@WEB1 ~]# systemctl start http.service[root@WEB1 ~]# echo “1” &gt;/var/www/html/index.html[root@WEB1 ~]# curl http://localhostWEB2同上 安装ipvsadm[root@WEB1 ~]# yum -y install ipvsadm[root@WEB1 ~]# modprobe ip_vs #加载到内核[root@WEB1 ~]# ipvsadm #查看是否安装成功 配置IPVS[root@WEB1 ~]#ipvsadm -C 清空原来表格内容[root@WEB1 ~]# ipvsadm -A -t 192.168.1.103:80 -s rr #创建一个集群 -A添加地址 -t指定vip tcp端口 -s指定算法[root@WEB1 ~]# ipvsadm -a -t 192.168.1.103:80 -r 192.168.201.137:80 -m -a指定真实服务器 -t lvs上的vip -r 真实服务器[root@WEB1 ~]# ipvsadm -a -t 192.168.1.103:80 -r 192.168.201.132:80 -m -a指定真实服务器 -t lvs上的vip -r 真实服务器[root@WEB1 ~]# ipvsadm -L -n 查看IP Virtual Server version 1.2.1(size=4096)Prot LocalAddress:PortScheduler Flags-&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 192.168.1.103 wrr persistent 20-&gt; 192.168.201.137 Route 1 0 0-&gt; 192.168.201.132 Route 1 0 0 …表示成功了 配置RS给WEB1服务器配置VIPifconfig lo 192.168.1.103 netmask 255.255.255.255WEB2设置同上 验证浏览器输入VIP地址 192.168.1.103看WEB1和WEB2是不是轮询响应，down掉一个还能否响应]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Lvs+NAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 Mysql双主模型]]></title>
    <url>%2F2018%2F03%2F27%2Fmysql%E5%8F%8C%E4%B8%BB%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Mysql双主模型可以在一定程度上保证主库的高可用,在一台主库down掉之后,可以在极短的时间内切换到另一台主库上（尽可能减少主库宕机对业务造成的影响），减少了主从同步给线上主库带来的压力； 目的：利用双主模型来提高系统的可用性 模型图（来源于网络）： 准备工作1、为了不影响实验结果，建议关闭Selinux和Iptables2、两台服务器时间要同步3、两台服务器都要启动中继日志，二进制日志4、主服务器1: 192.168.1.60 主服务器2：192.168.1.61 安装Mariadb[root@mysql-masster1 /]# yum -y install mariadb-server mariadb第二台服务器一样直接安装 修改主配置文件Master1配置： [root@mysql-masster1 /]# vim /etc/my.cnf [mysqld] server_id=1 ##设定全局唯一的server_id log_bin=master-log ##启用二进制日志，指明二进制日志的存放路径及名称 relay_log=relay-log ##启用中继日志，指明中继日志的存放路径及名称 auto_increment_offset=1 ##避免自增长字段的冲突值，设置本机的自增长字段从1开始，每次增长2 auto_increment_increment=2 skip-name-resolve=ON ##禁止名称解析 innodb-file-per-table=ON ##innodb存储引擎每表一个表空间 Master2配置： [root@mysql-masster2 /]# vim /etc/my.cnf [mysqld] server_id=2 ##设定全局唯一的server_id log-bin=master-log ##启用二进制日志，指明二进制日志的存放路径及名称 relay-log=relay-log ##启用中继日志，指明中继日志的存放路径及名称 auto_increment_offset=2 ##避免自增长字段的冲突值，设置本机的自增长字段从1开始，每次增长2 auto_increment_increment=2 skip-name-resolve=ON ##禁止名称解析 innodb-file-per-table=ON ##innodb存储引擎每表一个表空间 **Master1和Master2配置完成后，重新启动mariadb服务** 登录MySQL用户授权Master1配置： [root@mysql-masster1 /]#mysql -uroot -p MariaDB [mysql]&gt; grant replication client,replication slave on *.* to &apos;repluser&apos;@&apos;192.168.1.61&apos; identified by &apos;redhat&apos;; MariaDB [mysql]&gt; flush privileges; MariaDB [mysql]&gt; show master logs; ##查看二进制日志列表和当前正在使用的二进制日志的文件位置 MariaDB [mysql]&gt; show master status; +-------------------+----------+--------------+------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | +-------------------+----------+--------------+------------------+ | master-log.000001 | 245| | | | +-------------------+----------+--------------+------------------+ MariaDB [mysql]&gt; ls /var/lib/mysql/ 查询二进制文件是否存在 Master2配置： [root@mysql-masster2 /]#mysql -uroot -p MariaDB [mysql]&gt; grant replication client,replication slave on *.* to &apos;repluser&apos;@&apos;192.168.1.60&apos; identified by &apos;redhat&apos;; MariaDB [mysql]&gt; flush privileges; MariaDB [mysql]&gt; show master logs; MariaDB [mysql]&gt; show master status; +-------------------+----------+--------------+------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | +-------------------+----------+--------------+------------------+ | master-log.000003 | 2109 | | | +-------------------+----------+--------------+------------------+ MariaDB [mysql]&gt; ls /var/lib/mysql/ 定义2个节点 在两个节点上定义复制时的属性，启动复制线程 Master1的配置： MariaDB [mysql]&gt; change master to master_host=&apos;192.168.1.61&apos;, ##指定的Master主机 master_user=&apos;repluser&apos;, ##以哪个用户的身份练上去 master_password=&apos;redhat&apos;, ##连接用户的密码 master_log_file=&apos;master-log.000003&apos;, ##主节点的二进制日志文件 master_log_pos=2109; ##主节点的二进制日志所在位置 Master2的配置： change master to master_host=&apos;192.168.1.60&apos;, master_user=&apos;repluser&apos;, master_password=&apos;redhat&apos;, master_log_file=&apos;master-log.000001&apos;, master_log_pos=245; 启动复制线程 [root@mysql-masster2 /]#mysql -uroot -p MariaDB [mysql]&gt;start slave; ##启动复制线程 MariaDB [mysql]&gt;show salve status; Slave_IO_Running:YES ##IO线程和SQL线程 Slave_SQL_Running:YES 两个线程都是YES，表明成功了，如果IO线程状态是Connecting 请退出MySQL，这个地方稍微有点延迟,重新启动一下mariadb服务，再连进去查看线程状态 双主服务器互相验证在Master1上创建一个testdb库，看Master2能否看见。Master2在testdb库中创建t1表，Master1能看见表明成功Master1在t1插入数据，Master能看见表示成功]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Mysql双主模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 Mysql主从同步]]></title>
    <url>%2F2018%2F03%2F27%2FMysql-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[MySQL主从同步：MySQL的主从复制广泛用于数据库备份、故障转移、数据分析等场合主从同步原理*：通过设置在Master MySQL上的binlog(使其处于打开状态)，Slave MySQL上通过一个I/O线程从Master MySQL上读取binlog，再传输到Slave MySQL的中继日志中，然后Slave MySQL的SQL线程从中继日志中读取中继日志，应用到Slave MySQL的数据库中。这样实现了主从数据同步功能。 目的：主从复制能够有效的缓解数据库读写的压力 模型图（图片来源于网络）： 环境的准备1.Mysql主备之前版本必须一致 2.为了不影响实验结果建议关闭&apos;Selinux&apos; 主服务器：mysql-master: 192.168.1.60 从服务器：mysql_slave: 192.168.1.61 安装Mariadb [root@mysql-master /]yum -y install mariadb mariadb-server [root@mysql-master /]systemctl enable mariadb.service ##开机启动mariadb服务 [root@mysql-master /]systemctl start mariadb.service ##启动mariadb服务 [root@mysql-master /]mysql_secure_installation ##初始化Mysql 从服务器同上操作 修改配置文件主服务器的配置文件（/etc/my.cnf）,开启日志功能，设置server_id 保证唯一 [root@mysql-master tmp]# vim /etc/my.cnf 加入以下两行内容 [mysqld] server_id = 200 ##server_id 同步复制时标识该语句最初是从哪个server写入的 log-bin=mysql-bin ##开启二进制功能 保存退出，重启服务器 数据库授权[root@mysql-master /]# mysqldump -uroot -p MariaDB [mysql]&gt; grant replication slave,reload,super on *.* to &apos;slave&apos;@&apos;192.168.1.60&apos; identified by &apos;slavepass&apos; MariaDB [mysql]&gt;flush privileges ##重读授权表信息 注释： ‘replication slave’拥有此权限可以查看从服务器，从主服务器读取二进制日志 ‘reload’权限，才可以执行flush [tables | logs | privileges] ‘super’这个权限允许用户终止任何查询；修改全局变量的SET语句；使用CHANGE MASTER，PURGE MASTER LOGS。 MariaDB [mysql]&gt;show master status; ##查看主服务的状态 +----------------------+----------+--------------+------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | +----------------------+----------+--------------+------------------+ | mysql-bin.000002 | 245| | | +----------------------+----------+--------------+------------------+ 主从备份为保证主DB server和从DB server的数据一致,这里采用主备份,从还原来实现初始数据一致 MariaDB [mysql]&gt;flush tables with read lock; ##加临时锁，表只读 [root@mysql-master /]# mysqldump -uroot -p --all- databases &gt; /home/backup.sql ##复制所有 数据库到/home/ [root@mysql-master /]# unlock tables; J##解锁 [root@mysql-master /]# scp /home/backup.sql ‘root’@‘192.168.1.61’：/home/ ##将备份数据发送到从服务器，用于恢复 配置Slave[root@mysql-slave /]# vim /etc/my.cnf server_id=201 ##设置server_id Slave还原备份数据[root@mysql-slave /]#systemctl restart mariadb.service [root@mysql-slave /]#mysql -uroot -p &lt; /home/backup.sql 连接Master服务器登陆从数据库,添加相关参数(主服务器的ip/端口/同步用户/密码/position号/读取哪个日志文件) [root@mysql-slave /]#mysql -uroot -p MariaDB [mysql]&gt;change master to master_host=&apos;192.168.1.60&apos;,master_user=&apos;slave&apos;,master_password=&apos;slavepass&apos;, master_log_file=&apos;mysql-bin.000002&apos;,master_log_pos=245; ##开启主从同步 MariaDB [mysql]&gt;start slave; ##查看主动同步状态 MariaDB [mysql]&gt;show slave status\G; ##主要看下面2项，都是YES表示成功了 Slave_IO_Running: Yes Slave_SQL_Running: Yes Master和Slave验证上面都没问题，那就开始测试了，去主服务断创建一个库，一张表，插入数据，再到从服务器来查看，如果数据一致表示没问题了 遇到的问题ERROR 2002 (HY000): Can&apos;t connect to local MySQL server through socket &apos;/tmp/mysql.sock&apos; (2) ####解决办法：在错误日志中，启动失败的原因极为明显，file ‘./mysql-bin。000004’ not found，failed to open！ mysql开启了bin日志功能，到数据库根目录查看该文件是存在的，可能是文件权限的问题。 [root@mysql-slave /]chown -R mysql:mysql /var/log/mysql [root@mysql-slave /]mysqld_safe &amp; ##启动安全模式 [root@mysql-slave /]systemctl stop mariadb.service [root@mysql-slave /]systemctl start mariadb.service ###再重新初始化数据库，就可以登录了 记得killall mysqld_safe mysql，因为不结束将不能开启二进制日志，结束安全模式进程然后 [root@mysql-slave /]systemctl stop mariadb.service [root@mysql-slave /]systemctl start mariadb.service]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Mysql主从同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 LVS集群+Keepalived（二）]]></title>
    <url>%2F2018%2F03%2F27%2FLVS%2BKeepalived%2F</url>
    <content type="text"><![CDATA[LVS是Linux Virtual Server的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统。本项目在1998年5月由章文嵩博士成立，是中国国内最早出现的自由软件项目之一。目前有三种IP负载均衡技术（NAT、DR、TUN），十种调度算法（rr|wrr|lc|wlc|lblc|lblcr|dh|sh|sed|nq）Keepalived在这里主要用作RealServer的健康状态检查以及Master主机和BackUP主机之间failover的实现下面，搭建基于LVS+Keepalived的高可用负载均衡集群，其中，LVS实现负载均衡，但是，简单的LVS不能监控后端节点是否健康，它只是基于具体的调度算法对后端服务节点进行访问。同时，单一的LVS又存在单点故障的风险。在这里，引进了Keepalived，可以实现以下几个功能：1. 检测后端节点是否健康2. 实现LVS本身的高可用 目的：解决DR模型下Director单点故障 模型图： 准备工作:DR1: vip :192.168.1.150 eno16777736:192.168.1.130 DR2 : vip :192.168.1.150 eno16777736:192.168.1.131 RS1: eno16777736:192.168.1.132 lo:192.168.1.150 netmask 255.255.255.255 ##4个255表示将广播域限制在本机 RS2: eno16777736:192.168.1.133 lo:192.168.1.150 netmask 255.255.255.255 网络配置完成后都互相ping一下，看是不是都配通了 注意问题：1.清空iptables规则 iptables -t filter -F2.关闭selinux setenforce 0 安装httpdyum -y install httpd systemctl enable httpd.service 开启启动httpd服务 systemctl start httpd.service 启动服务 echo “WEB1”&gt;/var/www/html/index.html 在httpd下写一个 测试网页 curl http://localhost 测试一下看能不能看到“WEB1” 配置完后把VIP指向RS1 ifconfig lo 192.168.1.150 netmask 255.255.255.0 【DR2】配置同上 RS服务器上也要关闭防火墙，关闭selinux 安装ipvsyum -y install ipvsadm modprobe ip_vs #加载到内核 lsmod |grep ip_vs #查看是否有ipvs模块 【DR2】上同上配置 安装keepalivedyum -y install keepalived systemctl enable keepalived 开机启动 systemctl start keepalived 启动程序 yum -y install httpd ##这里装httpd做Server—server echo &lt;h1System upgrade maintenance &lt;\h1&gt;/var/www/html/index.html systemctl start httpd 修改配置:vim /etc/keepalived/keepalived.conf 配置文件如下： global_defs { notification_email { acassen@firewall.loc #设置报警邮件地址，可设置多个，每行一个 failover@firewall.loc #需要开启右键报警以及本机的sendmail服务 sysadmin@firewall.loc } notification_email_from Alexandre.Cassen@firewall.loc smtp_server 127.0.0.1 #设置SMTP Server地址 smtp_connect_timeout 30 router_id LVS_DEVEL } vrrp_instance VI_1 { state MASTER #指定keepalived的角色，MASTER为主服务器，BACKUP为备用服务器 interface eno16777736 virtual_router_id 50 priority 100 #定义优先级，数字越大，优先级越高，主Direvtor必须大于备用Director advert_int 1 authentication { auth_type PASS #设置验证类型 auth_pass 1111 #设置验证密码,最好随机生成几位数字 } virtual_ipaddress { 192.168.1.150 #设置主Director的VIP } virtual_server 192.168.1.150 80 { 设置VIP地址和端口 用空格隔开 delay_loop 6 #设置健康检查时间，单位为秒 lb_algo rr #设置负载均衡调度算法，默认为rr，即轮循算法，最优秀的是wlc算法 lb_kind DR #设置LVS实现LB机制，有NAT,DR,TUN三种模式 nat_mask 255.255.255.0 persistence_timeout 50 #回话保持时间，单位为秒 protocol TCP #指定转发协议类型，有TCP和UDP两种 real_server 192.168.1.132 80 { weight 2 #配置节点权值，数字越大权值越高 HTTP[_GET { url { path / digest ff20ad2481f97b1754ef3e12ecd3a9cc } url { path /mrtg/ digest 9b3a0c85a887a256d6939da88aabd8cd connect_timeout 3 #表示3秒无响应，则超时 nb_get_retry 3 #表示重试次数 delay_before_retry 3 #表示重试间隔 sorry_server 127.0.0.1 80 ##所有节点都down掉了， soory_server可以当real_server使用，或者定义升级维护页面 real_server 192.168.1.113 80 { weight 1 # HTTP_GET { # url { # path / # digest ff20ad2481f97b1754ef3e12ecd3a9cc # } #url { # path /mrtg/ #digest 9b3a0c85a887a256d6939da88aabd8cd # } connect_timeout 3 nb_get_retry 3 delay_before_retry 3 } } 【DR2】配置大致同上，只需修改部分参数 1. 把state MASTER 改为 state BACKUP 2. 把priority 100 的优先值改成90 然后保存即可 重启服务systemctl restart keepalived.service [DR1]#ipvsadm -L -n 出现以下信息表示配置成功，没有就返回上一步排错 IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags -RemoteAddress:Port Forward Weight ActiveConn InActConn TCP 192.168.1.150:80 rr persistent 50 -192.168.1.113:80 Route 1 0 0 -192.168.1.132:80 Route 2 0 0 抑制ARP响应（防止将后端Real Server暴露在公网） 【DR1】# echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore 【DR1】# echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/lo/ arp_announce 【DR1】# echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignore 【DR1】# echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announce arp响应限制: 1）arp_ignore: 0 - (默认值): 回应任何网络接口上对任何本地IP地址的arp查询请求 1 - 只回答目标IP地址是来访网络接口本地地址的ARP查询请求 2）arp_announce: 0 - (默认) 在任意网络接口（eth0,eth1，lo）上的任何本地地址 2 - 对查询目标使用最适当的本地地址.在此模式下将忽略这个IP数据包的源地址并尝试选择与能与该地址通信的本地地址. 首要是选择所有的网络接口的子网中外出访问子网中包含该目标IP地址的本地地址. 如果没有合适的地址被发现,将选择当前的发送网络接口或其他的有可能接受到该ARP回应的网络接口来进行发送. 测试DR1和DR2上把keepalived服务都启动起来systemctl keepalived status 查看服务当前状况在浏览器输入“192.168.1.150” 看能否看到“WEB1”和“WEB2”将DR2关掉看能否访问到“192.168.1.150”还能看到“WEB1”“WEB2”恭喜你 成功了！！！]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Lvs+Keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 LAMP黄金组合之wordpress]]></title>
    <url>%2F2018%2F03%2F27%2Flamp%2Bweordpress%2F</url>
    <content type="text"><![CDATA[WordPress是一个注重美学、易用性和网络标准的个人信息发布平台。WordPress虽为免费的开源软件，但其价值无法用金钱来衡量。WordPress的图形设计在性能上易于操作、易于浏览；在外观上优雅大方、风格清新、色彩诱人。使用WordPress可以搭建功能强大的网络信息发布平台，但更多的是应用于个性化的博客。针对博客的应用，WordPress能让您省却对后台技术的担心，集中精力做好网站的内容。目的：LAMP搭建wordpress博客 准备工作： 1.上来先关闭防火墙 iptables -F 2.ping以下网络是否通畅 ping www.baidu.com 安装Httpd[root@wp ~]# yum -y install httpd [root@wp ~]# systemctl start httpd.service #启动httpd 防火墙放行80端口以及http服务 [root@wp ~]#firewell-cmd --permanent --add-service=http [root@wp ~]#fireewll-cmd --reload #重启防火墙生效 地址栏输入http://localhost 能看到apche测试页面即成功 安装mariadb[root@wp ~]# yum -y install mariadb mariadb-server [root@wp ~]# systemctl enabled mariadb.service #开机启动mysql [root@wp ~]# systemctl start mariadb.service #启动mysql 初始化mysql并设置密码： [root@wp ~]# mysql_secure_installation Enter current password for root (enter for none): #初次运行直接回车 Set root password? [Y/n] #是否设置root用户密码，输入y并回车或直接回车 New password: #设置root用户的密码 Re-enter new password: #再输入一次你设置的密码 Remove anonymous users? [Y/n] #是否删除匿名用户，回车 Disallow root login remotely? [Y/n] #是否禁止root远程登录 ,回车, Remove test database and access to it? [Y/n] # 是否删除test数据库,回车 Reload privilege tables now? [Y/n] #是否重新加载权限表，回车 始化MariaDB完成，接下来测试登录 root@wp ~]# mysql -u root -p #登录mysql 安装php[root@wp ~]# yum install php php-mysql php-gd libjpeg* php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-bcmath php-mhash [root@wp ~]# vim /var/www/html/index.php &lt;?php phpinfo(); ?&gt; 保存退出！ systemctl restart httpd.service 浏览器地址栏输入http://localhost 能看到php测试页面即成功 配置wordpress进入wordpress目录 [root@wp ~]# cd /wordpress [root@wp ~]# cp wp-config-sample.php wp-config.php #复制主配置文并改名为wp-config.php 开始配置wp-config.php [root@wp ~]# vim wp-config.php / ** MySQL settings - You can get this info from your web host ** // /** The name of the database for WordPress */ define(&apos;DB_NAME&apos;, &apos;wordpressdb&apos;); #数据库名称 /** MySQL database username */ #数据库用户名 define(&apos;DB_USER&apos;, &apos;wordpressuser&apos;); /** MySQL database password */ #数据库密码 define(&apos;DB_PASSWORD&apos;, &apos;wordpresspassword&apos;); wq保存退出 配置完成后将wordpress目录下所有文件移动到/var/www/html下 chown -R apache:apache /var/www/html/ chmod -R 755 /var/www/html mysql授权配置[root@wp ~]# mysql -u root -p MariaDB [mysql]&gt; create database wordpressdb; #（创建库） MariaDB [mysql]&gt; create user wordpressuser@localhost identified by &apos;wordpresspassword&apos;; #（创建用户并设置密码） MariaDB [mysql]&gt; grant all privileges on wordpressdb.* to wordpressuser@localhost; #(给wordpressuser对wordpress授取所有权) MariaDB [mysql]&gt; flush privileges; #（重读数据库变量） 配置完重启服务: MariaDB [mysql]&gt; service httpd restart MariaDB [mysql]&gt; service mariadb restart #我一般不喜欢用Phpmyadmin，直接用Navicat 配置Wordpress浏览器地址栏输入http://localhost配置成功后应该是这个样子的，主题相关参数自行配置，是不是很时尚，wordpress有很多时尚的主题自己选择一个安装吧吧]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 HAproxy实现反向代理和资源动静分离]]></title>
    <url>%2F2018%2F03%2F27%2Fhaproxy%2F</url>
    <content type="text"><![CDATA[HAProxy 是一款提供高可用性、负载均衡以及基于TCP（第四层）和HTTP（第七层）应用的代理软件， 支持虚拟主机，它是免费、快速并且可靠的一种解决方案。 HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。HAProxy运行在时下的硬件上，完全可以支持数以万计的 并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中， 同时可以保护你的web服务器不被暴露到网络上。HAProxy 实现了一种事件驱动、单一进程模型，此模型支持非常大的并发连接数。多进程或多线程模型受内存限制 、系统调度器限制以及无处不在的锁限制，很少能处理数千并发连接。 事件驱动模型因为在有更好的资源和时间管理的用户端(User-Space) 实现所有这些任务，所以没有这些问题。此模型的弊端是，在多核系统上，这些程序通常扩展性较差。这就是为什么他们必须进行优化以 使每个CPU时间片(Cycle)做更多的工作。 总结：HAproxy只是Http协议的反向代理，不提供内存，但额外支持对TCP层基于Http通信的应用做负载均衡 架构图 HAproxy工作模式： 1、Http反向代理 2、TCP连接负载均衡 HAproxy的配置文件格式： global: 设定全局配置参数 proxy：定义”defaults” “listen” “frontend” “backend” 三台主机： HAProxy:192.168.1.51 Web1:192.168.1.52 Web2:192.168.1.53 目的：利用HAproxy实现反向代理和资源动静分离 利用HAproxy实现反向代理Web1主机安装httpd [root@web1 ~]# yum -y install httpd [root@web1 ~]# echo web1 &gt; /var/www/html/index.html [root@web1 ~]# systemctl start httpd [root@web1 ~]# firewall-cmd --permanent --add-service=http [root@web1 ~]# firewall-cmd --reload [root@web1 ~]# curl http://192.168.1.52 web1 Web2主机配置同上 Proxy主机安装HAproxy [root@proxy ~]# yum -y install haproxy.x86_64 [root@proxy ~]# vim /etc/haproxy/haproxy.cfg chroot /var/lib/haproxy #工作目录 pidfile /var/run/haproxy.pid #pid文件 maxconn 4000 #最大连接数 user haproxy #进程启动以哪个用户来运行 group haproxy daemon #启动为守护进程，不加daemon将会运行在前台 frontend main *:80 #监听的端口 efault_backend webserver backend webserver balance roundrobin #使用roundrobin算法（rr轮询） #用法:server &lt;name&gt; &lt;addr&gt;[:port] [param] server web1 192.168.1.52:80 check weight=1 #check做健康监测，默认2秒一次,weight定义权重 server web2 192.168.1.53:80 check weight=1 [root@proxy ~]# systemctl start haproxy.service [root@proxy ~]# curl http://192.168.1.51 web1 [root@proxy ~]# curl http://192.168.1.51 web2 [root@proxy ~]# firewall-cmd --permanent --add-port=80/tcp [root@proxy ~]# firewall-cmd --reload 基于浏览器cookie实现session stickebackend webserver balance roundrobin cookie SERVERID insert nocahe #设置cookie,insert插入，nocache不允许缓存，indirect间接方式让cookie生效 server web1 192.168.1.52:80 check weight=1 cookie websrv1 #绑定cookie并指定cookie名称 server web2 192.168.1.53:80 check weight=1 cookie websrv2 要点： （1）每个server有自己唯一的cookie标识 （2）在backend中定义为用户请求调度完成操作其cookie Haproxy的几种调度方法动态：（权重可以动态调整） 静态：（调整权重不会立即生效，需要重启服务生效） 1、Roundrobin(rr轮询）:根据权重的比率在服务器之间公平调度，每个后端服务器最多可以承载4128个并发连接，属于动态 2、Leastcinn: 根据后端服务器的负载数量进行调度，仅适用于长连接回话，属于动态 3、Static（rr轮询）:和roundrobin类似，但是不支持实时修改权重，后端服务器并发连接理论没有上限，属于静态， 4、Source：将连接请求的源地址进行Hash计算，并由后端服务器的权重总和相除后转发至匹配的服务器，是否静态或动态，取决于Hash-type 5、URI: 对uri左半部分或对整个uri进行Hash计算,并由服务器的总权重相除后派至匹配后的某个服务器，特别适用于代理缓存服务器应用场景 6、Hdr&lt;name&gt;: 根据请求报文中指定的header,（如：user_agent,referer,hostname）进行调度，把指定的header的值做hash计算,Hash_type 7、URL_param: 根据url中指定参数的值进行调度，把值做Hash计算，并除以总权重，Hash_type ##只要用到Hash算法，就会根据Hash_type的值来确定是动态还是静态 Hash-type： 1、map-hash(取模法)，静态 2、consistent(一致性哈希)，动态 配置stats管理界面[root@proxy ~]# vim /etc/haproxy/haproxy.cfg frontend main bind *:80 default_backend webserver listen stat bind 192.168.1.51:9000 #管理页面的端口 stats enable #开启stats页面 stats hide-version #隐藏版本号 stats uri /admin #访问stats的url stats realm haproxy\ admin\ area #需要认证时，认证框里面的提示信息 stats auth admin:admin #认证的账号和密码（user:password） stats refresh 5s #打开页面后每秒刷新间隔 stats admin if TRUE #是否开启管理功能 然后浏览器输入 192.168.1.51:9000/admin 根据提示输入用户和密码 密码验证： 管理界面： 利用Haproxy实现动静分离[root@proxy ~]# vim /etc/haproxy/haproxy.cfg frontend main bind *:80 default_backend dynamic #默认backend为dynamic acl url_static path_end -i .php #访问控制列表，匹配结尾.php资源 use_backend static if url_static #如果结尾是.php，则backend为static backend static balance roundrobin #这里使用roundrobin算法 server dynamic 192.168.1.53:80 check backend dynamic balance uri#这里使用uri算法 server static 192.168.1.52:80 check 客户端资源验证静态资源动态资源]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>HAproxy</tag>
      </tags>
  </entry>
</search>
